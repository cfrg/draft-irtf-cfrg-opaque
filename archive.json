{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-07-14T01:24:22.892892+00:00",
  "repo": "cfrg/draft-irtf-cfrg-opaque",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "next-version",
      "description": "Issue to fix in next version",
      "color": "86E6A4"
    },
    {
      "name": "editorial",
      "description": "Editorial",
      "color": "c5def5"
    },
    {
      "name": "optional",
      "description": "Nice to have, but not necessary and won't block forward progress",
      "color": "DEBBFA"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU2MjAyNDU1MjQ=",
      "title": "Drop TLS integration details",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/2",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should reference and rely on [1] when it's updated.\r\n\r\n[1] https://tools.ietf.org/html/draft-sullivan-tls-opaque-00",
      "createdAt": "2020-05-18T14:15:17Z",
      "updatedAt": "2020-06-19T15:14:46Z",
      "closedAt": "2020-06-19T15:14:46Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2MjAyNDg5NTU=",
      "title": "Move security property discussion to considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/3",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will shorten the introduction and help readers get straight to the protocol details. HPKE does a good job with this sort of structure, so we might look there as a guide.",
      "createdAt": "2020-05-18T14:19:28Z",
      "updatedAt": "2020-10-28T13:03:22Z",
      "closedAt": "2020-10-28T13:03:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This has since been done.",
          "createdAt": "2020-10-28T13:03:22Z",
          "updatedAt": "2020-10-28T13:03:22Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2MjAyNDkzNDk=",
      "title": "Clarify server trust",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should we clarify how much trust we place in the server? For example, since OPAQUE stores encrypted keys in the server, and that same server has the OPRF secret key, it could in theory do a dictionary attack and recover the private key for each user. This is pretty nonsensical, but I think it does highlight that OPAQUE assumes the server is honest-but-curious, rather than entirely malicious.\r\n\r\nThis is sort of fundamental, but some folks might miss it.",
      "createdAt": "2020-05-18T14:19:58Z",
      "updatedAt": "2020-12-21T16:45:52Z",
      "closedAt": "2020-12-21T16:45:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is already discussed in the \"Password salt and storage implications\" section. Closing.",
          "createdAt": "2020-12-21T16:45:51Z",
          "updatedAt": "2020-12-21T16:45:51Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU2MjAyNTQwMzM=",
      "title": "Reconsider \"cost\" details section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/5",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The \"cost\" details are written assuming a traditional DH-based KE protocol. Should we try to generalize this, e.g., to cover KEM-based protocols? Moreover, the cost details might not age well as TLS 1.3 develops and possibly moves away from signatures, via, e.g., semi-static DH. Or we might just remove this section entirely. ",
      "createdAt": "2020-05-18T14:25:57Z",
      "updatedAt": "2020-11-02T22:18:22Z",
      "closedAt": "2020-11-02T22:18:22Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2MjAyNTQ0MDA=",
      "title": "Add wire format details for registration and login flow messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/6",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TLS notation would be easiest, given its ubiquity. ",
      "createdAt": "2020-05-18T14:26:28Z",
      "updatedAt": "2020-06-04T23:18:09Z",
      "closedAt": "2020-06-04T23:18:09Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2MjAyNTQ5NTM=",
      "title": "Highlight the importance of IdU and IdS in the envelope and post-OPRF AKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Endpoints MUST agree on these identities (and use the right values!) for security. ",
      "createdAt": "2020-05-18T14:27:09Z",
      "updatedAt": "2020-12-17T01:58:59Z",
      "closedAt": "2020-12-17T01:58:59Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is pretty much covered now. Closing.",
          "createdAt": "2020-12-17T01:58:59Z",
          "updatedAt": "2020-12-17T01:58:59Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2MjA1ODA5MTM=",
      "title": "Typo in 3DH key derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The key K3dh needs to computed by the server as\r\n K3dh = ePubU^ePrivS | ePubU^PrivS | PubU^ePrivS\r\nThe current draft inverts the order between the last two elements making it inconsistent with the way the client computes the key.\r\n(Reported by Kevin Lewi)",
      "createdAt": "2020-05-19T00:09:37Z",
      "updatedAt": "2020-05-19T22:17:38Z",
      "closedAt": "2020-05-19T16:43:28Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "As you see my github skills improved significantly, but the truth I did\nthese postings guided by someone else :-)\n\nCan I  address pull requests directly? DO you need to define me as\ncontributor? Or is it better that I let you push changes?\n\n\n-- Hugo\n\nHelp build a *worldwide repository* of COVID-19 data\n<https://iReport.algorand.org>, open to all, everywhere.\n\n\nOn Tue, May 19, 2020 at 12:43 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> Closed #8 <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8> via\n> #10 <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/10>.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8#event-3352769127>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXKFQIYX44QTCJJHK3RSKZL7ANCNFSM4NEQVXEQ>\n> .\n>\n",
          "createdAt": "2020-05-19T19:50:30Z",
          "updatedAt": "2020-05-19T19:50:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I forgot to add you as a contributor! Oops. Let me do that now.",
          "createdAt": "2020-05-19T19:58:52Z",
          "updatedAt": "2020-05-19T19:58:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Also, add yourself as an author.\n\n-- Hugo\n\nHelp build a *worldwide repository* of COVID-19 data\n<https://iReport.algorand.org>, open to all, everywhere.\n\n\nOn Tue, May 19, 2020 at 3:59 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> Ah, I forgot to add you as a contributor! Oops. Let me do that now.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8#issuecomment-631049168>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXTP7PCTIP7DRVPILW3RSLQIVANCNFSM4NEQVXEQ>\n> .\n>\n",
          "createdAt": "2020-05-19T22:17:37Z",
          "updatedAt": "2020-05-19T22:17:37Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU2MjA1OTMzNjk=",
      "title": "typos/comments from Eric Crockett",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/9",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Page 4, second paragraph: \u201cOKI-free\u201d -> \u201cPKI-free\u201d\r\n\r\nIn that same paragraph \"it works for RSA\" should be replaced with a better explanation. The point is that  SRP requires a ring: it mixes additions and multiplications. It does not work over plain elliptic curves.\r\n\r\nPage 8, section 2.1. DH-OPEF -> DH-OPRF",
      "createdAt": "2020-05-19T00:47:29Z",
      "updatedAt": "2020-05-21T21:27:52Z",
      "closedAt": "2020-05-21T21:27:52Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU2MjI2ODU4NDg=",
      "title": "Add OPRF domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/15",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The DST might include the \"RFCXXXX\" identifier, similar to what we did for HPKE.",
      "createdAt": "2020-05-21T18:16:49Z",
      "updatedAt": "2020-12-21T20:55:28Z",
      "closedAt": "2020-12-21T20:55:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We now include \"OPAQUEXX\" in `Finalize`. Closing.",
          "createdAt": "2020-12-21T20:55:27Z",
          "updatedAt": "2020-12-21T20:55:27Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU2MjI4NDM5NjI=",
      "title": "Specify profiles or configurations for servers",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/16",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This might include, for example, what sort of OPRF ciphersuite(s) are used. Or we might just say that this is decided out of band.",
      "createdAt": "2020-05-21T23:10:15Z",
      "updatedAt": "2020-05-28T16:17:15Z",
      "closedAt": "2020-05-28T16:17:15Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU2MjQ1Njk4MjM=",
      "title": "HMQV key derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/18",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The following changes the HMQV key derivation to include the session identifier (essentially what the value info is) under the key calculation (the changes are in the last 4 lines below)\r\n\r\nValues IKM and info are defined for each protocol:\r\n\r\nFor HMQV:\r\n\r\n - info = \"HMQV keys\" \\| nonceU \\| nonceS \\| IdU \\| IdS\r\n\r\n - IKM = Khmqv\r\n\r\n   where Khmqv is computed:\r\n\r\n   - by the client:  Khmqv = (ePubS \\* PubS^s)^{ePrivU + u\\*PrivU}\r\n\r\n   - by the server:  Khmqv = (ePubU \\* PubU^u)^{ePrivS + s\\*PrivS}\r\n\r\n   and u = H(ePubU | \"user\" | info) and s = H(ePubS | \"srvr\" | info).\r\n\r\n<!--     (u and s are often denoted d and e, respectively, in HMQV)   -->\r\n\r\nAlso, in subsection \"Instantiation of OPAQUE with HMQV and 3DH\", before the KEY DERIVATION heading, add the following note:\r\n\r\n   [[TODO: Specify that in the login phase, ephemeral DH values need to be\r\n   verified to belong to the correct group (via membership tests or cofactor\r\n   exponentiation). Same for public keys during the registration phase.\r\n   Details of verification depend on the particular group/curve. (What's done in\r\n   TLS 1.3?)]]\r\n\r\n",
      "createdAt": "2020-05-26T03:02:31Z",
      "updatedAt": "2020-05-29T15:08:35Z",
      "closedAt": "2020-05-29T15:08:35Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU2MjY0NjQyNDM=",
      "title": "Add common configurations for OPAQUE ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/19",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This basically specifies different configurations, where each configuration identifies the OPRF, RKR-AEAD, and MHF algorithm. For example, one configuration might be DH-OPRF with OPRF-curve448-HKDF-SHA512-ELL2-RO, CTR+HMAC with AES-256 and HMAC-SHA256, and scrypt (with reasonable parameters).",
      "createdAt": "2020-05-28T12:19:47Z",
      "updatedAt": "2020-08-30T16:20:39Z",
      "closedAt": "2020-08-30T16:20:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "These configurations should also specify values for the nonce, authentication key, and exporter key lengths.",
          "createdAt": "2020-06-17T17:14:12Z",
          "updatedAt": "2020-06-17T17:14:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU2MjY0NjUxNzI=",
      "title": "Should all Credential fields be encrypted?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/20",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some fields, like the user public key, might only require authentication.",
      "createdAt": "2020-05-28T12:21:21Z",
      "updatedAt": "2020-06-18T23:36:20Z",
      "closedAt": "2020-06-18T23:36:20Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Authenticating-only the server's public key can be beneficial in a setting where the server uses the same public key with multiple clients. Encrypting the key means a larger envelope stored as *each*  user's record while authenticating-only makes both the envelope and per-user shorter shorter. There is some savings in not having to decrypt the server's public key but this seems negligible (especially if the authentication operation that cannot be avoided is more expensive than decryption).",
          "createdAt": "2020-06-02T16:31:07Z",
          "updatedAt": "2020-06-02T16:31:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was resolved in #36.",
          "createdAt": "2020-06-18T23:36:20Z",
          "updatedAt": "2020-06-18T23:36:20Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU2MjY0NjcwODU=",
      "title": "Move KdKey derivation to the Seal/Open calling code",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/21",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This key is used for applications that choose to process user information beyond the OPAQUE functionality (e.g., additional secrets or credentials).",
      "createdAt": "2020-05-28T12:24:30Z",
      "updatedAt": "2020-06-17T17:13:39Z",
      "closedAt": "2020-06-17T17:13:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now done.",
          "createdAt": "2020-06-17T17:13:39Z",
          "updatedAt": "2020-06-17T17:13:39Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU2MjY0NzAwNjk=",
      "title": "Lift user enumeration text to the OPAQUE AKE stage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/22",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood",
        "kevinlewi"
      ],
      "labels": [],
      "body": "We might consider standardizing the mechanism by which servers prevent user enumeration attacks. ",
      "createdAt": "2020-05-28T12:29:17Z",
      "updatedAt": "2021-04-14T19:35:01Z",
      "closedAt": "2021-04-14T19:35:01Z",
      "comments": [
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "I support standardizing a method to prevent user enumeration attacks as part of the OPAQUE specification.",
          "createdAt": "2021-01-11T22:53:21Z",
          "updatedAt": "2021-01-11T22:53:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "After reviewing the text again, I think the response encryption approach is likely the only viable way forward here, if we are to do anything. This requires restructuring the RegistrationResponse and CredentialResponse structures and how clients process them. Let's focus on CredentialResponse to start, which currently looks like so:\r\n\r\n```\r\nstruct {\r\n    SerializedElement data;\r\n    opaque server_public_key<1..2^16-1>;\r\n    Envelope envelope;\r\n} CredentialResponse;\r\n```\r\n\r\nIf we were to encrypt this using an OPRF-derived key, this might look like the following:\r\n\r\n```\r\nstruct {\r\n    SerializedElement data;\r\n    opaque ciphertext<1..2^16-1>; // encryption of server_public_key and envelope\r\n} CredentialResponse;\r\n```\r\n\r\nClients might process this by doing the following:\r\n\r\n1. Derive some key from the OPRF given the client's input (client_identity) and the server-derived OPRF key (oprf_key = f(MK, client_identity)). (This would require the client send two blinded elements -- one for deriving the CredentialResponse decryption key, based only on username, and one for deriving the envelope encryption key, based on the password.)\r\n2. Decrypt CredentialResponse.ciphertext, revealing server_public_key and envelope.\r\n3. Process both of these as normal. \r\n\r\n(Maybe there's a way to do this with only a single OPRF evaluation, but I've written the naive interpretation above for discussion.) \r\n\r\nOverall, this seems like it wouldn't be too terrible to implement. It also has the benefit of encrypting more information on the wire. But I'd really like to see if we can simplify it, perhaps by minimizing OPRF evaluations done, before writing up and implementing the change.\r\n\r\n@hugokraw, do you have any ideas?\r\n\r\ncc @kevinlewi for visibility, too.",
          "createdAt": "2021-02-15T18:57:41Z",
          "updatedAt": "2021-02-15T18:57:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The idea is to compute prk exactly as it is done now with a single OPRF computation and derive from it an additional key for decrypting the envelope.  Once the envelope is decrypted, the processing is the same (same keys derived from prk as currently done). Do you a reason this would not work or that you need a separate run of the OPRF?\r\nBtw, this covers a kind of second-order user enumeration threat. I was not sure it would be needed but if we specify it, it should be optional, not the main mechanism, I think.",
          "createdAt": "2021-02-15T21:19:18Z",
          "updatedAt": "2021-02-15T21:19:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Your comment seems to apply to the first type of enumeration attack listed in the appendix, which does not require client changes. I don't see much value in preventing this alone when the other type of enumeration exists, which is why I focused on the variant that requires client changes. ",
          "createdAt": "2021-02-15T21:22:12Z",
          "updatedAt": "2021-02-15T21:22:12Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "My comments refer to the second type. The first one only requires allowing that all contents of the envelope be encrypted but no change on client processing. The second type is the one that needs an additional layer of encryption with an additional key derivation from prk. Makes sense?",
          "createdAt": "2021-02-15T21:38:52Z",
          "updatedAt": "2021-02-15T21:38:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm confused then. There are two OPRF evaluations described in the appendix: F(derived_key, client_identity) and F(kU, client_password). Is that not right?",
          "createdAt": "2021-02-15T21:42:17Z",
          "updatedAt": "2021-02-15T21:42:17Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "You are confused and for a good reason. I used a terrible notation in that passage of the draft. I had kU and kU' notation for two very different things. The first was indeed an OPRF key but  the second was used as rwdU (or what's called prk now). So naturally, you thought of kU' as an OPRF key. In the current text this was translated into oprf_key and oprf_key'. However, if you change oprf_key' into something like prk' then you see how things make sense and that one OPRF key (and a single evaluation) suffices.  I'll be glad to clarify further if this is still confusing. Sorry for that.",
          "createdAt": "2021-02-15T22:43:03Z",
          "updatedAt": "2021-02-15T22:43:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, I understood that distinction. Here's what not clear to me: To simulate randomized CredentialResponses, the text proposes encrypting these under a key derived from OPRF(derived_key, client_indentity). However, there must *also* be some key derived from OPRF(kU, password) (as is essential to OPAQUE). (One can't just encrypt the envelope under a key derived from the first OPRF evaluation, as that completely skips the password.) \n\nAre these not two separate OPRF evaluations? If not, what am I missing?",
          "createdAt": "2021-02-15T23:41:06Z",
          "updatedAt": "2021-02-15T23:42:01Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "To address the attack in the first paragraph of Client Enumeration section (btw, should this be referred as user enumeration?), the server does the following. It holds a regular PRF key K (let's call the PRF by HMAC just to remove any confusion with OPRF). Upon receiving a pair (userid, blind) where userid does not exist in the server's database, S computes:\r\noprf_key=HMAC(K; userid | \"fake oprf key\") \r\nprk = HMAC(K; userid | \"fake prk\").\r\nThen, it builds an envelope using prk as the key and a string of all zeros as contents.encrypted_creds. In this case, however, we assume that ALL the envelope contents (including pkS) are encrypted. It sends this envelope to the client together with the OPRF response computed as blind^oprf_key.\r\n\r\nTo address the attack in the second paragraph, the server will need to derive oprf_key=HMAC(K; userid | \"oprf key\") even for its real users.\r\nIn addition, the protocol is changed as follows.\r\nAt registration, everything works the same except that an additional key outer_encrypt_key is derived from prk, and this key is stored at the server.  During online session, the server will take the envelope (which will be computed at registration exactly as currently done and stored at the server) and will produce a *fresh* encryption of envelope (fresh = with fresh random IV) and send the encrypted envelope to the client. Everything else stays the same.\r\nAt the client, prk and all its derivatives are computed as done currently, but in addition, the key outer_encrypt_key is derived from prk. The client uses it to decrypt the encrypted envelope and then proceeds as usual with the recovered envelope. \r\n\r\nWith these modifications, the case where the the server receives a pair (userid,blind) for unknown userid, is handled as follows.\r\nThe server sets oprf_key=HMAC(K; userid | \"oprf key\")  (with the received, unknown userid), sets outer_encrypt_key = HMAC(K; userid | \"fake encrypt\"), and generates a fresh encryption using outer_encrypt_key of a string of all zeros (same length as a regular envelope). ",
          "createdAt": "2021-02-16T00:31:27Z",
          "updatedAt": "2021-02-16T00:31:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, this is more clear now. This seems somewhat different from what's written currently. There is a technical blocker in that we don't have a deterministic API to generate OPRF keys from the output of a PRF. (The OPRF document currently only specifies a randomized KeyGen API, not a deterministic one.) Assuming we could work through that, we'd then need to define the randomized encryption algorithm for the response. Would the server just choose a random nonce and do XOR-based encryption per usual? Something else?\n\nThis seems doable, but it will require some invasive changes.",
          "createdAt": "2021-02-16T00:45:09Z",
          "updatedAt": "2021-02-16T00:45:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "You are right, you need to derive oprf_key deterministically from a PRF. This is easily adaptable from what you have in the OPRF document: Just output a random string of the size you need for the randomized KeyGen.  And yes, the randomized encryption can be done with a random nonce and and xor. No need for authentication.\r\n",
          "createdAt": "2021-02-16T01:02:31Z",
          "updatedAt": "2021-02-16T01:02:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I filed [this issue](https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/228) to track the deterministic key generation API for the OPRF. Absent such a function, I don't think we can move forward with this change. It's also not clear to me how much additional complexity this introduces without having implemented it, so I'd prefer we table this until after IETF 110.",
          "createdAt": "2021-02-18T23:02:51Z",
          "updatedAt": "2021-02-18T23:02:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the addressing of the attack of the first paragraph:\r\n\r\nI think this is a good suggestion for implementers who want this extra security property, and since it does not involve any changes to the OPAQUE protocol itself, I think it does not need to be explicitly standardized in this document.\r\n\r\nRegarding the addressing of the attack of the second paragraph:\r\n\r\nThis is also a nice way to add extra security, but the main downside to me is the fact that the server has to store an extra `outer_encrypt_key` per user, which adds 32 bytes to the password file. It's hard to speak objectively here, but it feels like the attack is a bit too esoteric to merit adding 32 bytes to the server-side storage, especially since it feels like most applications would not need this extra security property. Therefore, I am leaning towards leaving it also as not standardized in this document, but perhaps a future document could look into standardizing it if it becomes important...\r\n\r\nWhich then leaves the remaining question: what do we want to do with this text? Leave it as-is? Perhaps add a few modifications to ensure that the terminology used here is in line with the rest of the changes made to the main document?\r\n\r\ncc: @chris-wood @hugokraw ",
          "createdAt": "2021-02-28T22:57:11Z",
          "updatedAt": "2021-02-28T22:57:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, I agree with @kevinlewi. I think we need stronger motivation to make username enumeration against an *active* attacker a property of the core protocol. Perhaps @crockeea has something in mind, here? \r\n\r\n> Which then leaves the remaining question: what do we want to do with this text? Leave it as-is? Perhaps add a few modifications to ensure that the terminology used here is in line with the rest of the changes made to the main document?\r\n\r\nIf we go down this route, I think acknowledging this property is necessary. I hesitate to add anything more detailed, as it might be implemented incorrectly and harm interop. There's probably some high-level sketch we can leave for future specifications that might want to more directly address this issue. ",
          "createdAt": "2021-03-01T02:41:09Z",
          "updatedAt": "2021-03-01T02:41:09Z"
        },
        {
          "author": "PaulGrandperrin",
          "authorAssociation": "NONE",
          "body": "I'm building a project making use of https://github.com/novifinancial/opaque-ke.\r\n\r\nWhile I was writing the code to do logins, I was very surprised that I wouldn't be able to easily do the classic\r\n\r\n ```your username OR password is incorrect```\r\n\r\nlike many major websites do to prevent username enumeration. e.g:\r\n  - Apple iCloud\r\n  - ProtonMail\r\n  - Cloudflare\r\n  - Github\r\n  - Parler\r\n  - Twitter\r\n  - Reddit\r\n  - Steam\r\n  - Mega.nz\r\n  - Tinder\r\n  - OkCupid\r\n  - Paypal\r\n  - Venmo\r\n  - Coinbase\r\n  - Binance\r\n  - P*rnhub\r\n  - Onlyfans\r\n  - Hired\r\n  - Indeed\r\n  - Glassdoor\r\n  - ...\r\n\r\n\r\nWhile it does indeed not matter for most websites (which is sadly also true for all the other nice properties of OPAQUE..), it will for sure be a showstopper for whole categories of websites: privacy-focus companies, security-oriented companies, free-speech platforms, online-dating, finance and crypto, adult sites and others.\r\n\r\n\r\nAlso, even if many website owners will not individually care about username enumeration, as a whole, if OPAQUE ever become widely deployed in its current implementation, being able to trivially know all websites to which a username/email has registered an account, will greatly help many actors looking to abuse users: hackers, scammers, and in some way, advertisers...\r\n\r\n\r\nFinally, I fear that if OPAQUE cannot be thought of as a ready-to-use solution good enough for all use cases (including the ones I enumerated above), it might hurt its general attractiveness.\r\nWhen building a new product/website, we never know what new constraints or features we might want or need in the future, so choosing dependencies that are all-around solutions is a major advantage for future-proof peace of mind.\r\n\r\nIn my experience working at some web companies, 32 bytes of data per user is nothing compared to all the other things usually kept, logged or traced per user.\r\nIf a company had all 7.5 billion humans registered (almost Facebook), it would add ~250GB of data to their user table, which is very little at that scale.",
          "createdAt": "2021-03-01T10:42:22Z",
          "updatedAt": "2021-03-01T10:42:22Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@PaulGrandperrin, thanks for highlighting those great points in your comment!!\r\n\r\nTo clarify, there are two types of attacks that are currently being discussed in this issue:\r\n\r\n### Attack 1: Adversary can tell whether or not a user has been registered based on the OPAQUE response.\r\n\r\n(This attack prevents the server from convincingly being able to state \"your username OR password is incorrect\", as in your comment.)\r\n\r\nThis attack has a mitigation, and it **does not involve changing the OPAQUE protocol in any way**. However, you are correct in pointing out that https://github.com/novifinancial/opaque-ke does not have explicit support for this mitigation. It could be added as an extra function to the API, but is currently not there. Feel free to file an issue to that repo for tracking if this is something you think should be added!\r\n\r\n### Attack 2: Adversary can tell, through repeated queries for a given user, whether or not that user has changed their password / registered, since the last time the adversary made a query.\r\n\r\nThe mitigation we are discussing for this attack DOES require a change to the OPAQUE protocol, and will add 32 bytes to per-user storage, as mentioned previously (along with a little bit of overall protocol complexity). Given your statement,\r\n\r\n> 32 bytes of data per user is nothing compared to all the other things usually kept, logged or traced per user.\r\n\r\nit seems like you would be advocating for changing the OPAQUE protocol to protect against this kind of attack, right? This is the main thing that we are discussing now, and we were not sure if this attack was realistic enough (or a significant worry to practitioners) to merit the extra cost.",
          "createdAt": "2021-03-01T11:26:25Z",
          "updatedAt": "2021-03-01T11:28:24Z"
        },
        {
          "author": "PaulGrandperrin",
          "authorAssociation": "NONE",
          "body": "@kevinlewi thanks for reminding me of this important subtility I forgot it since I first read about this issue a week ago!\r\n\r\n\r\nHere are some thoughts (biased from the point of view of working within or with SRE teams most of my professional experience):\r\n\r\n- as mentioned above, there is already quite a lot of websites used to not having to worry at all about username/email enumeration. Even though the \"attack 2\" might objectively be a minor regression for many use-cases, it will still feel like a regression necessitating a security and privacy review about the subtle new implications.\r\nLobbying a new technology that is only strictly superior to the old one is always much easier than having to debate the gains vs losses of the upgrade, even if the losses are small.\r\n\r\n- As I mentioned before, business needs evolve unpredictably over time, there's a certain peace of mind knowing that a piece of technology soundly and fully solves an issue. Needing to keep in mind small security/privacy gotchas in case they might become relevant for future use cases is annoying.\r\nI guess this is by the same logic that it is now always recommended to use AEADs and never directly symmetric ciphers, even when the authentification property does not feel necessary at first. (some people would even advocate for NRMR key-committing AEAD in all use cases ;-) )\r\n\r\n- For some categories of websites \"attack 2\" would still be a showstopper. In the case of adult sites, for example, one would just need to grab a dump of known emails (on the dark web), try them slowly at random over and over again, and could then blackmail the ones where a password change has been detected (which might also mean an account registration).\r\n\r\n- As an SRE, the proposed mitigation for \"attack 2\" makes me uncomfortable because it does not fail in an obvious and visible way. Teams wanting to be sure that the \"password rotation\" mitigation is working at all times would need to deploy some kind of non-trivial (because of the randomness of the timing of the rotations) monitoring and alerting on the production systems.\r\nAlso, choosing the parameters of frequency and distribution of the non-existing user's password changes feels like a very difficult question.\r\nI'm pretty confident most SREs would be happy the trade those 32 bytes per-user for not having to worry and deal with those things in production.\r\n\r\n- Finally, and this is a question: if the robust solution was not adopted now but was added to a later version, would it be possible for existing users of the first version of OPAQUE to upgrade their databases to the new version? (in an offline way, ie, without waiting for each user to log in one by one)",
          "createdAt": "2021-03-01T14:26:46Z",
          "updatedAt": "2021-03-01T14:26:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> For some categories of websites \"attack 2\" would still be a showstopper. In the case of adult sites, for example, one would just need to grab a dump of known emails (on the dark web), try them slowly at random over and over again, and could then blackmail the ones where a password change has been detected (which might also mean an account registration).\r\n\r\nThis is a *great* point. I suppose this is a realistic attack vector that we ought to consider. ",
          "createdAt": "2021-03-01T15:29:32Z",
          "updatedAt": "2021-03-01T15:29:32Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "@PaulGrandperrin Thank you for your comments. I had some of these hypothetical scenarios in my mind when considering the enumeration attacks but you make it feel real and tangible. \r\n\r\nI am not clear about the following comment:\r\n\r\n> * As an SRE, the proposed mitigation for \"attack 2\" makes me uncomfortable because it does not fail in an obvious and visible way. Teams wanting to be sure that the \"password rotation\" mitigation is working at all times would need to deploy some kind of non-trivial (because of the randomness of the timing of the rotations) monitoring and alerting on the production systems.  Also, choosing the parameters of frequency and distribution of the non-existing user's password changes feels like a very difficult question.  I'm pretty confident most SREs would be happy the trade those 32 bytes per-user for not having to worry and deal with those things in production.\r\n> *\r\n\r\nI do not see how the mechanism that is needed to address Attack 2 interacts with password rotation policy or its mechanics.\r\n",
          "createdAt": "2021-03-01T22:36:10Z",
          "updatedAt": "2021-03-01T22:36:10Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am looking into the design that @hugokraw proposed for mitigating Attack #2, and here is what I have come up with so far (note that this is not exactly what was originally suggested, since I made some modifications to hopefully simplify things without affecting security).\r\n\r\n## Registration Phase\r\n\r\nFirst, we have to modify the registration procedure to derive an `outer_encrypt_key` from `prk`:\r\n\r\nThe client, on input `prk`, computes something like:\r\n1. `outer_encrypt_key = HKDF-Expand(prk, \"outer encrypt key\", 32)`\r\n\r\nand then the RegistrationUpload struct is modified from:\r\n```\r\nstruct {\r\n    opaque client_public_key[Npk];\r\n    Envelope envelope;\r\n} RegistrationUpload;\r\n```\r\nto\r\n```\r\nstruct {\r\n    opaque client_public_key[Npk];\r\n    opaque outer_encrypt_key[32];\r\n    Envelope envelope;\r\n} RegistrationUpload;\r\n```\r\n\r\n> Question for @hugokraw: Is it secure for outer_encrypt_key to be sent in plaintext here, along with the envelope? Doesn't this mean that an attacker that has saved the `RegistrationUpload` message can try to decrypt the \"outer encryption\" we will provide in `CredentialResponse`, thereby making the mitigation less effective?\r\n\r\n## Login Phase\r\n\r\nMoving onto the login phase: there are two possibilities for the server to handle: either the user is registered, or the user is not registered:\r\n\r\n### If the user is registered:\r\n\r\nCurrently, we have this:\r\n```\r\nstruct {\r\n    SerializedElement data;\r\n    opaque server_public_key[Npk];\r\n    Envelope envelope;\r\n} CredentialResponse;\r\n```\r\nand the proposal is to modify to something like this:\r\n```\r\nstruct {\r\n    SerializedElement data;\r\n    opaque encryptionNonce[32];\r\n    opaque encryptedResponse[Nr];\r\n} CredentialResponse;\r\n```\r\nwhere `Nr = Npk + sizeof(Envelope) = Npk + (1 + 32 + Nsk + Nh)`\r\n\r\nThe server, with inputs `(data, server_public_key, envelope, outer_encrypt_key)`, constructs CredentialResponse by doing:\r\n1. Pick a random 32-byte `encryptionNonce`.\r\n2. Computes `encryptionPad = HKDF(outer_encrypt_key, encryptionNonce, Nr)` (so that `encryptionPad` is `Nr` bytes long)\r\n3. Sets `plaintext = server_public_key || envelope`\r\n4. Computes `encryptedResponse = plaintext xor encryptionPad`\r\n\r\nAnd constructs `CredentialResponse` using `(data, encryptionNonce, encryptedResponse)`.\r\n\r\n> Question for @hugokraw: Is it OK to do a one-time-pad encryption here with a fresh nonce, rather than rely on an AEAD?\r\n\r\n### If the user is not registered\r\n\r\nThen the server does the following:\r\n1. Pick a random 32-byte `encryptionNonce`\r\n2. Pick a random `Nr`-byte `encryptionResponse`\r\n\r\nAnd constructs `CredentialResponse` using `(data, encryptionNonce, encryptedResponse)`.\r\n\r\n-----\r\n\r\nDoes this sound right? Open to feedback!\r\n",
          "createdAt": "2021-03-02T10:54:42Z",
          "updatedAt": "2021-03-02T10:54:42Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The outer_encrypt_key needs to be transported under a confidential channel during registration.  We are assuming registration is done over an authenticated channel (otherwise how do yo know you are talking to the correct server?) so it is probably also confidential (e.g. TLS).\r\n\r\n[If that is not the case, the client could, IN THEORY (I do not suggest actually specifying that), first register without sending outer_encrypt_key, then running an OPAQUE session without that key, establishing an OPAQUE session key and then sending outer_encrypt_key under the protection of that key]\r\n\r\nAs for encryption of the envelope, as a defense against attack 2, no need for authentication. A simple xor with a pad derived using HKDF would suffice.\r\n\r\n@kevinlewi \r\n`I made some modifications to hopefully simplify things without affecting security`\r\n\r\nCan you indicate what these modification s were other than adding the specification details? I am asking to make sure I am not missing something.",
          "createdAt": "2021-03-02T17:18:29Z",
          "updatedAt": "2021-03-02T17:18:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw: Thanks, sounds good! I can go ahead and make a PR with these adjustments.\r\n\r\nRegarding the modifications, they are already embedded in the description of the specification that I gave. The two things that I modified (which differed from your original explanation) were:\r\n\r\n1. You said, \"To address the attack in the second paragraph, the server will need to derive oprf_key=HMAC(K; userid | \"oprf key\") even for its real users.\" I did not find this necessary, and did not incorporate it into the specification above.\r\n2. The use of xor-based encryption rather than AEAD for the encryption of the envelope using the outer_encrypt_key -- which you just confirmed would be enough.",
          "createdAt": "2021-03-02T17:38:36Z",
          "updatedAt": "2021-03-02T17:38:36Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. You said, \"To address the attack in the second paragraph, the server will need to derive oprf_key=HMAC(K; userid | \"oprf key\") even for its real users.\" I did not find this necessary, and did not incorporate it into the specification above.\r\n\r\nThis is needed for the following reason. The attacker sends hugokraw@service.com, a non-existing userid with service.com, with alpha as its first OPRF message and gets a response beta. Later he does the same and still gets the same response beta.\r\nAt some point hugokraw joins service.com,. If the OPRF key changes, namely the response beta to alpha changes, the attacker knows that hugokraw now has an account with service.com.  \r\nThis is not a specification of the protocol in the sense of messages and interoperability but is should be part of the server's actions specification. Also needed is a warning that the server implementation should be careful to avoid side channel leakage\r\n(e.g., timing) that differentiates the existent and non-existent user cases. \r\nIn short, these enumeration issues are a pain, though servers that are not  concerned with enumeration can skip these server-side careful operations. They still need to do the re-encryption of the envelope as this becomes part of the basic spec (right?).",
          "createdAt": "2021-03-02T18:16:37Z",
          "updatedAt": "2021-03-02T18:16:37Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, this makes sense, thanks! Unfortunately this increases the complexity of the implementation slightly, since now the server must store some persistent K used to derive oprf_keys for each user. But it should be workable.",
          "createdAt": "2021-03-02T20:08:08Z",
          "updatedAt": "2021-03-02T20:08:08Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw : One more point which I want to highlight. We will have to revert the change in Issue #120 (PR #126) since that made the `prk` value dependent on `envelope_nonce`. If we are to do this above change, we cannot have `prk` rely on `envelope_nonce`, since `prk` is required in order to decrypt the envelope in the first place.\r\n\r\nThis also raises a question: how should `outer_encrypt_key` be computed from `prk`? Is it OK to not require a nonce here, by setting `outer_encrypt_key = HKDF-Expand(prk, \"outer encrypt key\", 32)`, now that `prk` will be computed as `HKDF-Extract(\"prk\", Harden(y, params))` (which no longer involves `envelope_nonce`)?\r\n\r\nJust wanted to raise this issue in case you see anything wrong with it. Otherwise, I will include a revert of #120 in my upcoming change.",
          "createdAt": "2021-03-05T05:18:02Z",
          "updatedAt": "2021-03-05T05:27:07Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a good point. The main reason for the nonce was to address the following situation. A user registers with a service using a password pw and a private key sk it chooses. At a later point, the user runs the registration procedure again  (e.g, because a company requires periodic registrations or some security event triggers it). This time, the user uses the same password pw but a different private key sk'.  Since the service derives the user's OPRF key deterministically from the username, the OPRF key does not change. With the password and OPRF key unchanged, the same pseudorandom_pad is computed in both cases but used to encrypt two different plaintexts, namely, private keys sk and sk'. The  nonce in the envelope, chosen afresh with each registration, this weakness is eliminated. \r\n\r\nThere are two possible ways here. One is to say that the double use of a one-time pad in this case would be relatively rare and since the plaintexts under these encryptions will be independent random keys then there is not much to learn for the attacker (except if it knew the first private key). This would not be totally outrageous but not a good example of cryptographic hygiene. The other solution is to include a nonce in the envelope that is used to derive the pseudorandom_pad as currently done, but the nonce is not used for the derivation of outer_encrypt_key. The latter is computed without the nonce. ",
          "createdAt": "2021-03-05T06:58:29Z",
          "updatedAt": "2021-03-05T06:58:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw Thanks. Based on the PR that I posted (#156), I opted to do the second suggestion you mentioned:\r\n\r\n> The other solution is to include a nonce in the envelope that is used to derive the pseudorandom_pad as currently done, but the nonce is not used for the derivation of outer_encrypt_key\r\n\r\nHowever, your response made me realize yet another aspect we should probably consider. Right now, the proposal is to do:\r\n\r\n```\r\noprf_key = HKDF-Expand(oprf_seed, concat(\"oprf key\", cred_identifier), 32)\r\n```\r\nwhere `cred_identifier` is an identifier that acts as the client's username (could be the same as `client_identity`, but doesn't have to be), and `oprf_seed` is a random 32-byte value that the server must keep across all clients.\r\n\r\nHowever, this suffers from the downside that if the client were to rerun the registration protocol with the same `cred_identifier`, this would result in the same `oprf_key`. Previously, when we were choosing `oprf_key` as a random bytestring, we did not have this issue, but now we do.\r\n\r\nI propose that in the RegistrationRequest message, we ask the client to generate a 32-byte `oprf_key_nonce`, and then we change the `oprf_key` derivation to:\r\n```\r\noprf_key = HKDF-Expand(oprf_seed, concat(\"oprf key\", oprf_key_nonce, cred_identifier), 32)\r\n```\r\nso as to mitigate the issue. Of course, `oprf_key_nonce` will have to be a value that is persisted in the server-stored password file for the user, so that upon login, the server can reconstruct the `oprf_key` without asking the client to send anything.\r\n\r\nLet me know if this sounds good. Unfortunately, this means adding *another* 32 bytes to the password file, but I think it's for a good cause.",
          "createdAt": "2021-03-05T08:41:19Z",
          "updatedAt": "2021-03-05T08:41:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking that cred_identifier should be unique across users, e.g. hugokraw@gmail.com is unique. But if the identifier in use cannot be guaranteed to be unique then what you suggest makes sense, except that why does the client choose it and not the server? The latter may be able to choose shorter strings, e..g., it could use a global counter that is augmented by one with each new user (if saving in storage is important)",
          "createdAt": "2021-03-07T02:28:53Z",
          "updatedAt": "2021-03-07T02:28:53Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "On some further reflection, I think that proposed mitigation for Attack #2 causes a regression in another important security property that is desirable for OPAQUE: re-running the registration phase for a user should result in a fresh `oprf_key` chosen for that user.\r\n\r\nNote that in the event of a server compromise, since these `oprf_key` values for each user are stored in plaintext with each user's credential file, we should assume that they are exposed to the adversary as well. Hence, after the server asks users to re-register in such an event (with the same user identifier), it is important for a fresh `oprf_key` to be selected.\r\n\r\nBetween the choice of mitigating Attack #2 versus ensuring that a fresh `oprf_key` is sampled upon re-registration of a user, I think it would be best if we kept the latter. Unless there is a way to retain both properties with OPAQUE?\r\n\r\nNote that we can still address Attack #1, since that does not require any changes to the protocol.\r\n\r\nTherefore, I'm in favor of *NOT* making the proposed change (PR #156) to address Attack #2, and would like to hear everyone's thoughts on this.\r\n\r\ncc: @hugokraw ",
          "createdAt": "2021-03-08T10:35:36Z",
          "updatedAt": "2021-03-08T10:35:36Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If you derive oprf_key as PRF(key=master; concat(userid, nonce)) where nonce is stored in the userid record, then upon a detected compromise of oprf_key for userid, you need to re-register that party without changing userid but changing nonce to get a fresh independent oprf_key.  This change can be noticed by an attacker submitting userid before and after the change, but it is something that happens only upon compromise so not enough to ruin the defense to attack #2 in normal circumstances.  \r\nI do not like the extra complexity introduced by the defense against attack 2 but @PaulGrandperrin made some good arguments about the importance of such defense, particularly as it is hard to start with a system that does not provide these defense and later upgrade it to one that it does.\r\n\r\n",
          "createdAt": "2021-03-08T22:57:11Z",
          "updatedAt": "2021-03-08T22:57:11Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> This change can be noticed by an attacker submitting userid before and after the change, but it is something that happens only upon compromise so not enough to ruin the defense to attack #2 in normal circumstances.\r\n\r\nI think this depends on the application, and when they choose to rotate `nonce`. I agree with your statement if the only time `nonce` is rotated is after a server compromise. But, I was initially under the impression that whenever a user wishes to change their password, they will re-run the registration phase, thereby having a new `nonce` sampled (and hence, a new `oprf_key`). Otherwise, if we don't choose a new `oprf_key`, then it seems like we would be somewhat weakening the security guarantees that one might expect to have upon registering a new password for the user. This would then make \"Attack #2\" more relevant in normal circumstances, unfortunately.\r\n\r\nUltimately, I would like to avoid those complications by just ensuring that the re-registration procedure is as clean as possible.",
          "createdAt": "2021-03-08T23:03:01Z",
          "updatedAt": "2021-03-08T23:03:23Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The renewal of the OPRF key is not critical. It is only needed upon compromise. Of course, if it doesn't cost anything to change oprf_key with a re-registration, then better since it addresses the case where you did not know the oprf_key leaked. On the other hand, if the oprf_key leaks, the user's password is open to offline dictionary attack, so you are in trouble anyway. Note that you can also periodically rotate the master key used to derive oprf keys (moving users gradually to a new key) and that will give no information to the attacker. Overall, I do not see this attack scenario to be worth leaving attack 2 undealt with. ",
          "createdAt": "2021-03-08T23:10:28Z",
          "updatedAt": "2021-03-08T23:10:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarification. That makes sense to me, and now I am convinced that we do not need to add the extra `oprf_key_nonce` parameter that I had proposed in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/22#issuecomment-791261028.\r\n\r\nI'm in favor of continuing with the proposed changes in #156 ",
          "createdAt": "2021-03-09T10:53:05Z",
          "updatedAt": "2021-03-09T10:53:05Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening to discuss the following:\r\n\r\n@hugokraw : The client's static public key is also a part of the password file that the server stores. In the absence of the password file because the user has not been registered, what should the server use in place of the client's static public key in order to generate the \"fake\" CredentialResponse message?\r\n\r\nThis will affect the generation of the KE2 message. Would it suffice to pick a uniformly random 32-byte string? Or do we need another PRF evaluation here?\r\n\r\nHope the question is clear!",
          "createdAt": "2021-03-25T08:29:52Z",
          "updatedAt": "2021-03-25T08:29:52Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "is this possible to implement without having a timing side-channel?",
          "createdAt": "2021-03-25T11:46:01Z",
          "updatedAt": "2021-03-25T11:46:01Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i am also wondering if all these computations are proportional and an attacker has more computation to do than a defender, otherwise it might be quite economic do do a resource exhaustion dos against an opaque server, no?",
          "createdAt": "2021-03-25T11:47:17Z",
          "updatedAt": "2021-03-25T11:47:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Not Hugo, but:\r\n\r\n> This will affect the generation of the KE2 message. Would it suffice to pick a uniformly random 32-byte string? Or do we need another PRF evaluation here?\r\n\r\n~~Since this is otherwise sent in cleartext in KE2, I think a PRF evaluation is probably necessary.~~\r\n\r\n(I confused myself with ephemeral keys.)\r\n\r\nThe public keys only affect the handshake secret, which is already ephemeral by virtue of including the server's ephemeral share, so no PRF seems necessary.",
          "createdAt": "2021-03-25T13:30:35Z",
          "updatedAt": "2021-03-25T17:24:31Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In response to @stef:\r\n\r\n> is this possible to implement without having a timing side-channel?\r\n\r\nYes, the specification of the faked response was written in a way so as to explicitly mitigate timing side-channels (though it will of course depend on the implementation as to whether or not it is done properly). There is text in the draft which mentions that implementations must take care to prevent timing attacks. Also see this comment here: https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/156#issuecomment-793706164\r\n\r\n> i am also wondering if all these computations are proportional and an attacker has more computation to do than a defender, otherwise it might be quite economic do do a resource exhaustion dos against an opaque server, no?\r\n\r\nThese operations are actually not super complicated or resource-intensive, so I don't think that there is an opportunity for an attacker to do this. Especially when considering the full registration / login flow, where the client must evaluate a memory-hard function, it looks more like the client has to do the bulk of the work rather than the server!",
          "createdAt": "2021-03-26T01:37:09Z",
          "updatedAt": "2021-03-26T01:37:22Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The simplest and universal (i.e., for al key exchange protocols) solution to this issue is to use masking_key to encrypt the whole message from the server, namely, both the envelope and the KE2 message. The client decrypts the whole stream and operates on it as in the regular protocol. In this case, for non-existing userid's the server just sends a stream of random bits (of the same length as the envelope + KE2).\r\nIf we want to use masking_key only to encrypt the envelope, then the masking of KE2 depends on the protocol. For 3DH and HMQV specified here (it is similar for SIGMA), what the server sends is the server_nonce,  server_keyshare, enc_server_info and mac. These can all be simulated with random bits *except* for server_keyshare that is a group element and would be distinguishable (except for special encodings) from a random string of the same length. Thus, if we do not want to use masking_key to cover KE2, the server will send random bits in place of the nonce, enc_server_info and mac (each such random string of the length of the field it occupies), but will need to send a random group element as server_keyshare. The latter costs an exponentiation operation.  \r\nSimulating these replacements while not leaking via timing is delicate. The server would need to deliberately slow-down the sending of its message to simulate the time it would take to compute the keys Ke2 and Km2 with a real user.",
          "createdAt": "2021-03-26T04:26:00Z",
          "updatedAt": "2021-03-26T04:26:00Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In response to @stef:\r\n> > i am also wondering if all these computations are proportional and an attacker has more computation to do than a defender, otherwise it might be quite economic do do a resource exhaustion dos against an opaque server, no?\r\n> \r\n> These operations are actually not super complicated or resource-intensive, so I don't think that there is an opportunity for an attacker to do this. Especially when considering the full registration / login flow, where the client must evaluate a memory-hard function, it looks more like the client has to do the bulk of the work rather than the server!\r\n\r\ni was more wondering of the simple case, a DDoS where attackers just send random garbage that is interpreted as a `CredentialRequest` message, and since we hide the userids - to prohibit enumeration - the attackers can send anything, and we cannot just sleep for x time to not leak time side chan, we have to actually do computation, and so the attacker very cheaply just sends random strings, and the server has to do much more expensive calculations. where if there would be no user enumeration protection, the cred requests that refer to nonexistent userids can simply be dropped, forcing the dos attackers to actually know valid userids, which if only  a few are used can be also dropped without processing - even at a firewall already. i know it's a tradeoff, but maybe noteoworthy mentioning in the draft?",
          "createdAt": "2021-03-26T12:35:50Z",
          "updatedAt": "2021-03-26T12:35:50Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If you use the technique by which all of the server's message (envelope + KE2 message) are encrypted under masking_key then the only non-trivial cost for the server is the computation of the OPRF response (one var-base exponentiation). If you do not encrypt KE2 under masking_key then the additional cost is a fixed-base exponentiation to compute server_keyshare which is relatively minor in comparison with the var-base exponentiation. All other values in KE2 are replaced with random strings. *Note that the server does not need to compute IKM or any of the derived keys **\r\nThe total cost for the server is less than establishing a TLS session with the attacker and in most cases OPAQUE will be run after establishing such channel (e.g., to protect the privacy of userid), so the gain for a DoS attacker from reacting to a fake userid in OPAQUE is not too significant.  Of course, if you compare with current password-over-TLS then the attacker always has the opportunity to do a DoS on TLS establishment and when using a real userid, it also forces the server to do the hardening procedure which I assume is significantly more expensive than an exponentiation.",
          "createdAt": "2021-03-26T16:20:35Z",
          "updatedAt": "2021-03-26T16:20:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the replies. Closing this issue out since the constant-time implementation is certainly doable.",
          "createdAt": "2021-04-14T19:35:01Z",
          "updatedAt": "2021-04-14T19:35:01Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU2MjY3MjY4Nzc=",
      "title": "Derive fresh nonces at envelope creation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/23",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The nonce used in envelope encryption should not be derived from RwdU but rather chosen freshly at random at the time of encryption (envelope creation) and be stored (and sent) as part of the envelope. This avoids reusing the same encryption stream for encrypting two different plaintexts.",
      "createdAt": "2020-05-28T18:38:50Z",
      "updatedAt": "2020-05-29T12:45:59Z",
      "closedAt": "2020-05-29T12:45:58Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #24.",
          "createdAt": "2020-05-29T12:45:58Z",
          "updatedAt": "2020-05-29T12:45:58Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU2MjY3Nzk1OTk=",
      "title": "Investigate OPRF generality",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/25",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently rely on a GenerateScalar function from the OPRF, which might not be a thing for OPRFs that are not based on Diffie-Hellman. We should consider how we might generalize this here, or perhaps in the OPRF document itself.",
      "createdAt": "2020-05-28T20:05:40Z",
      "updatedAt": "2020-09-19T12:04:44Z",
      "closedAt": "2020-09-19T12:04:44Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU2MjcyNDk1NDI=",
      "title": "Private key encodings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/26",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might use PKCS#8 as an encoding for credential private keys, or we might use language that suggests this is specific to each instantiation. ",
      "createdAt": "2020-05-29T12:56:46Z",
      "updatedAt": "2020-06-17T17:13:28Z",
      "closedAt": "2020-06-17T17:13:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as an application/instantiation-specific concern.",
          "createdAt": "2020-06-17T17:13:27Z",
          "updatedAt": "2020-06-17T17:13:27Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU2MjcyNTE5Mzk=",
      "title": "Validate ephemeral key shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specify that in the login phase, ephemeral DH values need to be verified to belong to the correct group (via membership tests or cofactor exponentiation). Same holds for public keys during the registration phase. Details of verification depend on the particular group/curve.",
      "createdAt": "2020-05-29T13:00:47Z",
      "updatedAt": "2020-08-30T16:26:04Z",
      "closedAt": "2020-08-30T16:26:04Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU2MjkzNTcyMzI=",
      "title": "Using HKDF-Expand in deriving KEYS",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/29",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of  KEYS = HKDF(salt=0, IKM=k, info=\"EnvU\", Length=L1+L2+L3) one could do \r\nKEYS = HKDF-Expand(key=k, info=\"EnvU\", Length=L1+L2+L3)\r\nwhich makes more sense since k is already a pseudo random key, we would only need to specify that k is the length of an HMAC key.",
      "createdAt": "2020-06-02T16:50:34Z",
      "updatedAt": "2020-06-18T23:36:09Z",
      "closedAt": "2020-06-18T23:36:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done in #36.",
          "createdAt": "2020-06-17T17:13:07Z",
          "updatedAt": "2020-06-17T17:13:07Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU2MjkzNjM5MTU=",
      "title": "KdKey rationale ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/30",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to add the rationale for KdKey somewhere. Can use the following as a basis:\r\n\r\nThe main use case I have in mind is retrieving a non-OPAQUE encrypted credential. Namely, expanding the use of OPAQUE with a credential-retrieval functionality. You could always put additional stuff in the envelope but I would prefer to restrict the envelope with its OPAQUE-specific functionality. In addition, having a separate encrypted credential can achieve several properties: allowing the server to send it only after the user authenticated; send it under the session key with forward secrecy; allowing the addition of a credential to the user's record after registration; allowing the use of non-RKR encryption for credential encryption; and just giving better extensibility, flexibility and separation from the core OPAQUE protocol.",
      "createdAt": "2020-06-02T17:01:06Z",
      "updatedAt": "2020-08-31T14:25:21Z",
      "closedAt": "2020-08-31T14:25:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is sort of like the TLS exporter secret. I'll see if I can write it as such!",
          "createdAt": "2020-06-04T20:58:08Z",
          "updatedAt": "2020-06-04T20:58:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw do you think the current rationale is sufficient? If not, would you mind proposing text to improve (expand) it?",
          "createdAt": "2020-07-21T16:44:26Z",
          "updatedAt": "2020-07-21T16:44:26Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume you mean the text under {export-usage}.\r\nI think it is ok.\r\nIt may be a good idea to add the following (which I have in my draft):\r\nThere is no restriction for the type of encryption scheme\r\n   used in this case.  However, ExportKey MUST NOT be used in any way\r\n   before the HMAC value in EnvU is validated. ",
          "createdAt": "2020-07-21T19:53:00Z",
          "updatedAt": "2020-07-21T19:53:00Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU2Mjk0MjQ1OTg=",
      "title": "On including pkU in the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/31",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a note: pkU is often not needed by the client to run the key exchange stage in which case it can be omitted from the envelope and not sent from server to client in the online stage. In particular, this is the case for the three instantiations here: 3DH, HMQV and SIGMA.",
      "createdAt": "2020-06-02T18:34:04Z",
      "updatedAt": "2020-06-18T23:36:02Z",
      "closedAt": "2020-06-18T23:36:02Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #36.",
          "createdAt": "2020-06-18T23:36:02Z",
          "updatedAt": "2020-06-18T23:36:02Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU2NDA4Njc5NzA=",
      "title": "Clarify KDF(Expand) and MAC requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/37",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Future implementers may wish to replace HKDF-Expand and HMAC with their own (read:faster?) variants, so we should make clear the rationale for using these. Per the analysis, we require random-key robustness from HMAC, which is not something all MACs provide. (GMAC and poly1305 don't, for example.) HKDF-Expand could possibly be replaced by a different variable-length output PRF.",
      "createdAt": "2020-06-18T02:56:35Z",
      "updatedAt": "2020-08-30T16:20:23Z",
      "closedAt": "2020-08-30T16:20:23Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU2NjAyMjQyMjU=",
      "title": "Typo: nonce appears twice",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/42",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In line\r\nexport_key = HKDF-Expand(RwdU, concat(nonce, \"ExportKey\", nonce), Nk)\r\nnonce appears twice",
      "createdAt": "2020-07-18T15:53:08Z",
      "updatedAt": "2020-07-21T16:43:49Z",
      "closedAt": "2020-07-21T16:43:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch! I fixed this directly on master.",
          "createdAt": "2020-07-21T16:43:38Z",
          "updatedAt": "2020-07-21T16:43:38Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU2NjAyMzUxMTg=",
      "title": "lengths of elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/43",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Who, when and how determines  the length of elements to be generated or received. For example, how does the client know what the value of Nk should be. More significant how does the client know Nk or len(pt) when receiving the envelope?\r\n\r\nOn a related note, for a derivation like\r\nSK, Km2, Km3, Ke2, Ke3 = HKDF(salt=0, IKM, info, L)\r\nwe need to assume that the client knows how to parse the key stream correctly and uniquely hence it needs to know the lengths of each key.  This is also needed even if we compute a separate HKDF-Expand for each value (since Expand requires to define a length value). How does the client know these values, are these determined by the specific algorithms or ciphersuite ? Should this information be part of the information authenticated by the envelope or some other mechanism?\r\nHow does TLS 1.3 deals with this, namely, how it communicates and authenticates the ciphersuite/algorithms/version?",
      "createdAt": "2020-07-18T16:13:01Z",
      "updatedAt": "2020-08-30T16:22:47Z",
      "closedAt": "2020-08-30T16:22:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Who, when and how determines the length of elements to be generated or received. For example, how does the client know what the value of Nk should be. \r\n\r\nThis is part of the configuration. We should define this!\r\n\r\n> More significant how does the client know Nk or len(pt) when receiving the envelope?\r\n\r\nThe length of the envelope's ciphertext is equal to len(pt), so the client uses that to determine the length of the pad.\r\n\r\nOn the length of keys, they're all `Nk` bytes long, which is part of the configuration. I'll throw up a PR that defines this. Unlike TLS, I don't think we want to negotiate the ciphersuite in-band (in the core protocol spec -- we might do something differently for the instantiations).",
          "createdAt": "2020-07-21T16:48:55Z",
          "updatedAt": "2020-07-21T17:10:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The ciphersuite needs to be set and fixed at registration time and it needs to be learned by the client during login.  If this information is wired into the client implementation/configuration then no need to worry about it. But otherwise, we need care (e.g., if the client is a browser contacting a server for which the client does not have configuration information).\r\nThe OPRF needs to be known or guessed before getting the envelope (similar to key_share algorithms in TLS 1.3). Do we need to have a mechanism for the server to say, please use this other OPRF if the guess was incorrect? Should we worry about downgrade attacks?\r\nFor the envelope the client needs to know what hash to use (how does it learn that?). If the OPRF and hash used by the client are correct, then we can trust the MAC computed on the envelope to detect any manipulation of the envelope. \r\nAnd then there is the AKE ciphersuite that needs to include the AKE protocol type itself (SIGMA, 3DH, etc)  and the specific algorithms/curves used by the AKE implementation. But the latter can be encoded into the envelope itself and verified by the MAC.",
          "createdAt": "2020-07-21T21:20:10Z",
          "updatedAt": "2020-07-21T21:20:10Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "How does the client parse/differentiate ciphertext and auth_data? I assume this is defined by the Envelope struct, but I don't know how these things are implemented. DO they have special separators, length values, etc.? I am worried about possible attacks that play with the boundaries of these elements.",
          "createdAt": "2020-07-22T16:14:13Z",
          "updatedAt": "2020-07-22T16:14:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How does the client parse/differentiate ciphertext and auth_data? I assume this is defined by the Envelope struct, but I don't know how these things are implemented. DO they have special separators, length values, etc.? I am worried about possible attacks that play with the boundaries of these elements.\r\n\r\nIndeed! Clients know to parse the ciphertext and auth_data in sequence (by the struct's definition), and know how to parse the type and length of each element in these lists. Everything should be unambiguous.",
          "createdAt": "2020-08-30T16:22:45Z",
          "updatedAt": "2020-08-30T16:22:45Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU2OTA0ODk5NzQ=",
      "title": "parsing of envelope when ct/pt are variable length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/51",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At the end of the `#protocol-messages` section is a description of the envelope structure as seen here:\r\n\r\n```\r\nOPAQUE uses an `Envelope` structure to encapsulate an encrypted `Credentials` structure.\r\nIt is encoded as follows.\r\n\r\n~~~\r\nstruct {\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n  opaque auth_data<0..2^16-1>;\r\n  opaque auth_tag<1..2^16-1>;\r\n} Envelope;\r\n~~~\r\n\r\nnonce\r\n: A unique 32-byte nonce used to protect this Envelope.\r\n\r\nct\r\n: Encoding of encrypted and authenticated credential extensions list.\r\n\r\nauth_data\r\n: Encoding of an authenticated credential extensions list.\r\n\r\nauth_tag\r\n: Authentication tag protecting the contents of the envelope.\r\n```\r\n\r\nas an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length. In such a case it is useful to have the lengths included in the auth_data section at known offsets of the envelope. hence i propose to move the auth_data section infront of the ct section, either at the very beginning before the nonce, or between the nonce and the ct, in both cases an instantiation of the protocol can decide to include the lengths at known offsets and will be able to parse the envelope, even if this means that these lengths are used before they are authenticated.",
      "createdAt": "2020-09-01T22:25:34Z",
      "updatedAt": "2021-01-08T04:03:06Z",
      "closedAt": "2021-01-08T04:03:06Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "on another note the line `opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the `<>` enclosed parameter is length, however hmacs provide quite specific length tags.",
          "createdAt": "2020-09-02T00:21:05Z",
          "updatedAt": "2020-09-02T00:21:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> as an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length. \r\n\r\nParsing these fields should be pretty straightforward. For example, consider `ct`, which is `opaque ct<1..2^16-1>`. To parse this, first parse a 2-byte length field, and then parse the remaining bytes (of that length) as the `ct` data. (This MUST be of length at least 1, which is what the `<1..2^16-1>` denotes.)\r\n\r\n> on another note the line opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the <>` enclosed parameter is length, however hmacs provide quite specific length tags.\r\n\r\nIt's true that the output of HMAC is fixed depending on the underlying hash function, but we chose to make this variable length in case clients wanted to truncate the tag to save space. (We can mark this as an open issue, because, as you hint, applications making such decisions isn't great.)",
          "createdAt": "2020-09-03T00:57:07Z",
          "updatedAt": "2020-09-03T00:57:07Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > as an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length.\r\n> \r\n> Parsing these fields should be pretty straightforward. \r\n\r\nindeed it should ;)\r\n\r\n> For example, consider `ct`, which is `opaque ct<1..2^16-1>`. To parse this, first parse a 2-byte length field,\r\n\r\nmaybe i missed this, but where is this 2-byte length field defined for ct? if it is plaintext, shouldn't it be explicitly protected by they authentication of the envelope and thus belongs in the auth_data section? does that imply there are more cleartext parts in the envelope besides the explicitly listed auth_data section? is there also a length field somewhere defined for the auth_data section?\r\n\r\n> and then parse the remaining bytes (of that length) as the `ct` data. (This MUST be of length at least 1, which is what the `<1..2^16-1>` denotes.)\r\n> \r\n> > on another note the line opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the <>` enclosed parameter is length, however hmacs provide quite specific length tags.\r\n> \r\n> It's true that the output of HMAC is fixed depending on the underlying hash function, but we chose to make this variable length in case clients wanted to truncate the tag to save space. (We can mark this as an open issue, because, as you hint, applications making such decisions isn't great.)\r\n\r\ni think it makes sense to just write `<Nh>` and refer to #cryptographic-protocol-and-algorithm-dependencies",
          "createdAt": "2020-09-03T18:15:26Z",
          "updatedAt": "2020-09-03T18:15:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> maybe i missed this, but where is this 2-byte length field defined for ct? if it is plaintext, shouldn't it be explicitly protected by they authentication of the envelope and thus belongs in the auth_data section? does that imply there are more cleartext parts in the envelope besides the explicitly listed auth_data section? is there also a length field somewhere defined for the auth_data section?\r\n\r\nI think perhaps you're confused by the terminology. These variable-length fields are using standard TLS notation (https://tools.ietf.org/html/rfc8446#section-3.4). Quoting that document:\r\n\r\n> Variable-length vectors are defined by specifying a subrange of legal\r\n> lengths, inclusively, using the notation <floor..ceiling>.  When\r\n> these are encoded, the actual length precedes the vector's contents\r\n> in the byte stream.",
          "createdAt": "2020-09-03T20:01:29Z",
          "updatedAt": "2020-09-03T20:01:29Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oh. maybe it makes sense to state this explicitly, it helps understanding this much easier for people that do not speak tls natively.",
          "createdAt": "2020-09-03T20:08:54Z",
          "updatedAt": "2020-09-03T20:08:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's stated here:\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#protocol-messages-protocol-messages\r\n\r\nWould an example section be more helpful? (I agree it's not obvious without that prior context!)",
          "createdAt": "2020-09-03T20:32:58Z",
          "updatedAt": "2020-09-03T20:32:58Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yeah i noticed that, but i have not anticipated the implicit consequences of that. the notation that is below as examples looks kinda self-explaining - except for the parts that are not explicitly spelled out...\r\nmaybe  an example section would be more helpful, or alternatively an explicit spelled out part that explains what is not obvious from the defintions below.",
          "createdAt": "2020-09-03T20:35:40Z",
          "updatedAt": "2020-09-03T20:35:40Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sorry , clicked on the wrong button.",
          "createdAt": "2020-09-03T20:35:55Z",
          "updatedAt": "2020-09-03T20:35:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To help craft that section, could you please list the notation that you do find confusing? I can then try to clarify. ",
          "createdAt": "2020-09-03T20:37:34Z",
          "updatedAt": "2020-09-03T20:37:34Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "after reading section 3 of RFC8446, i'd say the length of the field being implicit in that notation should be definitely \r\nnoted, and what i also learned, that in the struct `opaque` is the \"type\" of the value and in no way related to the protocol being specified, that is also kinda confusing in retrospect. otherwise i think enums and structs do not have hidden semantics, and as far as i see variants are not used. so i guess that's then these two things lengths of arrays and the type `opaque` as a special mention that this is a type and a name collision only.",
          "createdAt": "2020-09-03T21:51:38Z",
          "updatedAt": "2020-09-03T21:51:38Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "uh, i see that variants are used in the ProtocolMessage struct.",
          "createdAt": "2020-09-04T13:11:31Z",
          "updatedAt": "2020-09-04T13:11:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> after reading section 3 of RFC8446, i'd say the length of the field being implicit in that notation should be definitely\r\nnoted, and what i also learned, that in the struct opaque is the \"type\" of the value and in no way related to the protocol being specified, that is also kinda confusing in retrospect. otherwise i think enums and structs do not have hidden semantics, and as far as i see variants are not used. so i guess that's then these two things lengths of arrays and the type opaque as a special mention that this is a type and a name collision only.\r\n\r\nOkay, thanks! I'll try to clarify these things.\r\n\r\n> uh, i see that variants are used in the ProtocolMessage struct.\r\n\r\nIs there a question hidden in here?\r\n",
          "createdAt": "2020-09-04T18:22:51Z",
          "updatedAt": "2020-09-04T18:22:51Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > uh, i see that variants are used in the ProtocolMessage struct.\r\n> \r\n> Is there a question hidden in here?\r\n\r\nwell yes, i first thought that variants are not used in the OPAQUE draft, only later i saw it, so the semantics of variants are quite understandable, but might also deserve mention in the clarifying section.\r\n",
          "createdAt": "2020-09-04T20:02:15Z",
          "updatedAt": "2020-09-04T20:02:15Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe we can close this out now, given the recent changes to the envelope structure which ensure that there is only one variable-length field:\r\n\r\n```\r\nstruct {\r\n  InnerEnvelopeMode mode;\r\n  opaque nonce[32];\r\n  opaque encrypted_creds<1..2^16-1>;\r\n} InnerEnvelope;\r\n\r\nstruct {\r\n  InnerEnvelope contents;\r\n  opaque auth_tag[Nh];\r\n} Envelope;\r\n```",
          "createdAt": "2021-01-08T04:02:56Z",
          "updatedAt": "2021-01-08T04:02:56Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU2OTMxMzg0NDk=",
      "title": "rename Evaluate() to Contribute()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/53",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "since github does not support reviewing markdown documents i'm submitting this as an issue:\r\n\r\nThe OPRF primitive defines a \r\n```\r\nEvaluate(k, M): Evaluate input M using private key k.\r\n```\r\nfunction, semantically i think it makes more sense to call this function Contribute as this conveys better what is happening, Evaluate() is less specific to the purpose of what is happening here.",
      "createdAt": "2020-09-04T12:54:48Z",
      "updatedAt": "2020-09-19T12:03:52Z",
      "closedAt": "2020-09-19T12:03:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you elaborate on why `Contribute` is more clear? As written, I don't agree.",
          "createdAt": "2020-09-06T13:52:52Z",
          "updatedAt": "2020-09-06T13:52:52Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "because in an OPRF two parties collaborate to calculate a value `c^s`. The client (c) blinds his value `c` using the blinding factor `r`, then sends over this blinded value to the server, who contributes his value `s` to the computation and returns it to the client. the client then unblinds the value from the server getting as a result `c^s`. ",
          "createdAt": "2020-09-06T14:07:00Z",
          "updatedAt": "2020-09-06T14:07:00Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "on another note i would also rephrase \"using private key k\" to \"using secret key k\" as the usage of \"private\" suggest that there is also a public key associated with this, while there isn't. and as far as i can judge for this kind of usage it is more common to refer as secret and not private keys.",
          "createdAt": "2020-09-06T15:02:06Z",
          "updatedAt": "2020-09-06T15:02:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Use of \u201cprivate key\u201d matches terminology in the OPRF dependent document. Use of Evaluate is also a result of that document. I suggest filing an issue against that repository to consider Contribute.",
          "createdAt": "2020-09-06T20:20:10Z",
          "updatedAt": "2020-09-06T20:20:10Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks will. do.",
          "createdAt": "2020-09-06T20:38:18Z",
          "updatedAt": "2020-09-06T20:38:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing based on the outcome of https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/140.",
          "createdAt": "2020-09-19T12:03:51Z",
          "updatedAt": "2020-09-19T12:03:51Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU2OTMxNDA0MjU=",
      "title": "What is an OPRF keypair?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/54",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in the Cryptographic primitives section there is this sentence:\r\n```\r\nWe also assume the existence of a function KeyGen, which generates an OPRF private and public key.\r\n```\r\ni'm sorry, but what does that mean? The notion of a keypair in the OPRF context makes no sense to me.",
      "createdAt": "2020-09-04T12:56:53Z",
      "updatedAt": "2020-09-16T13:34:41Z",
      "closedAt": "2020-09-16T13:34:41Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i just realized this might be a typo and should say OPAQUE instead of OPRF?",
          "createdAt": "2020-09-04T13:06:00Z",
          "updatedAt": "2020-09-04T13:06:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not a typo. The OPRF dependency in this document has a private and public key component to it. (Is your point that it should only be a secret key?) ",
          "createdAt": "2020-09-06T13:54:17Z",
          "updatedAt": "2020-09-06T13:54:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OPRF as such does not use any public/private keypair. An OPRF blinds the value of the initiator, the responder contributes its own value, and the initiator then unblinds the responders value. there is no use for a (sk=x, pk=g^x) keypair in this computation.",
          "createdAt": "2020-09-06T14:10:42Z",
          "updatedAt": "2020-09-06T14:10:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "however OPAQUE itself makes use of public private keypairs (and thus of keygen) for the values pkU, skU, pkS, skS, and their ephemeral counterparts. thus my assumption this being a typo.",
          "createdAt": "2020-09-06T14:12:30Z",
          "updatedAt": "2020-09-06T14:12:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Please review the dependent OPRF document. This OPRF has a public and private key pair. The public key is only used for verification, which is why OPAQUE discards it. ",
          "createdAt": "2020-09-06T20:18:17Z",
          "updatedAt": "2020-09-06T20:18:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sorry, i only read the paper by Jarecki et al., i wasn't aware that there is also an IETF (V)OPRF rfc draft. looking at that it makes kind of sense to call this keygen(), as for nist curves it must be guaranteed that the scalar is member of the field. and for voprfs actually to verify it. thanks for pointing that out, maybe this could be explained where the keygen() is mentioned in the opaque draft",
          "createdAt": "2020-09-06T20:37:20Z",
          "updatedAt": "2020-09-06T20:48:12Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i just reread the paper, and i apologize for the noise. ",
          "createdAt": "2020-09-16T13:34:41Z",
          "updatedAt": "2020-09-16T13:34:41Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU2OTQzODU1MDg=",
      "title": "uint24 in ProtocolMessage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/55",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`ProtocolMessage` defines the `length` field to be of type `uint24`, i understand this is to handle messages that are composed of a few max 2^16 long parts, and possibly to conserve bandwidth? is it possible to make this 32bit which is a native and widely used size instead of 24bits.",
      "createdAt": "2020-09-06T13:40:50Z",
      "updatedAt": "2020-09-06T14:15:08Z",
      "closedAt": "2020-09-06T14:15:08Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The full ProtocolMessage struct is as follows:\r\n\r\n~~~\r\nstruct {\r\n    ProtocolMessageType msg_type;    /* protocol message type */\r\n    uint24 length;                   /* remaining bytes in message */\r\n    select (ProtocolMessage.msg_type) {\r\n        case registration_request: RegistrationRequest;\r\n        case registration_response: RegistrationResponse;\r\n        case registration_upload: RegistrationUpload;\r\n        case credential_request: CredentialRequest;\r\n        case credential_response: CredentialResponse;\r\n    };\r\n} ProtocolMessage;\r\n~~~\r\n\r\nNote that `msg_type` is one byte, so one can skip over the type/length by 4 bytes if desired. `uint32` is fairly large for one of these messages, and `uint16` may be too small, so we went with `uint24` for alignment purposes.",
          "createdAt": "2020-09-06T13:52:17Z",
          "updatedAt": "2020-09-06T13:52:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "uint16 is definitely too small (since some parts of these messages can be more than 2*2^16-2 in size). using msg_type and length in one 32bit word makes sense though.",
          "createdAt": "2020-09-06T14:14:32Z",
          "updatedAt": "2020-09-06T14:14:32Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU3MDQ4NzA5ODM=",
      "title": "Should the nonce length be a parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/58",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's currently set 32 bytes, which may be too much (?) in some circumstances. However, adding yet another parameter that applications must choose is not great. ",
      "createdAt": "2020-09-19T12:10:05Z",
      "updatedAt": "2020-10-28T13:05:35Z",
      "closedAt": "2020-10-28T13:05:34Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it should be fine to keep this as 32 bytes, erroring on the side of safety without too much of a drawback.",
          "createdAt": "2020-10-21T22:42:38Z",
          "updatedAt": "2020-10-21T22:42:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I applied this directly on main. Closing.",
          "createdAt": "2020-10-28T13:05:34Z",
          "updatedAt": "2020-10-28T13:05:34Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU3MDkyMTA3OTE=",
      "title": "SHA-256 for Curve25519-based OPRF ciphersuites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/59",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, SHA-512 is used for all OPRF suites, which is quite excessive. (This is more an issue against the OPRF draft, I'm but filing it here to track the change in our doc.)",
      "createdAt": "2020-09-25T18:56:57Z",
      "updatedAt": "2020-11-02T23:54:06Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": []
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU3MDkyMTEyOTc=",
      "title": "Consider adding a registry",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/60",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The configurations are rather loosely defined. A registry that allows one to encode an entire configuration (AKE, OPRF, MHF, etc) could be useful. ",
      "createdAt": "2020-09-25T18:57:48Z",
      "updatedAt": "2020-10-28T13:05:48Z",
      "closedAt": "2020-10-28T13:05:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nevermind! Closing.",
          "createdAt": "2020-10-28T13:05:48Z",
          "updatedAt": "2020-10-28T13:05:48Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU3MTQ0MTcyNjc=",
      "title": "Envelope format in registration versus login",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/62",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should this line (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L583) be similar to this line (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L787)?\r\n\r\nEither both should read `Envelope envelope;`, or both should read `opaque envelope<1..2^16-1>`, right?",
      "createdAt": "2020-10-04T22:37:27Z",
      "updatedAt": "2020-10-20T00:47:44Z",
      "closedAt": "2020-10-20T00:47:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Doh, yes, that's an error. Let's make them both the former (`Envelope envelope`). Can you please submit a PR to correct this?",
          "createdAt": "2020-10-19T18:32:21Z",
          "updatedAt": "2020-10-19T18:32:21Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU3MTQ0NTQ0NjY=",
      "title": "Extraneous parameter pkS in CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/63",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Why is it necessary to [put pkS in the CredentialResponse struct](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L788)?\r\n\r\nAccording to [this](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L460-L464), pkS must be included within the envelope already. So, when the client parses the CredentialResponse struct, shouldn't it be able to obtain pkS from the envelope already?",
      "createdAt": "2020-10-05T01:47:20Z",
      "updatedAt": "2020-12-30T04:20:11Z",
      "closedAt": "2020-10-26T21:45:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good question! I *think* it can probably be removed, but let's see what @hugokraw thinks?",
          "createdAt": "2020-10-19T18:31:10Z",
          "updatedAt": "2020-10-19T18:31:10Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I did not notice pkS is sent outside the envelope. Not only it would be redundant but pkS is the most important element to be authenticated as part of the envelope. Sending it outside may lead people to accept it without authentication.",
          "createdAt": "2020-10-19T22:23:30Z",
          "updatedAt": "2020-10-19T22:23:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's drop it. @kevinlewi, can you please prep a PR to do this?",
          "createdAt": "2020-10-21T22:35:57Z",
          "updatedAt": "2020-10-21T22:35:57Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In light of the changes made in #102, this will need to be re-introduced again.",
          "createdAt": "2020-12-30T04:20:11Z",
          "updatedAt": "2020-12-30T04:20:11Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU3MjQ0MDY5ODk=",
      "title": "Omitting idU parameter in RegistrationRequest and CredentialRequest messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/65",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The idU parameter is not used by the server when receiving the `RegistrationRequest` and `CredentialRequest` messages from the client. Can this parameter be omitted from the specification of these messages?\r\n\r\nIn theory, the server does need some \"username\" equivalent in order to look up the client's record, so this information does need to be sent, but I don't think it should be included in the OPAQUE messages, since it has no function within OPAQUE other than to set/retrieve the appropriate password file.\r\n\r\nPresumably, any wrapper protocol which uses OPAQUE will not want to look into the bytes of the OPAQUE messages in order to figure out what the username is.",
      "createdAt": "2020-10-19T08:43:53Z",
      "updatedAt": "2020-10-28T18:59:13Z",
      "closedAt": "2020-10-28T18:59:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, it needs to be included in the transcript for the AKEs, I think, so that's why it's part of the `CredentialRequest` message. ",
          "createdAt": "2020-10-19T18:30:37Z",
          "updatedAt": "2020-10-19T18:30:37Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The presence of idU is dependent on the AKE protocol used, and so even though it may get sent over as the first message of the AKE, shouldn't this be controlled by the specification of the AKE, and not the OPRF component?\r\n\r\nAlso, this is only for `CredentialRequest`, since `RegistrationRequest` does not use idU. I would be happy with delegating the specifying of idU to the AKE component.",
          "createdAt": "2020-10-19T23:35:56Z",
          "updatedAt": "2020-10-19T23:35:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The presence of idU is dependent on the AKE protocol used, and so even though it may get sent over as the first message of the AKE, shouldn't this be controlled by the specification of the AKE, and not the OPRF component?\r\n\r\nThat's true. One thing I have in my implementation notes is whether we ought to include *both* `idU` and `pwdU` in the OPRF input, rather than just `pwdU`. Given that `kU` is unique per `idU`, this probably doesn't make a meaningful change in security, though I wonder if it's just cleaner aesthetically?\r\n\r\nI could go either way, I guess. I'm curious to hear what @hugokraw thinks.",
          "createdAt": "2020-10-20T00:04:25Z",
          "updatedAt": "2020-10-20T00:04:25Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": ">  One thing I have in my implementation notes is whether we ought to include both idU and pwdU in the OPRF input, rather than just pwdU.\r\n\r\nThat is certainly a valid consideration, but regardless of whether or not this is changed, I believe we can still omit idU from the `RegistrationRequest` and `CredentialRequest` messages, since the server doesn't use them (except for in the AKE component potentially).",
          "createdAt": "2020-10-20T00:09:22Z",
          "updatedAt": "2020-10-20T00:09:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "True, though I wonder if that just complicates things. (I don't disagree with the proposal. I just need to think about it more.)",
          "createdAt": "2020-10-20T00:14:18Z",
          "updatedAt": "2020-10-20T00:14:18Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Kevin, as you say correctly some form of user identity needs to be sent to the server for fetching the user's record. I would actually think that this transmission of identity is very much a role of the password authentication protocol, namely, OPAQUE. I can also see that this information may be transmitted in some other way (e.g., a wrapper) but I would not want to rely 100% on that possibility. Can we make the idU in the CredentialRequest message optional? Would that address your concern? \r\nThe setting in which the RegistrationRequest message acts is more complex as there are many issues involved in this case, particularly ways for the server to validate it is talking to the claimed user. In that case there may be a more complex wrapper. But even then, it feels that a support for a minimal implementation that  communicated idU from client to server could be supported. But in issues of implementation and deployment I  let you guys have the last word.\r\n\r\nAs for including idU under the OPRF input, I am ok with it. I am in favor of analyzing minimalistic protocols to understand what's the minimum elements the protocol's security requires. But I am happy to add elements that add robustness to the protocol (against misuse, etc.). I had examples in the past that I thought adding idU would be useful but I do not remember. It seems that if servers choose per-user kU (which they should) then adding idU does not add much value. Otoh, it makes idU more static as you cannot decide to change idU after registration (some websites would let you change userid)",
          "createdAt": "2020-10-20T06:29:51Z",
          "updatedAt": "2020-10-20T06:29:51Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "> some form of user identity needs to be sent to the server for fetching the user's record.\r\n\r\nI think this hinges on whether the protocol is described as a component of a session (L5+). It seems to me that this is one natural way of interpreting (or implementing) the Registration flow, on the one hand, and the Credential flow, on the other hand. During each of those, the idU parameter remains a constant.\r\n\r\nOnce the session parameters are determined \u2014 including of course the user's claim to identity (idU) \u2014 there is no need for the application to receive them again in further messages. The repetition would in fact no only consume bandwidth, but complicate implementation, by requiring a check that the idU value has indeed been kept constant on every message of a session, and demanding that the server emits a new error case if that session invariant is broken.\r\n\r\nHowever, such a re-transmission may be useful for auxiliary stateless tooling that does not have an understanding of a session, such as firewalls implementing packet filtering based on the idU field.\r\n\r\nWe've worked on implementation with a L7 in mind, but it's perfectly understandable that you could think of OPAQUE + KE as a lower-level initial session establishment protocol, in which case the stateless interpretation would make sense. \r\n\r\nAre there two recommendations to make to implementers here, depending on their use case?  \r\n\r\n",
          "createdAt": "2020-10-20T18:23:51Z",
          "updatedAt": "2020-10-20T18:24:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to be extra clear -- the inefficiency I am highlighting is the fact that the idU parameter included by RegistrationRequest is never used by the OPAQUE server implementation. Leaving it out would have no impact on anything within OPAQUE. One could argue the use for it by a wrapper protocol, but then the wrapper protocol would need to inspect the bytes of the OPAQUE protocol in order to extract idU, which could change depending on the OPAQUE version, and in general does not seem like a good abstraction.\r\n\r\nFor CredentialRequest, the same is true, except that the AKE component may use idU. However, I believe we should include the idU in the \"first message of the key exchange\" if the specification for that key exchange so requires, rather than placing it next to the OPRF component where it may or may not be consumed by the AKE.\r\n\r\nBTW @hugokraw, I believe the idU parameter is already optional (since it can be specified as 0 bytes as per \"`opaque id<0..2^16-1>;`\"). The question I am asking is if we should remove the already-optional parameter from the message being sent from client to server.",
          "createdAt": "2020-10-20T18:49:55Z",
          "updatedAt": "2020-10-20T18:49:55Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not completely sure I understand the issue here. I can see that there are cases where sending IdU inside OPAQUE can be redundant or even complicate things. But I think that giving the option to send it as part of the OPAQUE messages is necessary for ensuring one standard way for signaling the userid information to the server when the wrapper/application around it is not doing so. If you take the ability to send userid completely out of OPAQUE, what would be the answer to people's question \"how is the client supposed to communicate the identity of the user to the server\"?. Would the answer be:  \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"? \r\n\r\nA related issue is privacy of the user id/account information. If you send it as part of OPAQUE and you run OPAQUE inside a confidential channel, such as server-authenticated TLS, then you get that protection. If you send it by other means, you need to trust that this other means take care of privacy. \r\n\r\nOnce thing that is **for sure** is that the AKE needs to have a notion of identities agreed by both parties (agreement needs to be at the level of bit representation as these are input into the KDF) as verifying such agreement is a fundamental part of the AKE functionality. Since these identities will be known in most cases to the parties before the AKE starts (the server needs it to fetch the user's record and the user will typically have an identity of the server in order to contacting it), sending it in the AKE may be redundant in some/many cases. But I am ok with any decision here as long as we make sure this agreement on identities is established before running the authentication steps in the AKE.",
          "createdAt": "2020-10-21T15:41:26Z",
          "updatedAt": "2020-10-21T15:41:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not completely sure I understand the issue here. I can see that there are cases where sending IdU inside OPAQUE can be redundant or even complicate things. But I think that giving the option to send it as part of the OPAQUE messages is necessary for ensuring one standard way for signaling the userid information to the server when the wrapper/application around it is not doing so. If you take the ability to send userid completely out of OPAQUE, what would be the answer to people's question \"how is the client supposed to communicate the identity of the user to the server\"?. Would the answer be: \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"?\r\n\r\nThat's correct, I am of the opinion that \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"\r\n\r\n> A related issue is privacy of the user id/account information. If you send it as part of OPAQUE and you run OPAQUE inside a confidential channel, such as server-authenticated TLS, then you get that protection. If you send it by other means, you need to trust that this other means take care of privacy.\r\n> \r\n> Once thing that is **for sure** is that the AKE needs to have a notion of identities agreed by both parties (agreement needs to be at the level of bit representation as these are input into the KDF) as verifying such agreement is a fundamental part of the AKE functionality. Since these identities will be known in most cases to the parties before the AKE starts (the server needs it to fetch the user's record and the user will typically have an identity of the server in order to contacting it), sending it in the AKE may be redundant in some/many cases. But I am ok with any decision here as long as we make sure this agreement on identities is established before running the authentication steps in the AKE.\r\n\r\nAgreed on the AKE point. I am also ok with leaving it as an optional parameter in RegistrationRequest and CredentialRequest, but I do want to point out that this idU parameter is the only remaining parameter in the OPAQUE protocol which is sent over the wire, but the receiving party does not do anything with it (within the specification).\r\n\r\nTo me, the rule I'd like to follow is: the only code which should be interpreting / deserializing any bytes sent as part of the OPAQUE protocol is the OPAQUE code itself -- having a wrapper protocol attempt to do the deserialization may end up causing versioning / upgrading nightmares for these wrapper implementations. As such, I'd like to avoid the possibility of a wrapper call understanding the organization of bytes in the OPAQUE messages, and hence would lean towards completely omitting this idU in OPAQUE's RegistrationRequest and the core part (not the AKE part) of CredentialRequest.",
          "createdAt": "2020-10-21T21:50:16Z",
          "updatedAt": "2020-10-21T21:50:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi can you please prep a PR with this suggested change?",
          "createdAt": "2020-10-21T22:35:24Z",
          "updatedAt": "2020-10-21T22:35:24Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I said in a previous post in this thread:\r\n> I had examples in the past that I thought adding idU [in the OPRF input, in addition to the password] would be useful but I do not remember\r\n\r\nSo now I remembered: It helps against an online attack where the attacker poses as the server with its own chosen value k*. If only pwd is included then, the attacker can build a universal dictionary of values H(pwd)^k* for all pwd in a dictionary and use it against any user to check the client response. On the other hand, if idU is included under H then the attacker needs to build a dictionary per idU.  This would mean that at login and before talking to the server, the client knows a value of idU that was set at registration. If this is considered too problematic, one can live with the above issue as online attacks, particularly from the server side are not so damaging (I think). One can also include the server identity under H as may always be needed by the client in order to contact the server.",
          "createdAt": "2020-10-22T15:08:19Z",
          "updatedAt": "2020-10-22T15:08:19Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU3MjY4NjkzNTc=",
      "title": "Allow OPRF context creation with external key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/67",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is more of an issue with the OPRF draft, but noting it here for now. The OPRF context constructor does not allow creation of a server with an existing key, which makes the OPRF credential response generation function somewhat annoying to implement. ",
      "createdAt": "2020-10-21T21:16:22Z",
      "updatedAt": "2020-11-02T23:54:06Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU3MjY4Njk4NTE=",
      "title": "OPRF evaluation output",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/68",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The output of `Evaluate` in the OPRF draft is an `Evaluation` object, which has both a blinded and signed element, as well as a proof. We should either adopt that type here, or make it clear in our notation that the output of `Evaluate` is just the blinded and signed element.\r\n\r\nNote that this affects what's carried in a `RequestMetadata` struct. ",
      "createdAt": "2020-10-21T21:17:15Z",
      "updatedAt": "2020-12-21T17:00:15Z",
      "closedAt": "2020-12-21T17:00:15Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Aside from the specification issues, I would explicitly note (if not done yet) that we use the OPRF without proof/verifiability. Doing so would require the user to carry the g^kU value with him/her contradicting the password-only property of OPAQUE.",
          "createdAt": "2020-10-22T14:41:01Z",
          "updatedAt": "2020-10-22T14:41:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I clarified this with a text change right on master. Closing.",
          "createdAt": "2020-12-21T17:00:15Z",
          "updatedAt": "2020-12-21T17:00:15Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU3MjY4NzEwNjQ=",
      "title": "Specify harden parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/69",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "Clients need a way to recover credential information during registration. So we should either (a) fix some Harden parameters, or (b) have servers send these during the registration and authentication flows. \r\n\r\n@kevinlewi, what do you think?",
      "createdAt": "2020-10-21T21:19:22Z",
      "updatedAt": "2021-02-07T22:10:09Z",
      "closedAt": "2021-02-05T23:54:48Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you clarify what you mean by (a)? If you mean to provide concrete settings, I think we may want to avoid that since these numbers can become out of date, and are application-dependent. For (b), I think we should avoid this as well, unless we start also deciding to send information about group representation / hash functions during these flows. Also, there is no way for the server to enforce that the client follows the harden parameters, and so these are at best recommendations.\r\n\r\nMy approach would be to allow for parameterizing the protocol based on harden parameters. So in the same way that we can have OPAQUE with Ristretto points versus Edwards, or OPAQUE with SHA3 versus Blake3, the choice of a hardened hash function should just be another parameter.",
          "createdAt": "2020-10-21T22:12:30Z",
          "updatedAt": "2020-10-21T22:12:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  If you mean to provide concrete settings, I think we may want to avoid that since these numbers can become out of date, and are application-dependent. \r\n\r\nYeah, that's what I mean, and that's the risk. \r\n\r\n> My approach would be to allow for parameterizing the protocol based on harden parameters. So in the same way that we can have OPAQUE with Ristretto points versus Edwards, or OPAQUE with SHA3 versus Blake3, the choice of a hardened hash function should just be another parameter.\r\n\r\nI think there's generally too much flexibility in what's currently in the document. We have ciphersuites, configurations, optional parameters, etc. All of this runs the risk of making implementations challenging to get right. I would be in favor of something a bit more rigid. Could you please draft a PR to take care of this with your proposal? (This would also ideally address #58.)",
          "createdAt": "2020-10-21T22:35:00Z",
          "updatedAt": "2020-10-21T22:36:27Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I might have misinterpreted, but I was not suggesting to modify the current proposal in any way, except to suggest that when producing test vectors, we have a set which instantiates Harden with a specific function.\r\n\r\nSo my proposal is to keep everything in the draft the same, and when presenting test vectors, we provide annotated options such as:\r\n- OPAQUE-X25519-3DH-SHA256-Scrypt10k,\r\n- OPAQUE-Ristretto255-SigmaI-Blake3-Argon2i100k,\r\n- etc.\r\n\r\nThis means that we will be supporting the increased flexibility that you may be against.\r\n\r\nBtw, while we are on the topic, the flexible parameters I am currently tracking are:\r\n- Group representation\r\n- Keypair format\r\n- AKE protocol\r\n- Hash function\r\n- Harden function\r\n\r\n(Also represented in code [here](https://github.com/novifinancial/opaque-ke/blob/master/src/ciphersuite.rs#L15-L23))\r\n\r\nLet me know if you think I am missing any others...",
          "createdAt": "2020-10-21T22:48:43Z",
          "updatedAt": "2020-10-21T22:48:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Those match my understanding, yeah. Do we really *need* this sort of flexibility? I'm not sure! \r\n\r\nThough, hmm... on reflection, why are the parameters of Harden something the configuration (server?) ought to specify at all?",
          "createdAt": "2020-10-22T00:01:18Z",
          "updatedAt": "2020-10-22T00:01:18Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, I don't think the specification needs to specify the parameters of Harden, but an implementation may want to provide options for configuring them.",
          "createdAt": "2020-10-22T01:15:24Z",
          "updatedAt": "2020-10-22T01:15:24Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "After some offline discussion, we have settled on the following as the main point of discussion:\r\n\r\nLet's suppose a client registers their password using a particular hardening function. How should the client on login know what parameters for the hardening function to use? Two potential options:\r\n1) This shouldn't be part of the OPAQUE protocol, and it should be the responsibility of the wrapping protocol to ensure that the login surface's hardening parameters match those of registration, or to optionally store an annotation at registration time to help inform what parameters to use for login.\r\n2) This should be incorporated into OPAQUE, potentially through an extra client-specified field that can be stored alongside the password file.\r\n\r\nIf we go with Option 2, there are more follow-up questions, such as whether or not this field should be free-form, if it should be authenticated, etc.\r\n\r\ncc: @chris-wood",
          "createdAt": "2020-10-22T02:42:14Z",
          "updatedAt": "2020-10-22T02:42:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If the hardening parameters are transmitted from server to client, it would be better to authenticate them, or otherwise a cheating server can either apply a DoS attack on the client by sending extremely large parameters or help in a dictionary attack with small parameters (the latter would only apply to an online attack posing as the server).",
          "createdAt": "2020-10-22T14:58:20Z",
          "updatedAt": "2020-10-22T14:58:20Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "I vote for option 1: This shouldn't be part of the OPAQUE protocol. While it's one of the strengths of the abstract protocol to be generic, in practice deployments will be content with one particular suite of sub-protocols (for each of the available choices). \r\n\r\nAllowing the server to fix a set of choices without any further variability in messages avoids the headache of downgrade attacks.",
          "createdAt": "2020-10-22T17:17:09Z",
          "updatedAt": "2020-10-22T17:17:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitseeker Accepting unauthenticated parameters from the server can allow some form of downgrade attack as I mentioned before in this thread (sending low hardening parameters helps in an online dictionary attack where the attacker spoofs the server).",
          "createdAt": "2021-02-04T19:23:38Z",
          "updatedAt": "2021-02-04T19:23:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was resolved by pinning configuration parameters as part of the configuration. In-band negotiation is (we believe) too complex to justify the cost. Closing as resolved.",
          "createdAt": "2021-02-05T23:54:48Z",
          "updatedAt": "2021-02-05T23:54:48Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "How does the client learn the configuration? If the client is an application like Facebook I can see that the app on the user side has these parameters wired in. What about browser-based login with clients that were not pre-configured? Are you intentionally not supporting this case?  One could transmit ciphersuite (and even parameters) in the envelope (which come authenticated). Even just a hash of the configuration in the envelope would defend against rogue/downgraded configurations.",
          "createdAt": "2021-02-06T04:23:50Z",
          "updatedAt": "2021-02-06T04:23:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The general philosophy that I think would be helpful to maintain in terms of \"what should go in the envelope\" is that: only the minimum necessary in order for the OPAQUE protocol to function -- therefore, the skU parameter belongs there. I'm hoping that if an application wishes to transmit ciphersuite information and harden parameters in the envelope, they can instead make use of the `export_key` parameter as a key for authenticated encryption.\r\n\r\n> What about browser-based login with clients that were not pre-configured? Are you intentionally not supporting this case?\r\n\r\nI think that this describes a less popular potential application of OPAQUE, which is why I would be hesitant to incorporate parameters that specifically support this into the envelope. At the same time, there is still the flexibility from the application layer to use `export_key` for this purpose.\r\n\r\n@hugokraw let me know what you think! Also cc: @chris-wood  since we had a discussion about this in the past as well.\r\n",
          "createdAt": "2021-02-07T00:22:03Z",
          "updatedAt": "2021-02-07T00:22:03Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Configuration information that may impact the derivation of RwdU cannot be protected by export_key. It is too late for that (e.g., in setting the hardening parameters or the algorithms with which export_key is derived and/or used.  \r\n\r\nThe point of using the envelope to transmit parameters is that it is the only information the client gets in an authenticated way. Actually, in the case of OPAQUE over TLS, the server will first authenticate using a TLS certificate. In this case, the server can transmit  hardening and other parameters to the client  authenticated under the certificate. We should not do anything now that will make it difficult to accommodate such configuration information in the over-TLS case.  \r\nWhat do you think @chris-wood ?",
          "createdAt": "2021-02-07T22:04:15Z",
          "updatedAt": "2021-02-07T22:04:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think what we have now is suitable for the TLS case. The future TLS spec can define how harden parameters are encoded and transmitted. And the client, if it supports those parameters, can use them. (In other words, the parameters part of the configuration, and the future TLS spec would just define how to express and choose the configuration.)\n\nI don't think anything else needs to be done with respect to harden parameters in this particular spec.",
          "createdAt": "2021-02-07T22:10:09Z",
          "updatedAt": "2021-02-07T22:10:09Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU3MjY5OTM2MDk=",
      "title": "Why does FinalizeRequest take in idU as a parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/72",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "According to [this](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L651), idU is used to construct FinalizeRequest, despite it only being applicable if the application decides to include it in the Credentials struct: > \"Applications may optionally include\r\n> `pkU`, `idU`, or `idS` in the `Credentials.cleartext_credentials` structure, or in\r\n> `Credentials.secret_credentials` if secrecy of these values is desired.\"\r\n\r\nBut if this is the case, then why not also make idS and pkU parameters to FinalizeRequest as well?\r\n\r\nSame goes for RecoverCredentials. Either they should take in all of these optional parameters as inputs, or they should not include any of them.",
      "createdAt": "2020-10-22T02:32:52Z",
      "updatedAt": "2020-10-28T18:59:00Z",
      "closedAt": "2020-10-28T18:59:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal: remove application-specific credential information from the parameter list, and call out to the application to build `Credentials` based on the server's `secret` and `cleartext` list.",
          "createdAt": "2020-10-23T21:09:43Z",
          "updatedAt": "2020-10-23T21:09:43Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU3MzAwNzYyODg=",
      "title": "Clarifying optional versus required parameters in the AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In this [section on AKE](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1008-L1014), we should clear up exactly which parameters are required and which are optional. Then we can also work towards defining a wire format for these AKEs if necessary.\r\n\r\nA couple of concrete questions:\r\n1) Can we simply set idU = static pkU and idS = static pkS?\r\n2) Can we remove mention of all of the following: info1*, info2*, Einfo2*, info3*, Einfo3*?\r\n",
      "createdAt": "2020-10-27T03:42:24Z",
      "updatedAt": "2020-11-12T23:41:22Z",
      "closedAt": "2020-11-12T23:41:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. Can we simply set idU = static pkU and idS = static pkS?\r\n\r\nThis had been discussed in the past, and I think it depends on whether or not there exists a secure binding between the public key(s) and corresponding identity. (And that seems mostly external to the protocol.) I need to think about this more. @hugokraw probably also has opinions. :-)\r\n\r\n> 2. Can we remove mention of all of the following: info1*, info2*, Einfo2*, info3*, Einfo3*?\r\n\r\nThese fields exist to make the AKE instantiation more generic, e.g., maybe `info1` contains the client's set of application protocols run on top of the AKE. I think we should remove them, since applications that need this flexibility should be using TLS. I view the 3DH and SIGMA-I variants as minimalist OPAQUE instantiations. ",
          "createdAt": "2020-10-28T13:01:30Z",
          "updatedAt": "2020-10-28T13:01:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 1: In general, identities refer to logical entities on the basis of which policy decisions by the receiving party are made (do I want to talk to this identity, under what security level, which access rights, etc.) A public key may be used as an identity but most of the time it is not (e.g. , it is the subject in a certificate rather than the public key). In the case of OPAQUE,  using public keys may be more acceptable since those are fixed after registration and the client authenticates the server's public key via the password. I am not sure if this means that the client will never need to make decisions based on the server's logical identity but I do not see an obvious setting where this is the case. However, note that in the three protocols in the draft, the client does not use the user's public key. So if we are going to use it then we either send it as part of the authenticated information in the envelope or require the client to re-compute it from the user's private key at the cost of an exponentiation.",
          "createdAt": "2020-10-28T16:28:57Z",
          "updatedAt": "2020-10-28T16:28:57Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 2: We want these AKEs to be minimalistic but not useless. I do not see the case of any key exchange protocol that does not require sending some additional setting-specific information in its flows. Instead of having these fields named specifically, you may define some extensibility mechanism to transport additional information, but some mechanism for that must exist.",
          "createdAt": "2020-10-28T16:31:11Z",
          "updatedAt": "2020-10-28T16:31:11Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the comments!\r\n\r\nFor point 1: I would be in favor of requiring the client to re-compute the user's public key from its private key at the cost of an exponentiation, if it means that we do not need to send idU over the wire for the KE1 message. Similarly, for idS, since the server's public key is already required to be a part of the authenticated envelope, I would be in favor of omitting idS from the KE2 message as well (it is not currently there but just in case that comes up).\r\n\r\nFor point 2: Fair enough, we can keep them as optional parameters, but just to double-check, for the sake of minimalism: do you think we need both the plaintext variants (info1*, info2*, info3*) in addition to the encrypted variants (Einfo2*, Einfo3*), or would one set of these suffice?",
          "createdAt": "2020-10-28T18:56:53Z",
          "updatedAt": "2020-10-28T18:56:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 2, why can't applications send info *after* the AKE completes? (I understand that it burns a round trip, but that seems preferable to additional complexity in the AKE protocol itself.) In other words, an AKE without application slots is *not* useless. It's minimal, and allows applications to build whatever it is they need on top. \r\n\r\nSimply put, absent a specific use case for extensions, I'm not convinced they need to exist. ",
          "createdAt": "2020-10-28T19:15:02Z",
          "updatedAt": "2020-10-28T19:16:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The plaintext info field may be needed to transport information needed to select the algorithms and type of protection applied by the AKE and cannot be postponed to after the end of the AKE. The encrypted info field may be needed to transport information that requires privacy. I am all for simplifying wherever possible but I also want a usable specification. Eliminating all information beyond the core crypt operations does not seem to lead to such usable specification.  \r\n\r\nI am ok with letting pkU and pkS act as identities but I can also see implementations that would prefer to use something like a uid@site.dom as idU and save the computation of pkU. Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)? \r\n ",
          "createdAt": "2020-10-28T22:10:20Z",
          "updatedAt": "2020-10-28T22:10:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The plaintext info field may be needed to transport information needed to select the algorithms and type of protection applied by the AKE and cannot be postponed to after the end of the AKE. \r\n\r\nI'm not sure I agree with this. If cryptographic algorithm negotiation is needed for the AKE, then we should specify the mechanics to do that. We shouldn't just provide a generic slot for application info and punt the problem downstream. (Or, put differently, leaving just `info` and assuming it'll be used for cryptographic algorithm negotiation is an underspecified AKE, and not something applications can implement safely or correctly on their own.)\r\n\r\n> The encrypted info field may be needed to transport information that requires privacy. \r\n\r\nIf privacy is required, this information can be sent after the AKE completes. Why does it need to be done in-band?\r\n\r\n> I am all for simplifying wherever possible but I also want a usable specification. Eliminating all information beyond the core crypt operations does not seem to lead to such usable specification.\r\n\r\nI think it's the opposite. If we keep the specification as minimal as I'm advocating for, then applications are free to use the AKE's output however they want. ",
          "createdAt": "2020-10-28T22:22:40Z",
          "updatedAt": "2020-10-28T22:24:12Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)?\r\n\r\nI believe idU and idS can already be specified as optional elements in the envelope (see [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L439)), and so I would be happy to go with omitting them from the AKE messages.",
          "createdAt": "2020-10-28T22:29:19Z",
          "updatedAt": "2020-10-28T22:29:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)?\r\n> \r\n> I believe idU and idS can already be specified as optional elements in the envelope (see [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L439)), and so I would be happy to go with omitting them from the AKE messages.\r\n\r\nOk. So we can eliminate them from the AKE messages but have an explicit specification that the values idU and idS in the KDF are those specified in the envelope or, if omitted there, then pkU and pkS  (with a note that pkU will need to be computed by the client if not transmitted in the envelope).\r\n\r\n\r\n",
          "createdAt": "2020-10-28T22:32:38Z",
          "updatedAt": "2020-10-28T22:32:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think it's the opposite. If we keep the specification as minimal as I'm advocating for, then applications are free to use the AKE's output however they want.\r\n\r\nThe are always free to use the AKE output however they want. The question is whether they will have enough information to run and complete the AKE if they cannot send more than the bare cryptographic elements during the AKE. \r\n",
          "createdAt": "2020-10-28T22:37:09Z",
          "updatedAt": "2020-10-28T22:37:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The are always free to use the AKE output however they want. The question is whether they will have enough information to run and complete the AKE if they cannot send more than the bare cryptographic elements during the AKE.\r\n\r\nAs specified currently, and ignoring the `info` fields, is this the case? If so, shouldn't we specify everything that's needed to complete the AKE in this spec? I don't see how we can punt on that!",
          "createdAt": "2020-10-28T22:38:55Z",
          "updatedAt": "2020-10-28T22:38:55Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> As specified currently, and ignoring the `info` fields, is this the case? If so, shouldn't we specify everything that's needed to complete the AKE in this spec? I don't see how we can punt on that!\r\n\r\nI am thinking of these AKEs as something people will need to customize to their application/setting. The usage by Facebook and the ones by AWS are very different and they will need to fill in the details according to their needs.",
          "createdAt": "2020-10-28T22:44:40Z",
          "updatedAt": "2020-10-28T22:44:40Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If it helps (I am not fully convinced), I am ok with removing info and einfo in the current description, and instead adding language saying that what is shown is the minimal cryptographic skeleton and that applications may need to transport additional information as part of the AKE. In such a case, any information transmitted as part of the AKE messages must be included in the transcript fields (that are mac-ed in 3DH/HMQV and signed in SIGMA).  In addition, we specify the derivation of authenticated encryption keys (denote Ke2, Ke3) to be used for confidentiality protection of elements in the transcript that require such protection.",
          "createdAt": "2020-10-28T23:07:17Z",
          "updatedAt": "2020-10-28T23:07:17Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the discussion on point #2 seems to be around either: leaving in the optional parameters info and einfo, or omitting them entirely, it seems like the tradeoffs are the following:\r\n\r\nPros for leaving in the optional parameters info* and einfo*:\r\n- A potential application that wants to use these fields can do so without having to wait the extra round trip for AKE to finish\r\n\r\nCons for leaving in the optional parameters info* and einfo*:\r\n- Increased spec / API complexity for implementers\r\n- Increased bandwidth due to bytes spent on length-prefixing the optional parameters in AKE even if they are not used\r\n\r\nIs this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :) ",
          "createdAt": "2020-10-28T23:22:52Z",
          "updatedAt": "2020-10-28T23:22:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :)\r\n\r\nYeah, I think that's mostly accurate. Can you elaborate on why you're leaning that way? (If you used them in your implementation, what were the values of the fields?)",
          "createdAt": "2020-10-28T23:33:51Z",
          "updatedAt": "2020-10-28T23:33:51Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "My feeling is that we serve better the potential implementers of OPAQUE that need to embed the protocol in their specific application by guiding them toward they way of adding application specific elements to the protocol, in particular telling them that they should add these elements to the authenticated transcript and use Ke to protect confidentiality if needed. As I wrote elsewhere, I am ok if we remove info, einfo from the spec but then we must have English text about the need to include such elements under the authenticated transcript. Also noting the potential need for Ke (which we would include in the key derivation even if we do not show einfo* explicitly).  My bottom line: We would be serving implementers of OPAQUE in specific applications better with the info fields than without. (But who am I to tell what implementers really need? :-)\r\n ",
          "createdAt": "2020-10-28T23:36:24Z",
          "updatedAt": "2020-10-28T23:36:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> My bottom line: We would be serving implementers of OPAQUE in specific applications better with the info fields than without.\r\n\r\nYeah, I think if the goal is to allow applications to build a one-off AKE specific to their use case, then I think this is the right call. If, on the other hand, we're specifying a feature-complete AKE in this spec, I lean the other way. ",
          "createdAt": "2020-10-28T23:38:54Z",
          "updatedAt": "2020-10-28T23:38:54Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Is this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :)\r\n> \r\n> Yeah, I think that's mostly accurate. Can you elaborate on why you're leaning that way? (If you used them in your implementation, what were the values of the fields?)\r\n\r\nOne example that comes to mind is the following: Suppose a client is using a password to log in to a server, and on the KE2 message, the server wants to send to the client auxiliary information about the last time the client successfully logged in (IP address, # of incorrect login attempts since last login, etc.). These are of course things that can wait 1 more round trip for, but in certain applications it may be more convenient to not have to wait.\r\n\r\nAnyway, the main reason why I am leaning towards including the optional parameters is because I feel like we are more likely to regret excluding them than the other way around. I believe the added API complexity only affects those who have to implement a spec-compliant OPAQUE (hopefully a small population) and the benefits of having the flexiblity to use these optional parameters would affect those who use the spec-compliant OPAQUE implementations (hopefully a larger population).\r\n\r\n@huitseeker in case he has any additional thoughts on this",
          "createdAt": "2020-10-29T00:06:49Z",
          "updatedAt": "2020-10-29T00:06:49Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> I feel like we are more likely to regret excluding them than the other way around\r\n\r\nI would have not dared to show my feelings like Kevin's but I strongly feel like him :-)\r\n\r\n",
          "createdAt": "2020-10-29T02:22:07Z",
          "updatedAt": "2020-10-29T02:22:07Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yeah, I think if the goal is to allow applications to build a one-off AKE specific to their use case, then I think this is the right call. If, on the other hand, we're specifying a feature-complete AKE in this spec, I lean the other way.\r\n\r\nThis is indeed the point in which our view diverge. I hear of several people with various interests, including Kevin/Facebook, Crockett/AWS and people from some banks. They were all talking of specific applications they have rather than using a general Web/TLS-based protocol. I think that the document we are writing needs to serve these people. It can also serve those integrating OPAQUE in other protocols IKEv2, SSH, ...",
          "createdAt": "2020-10-29T02:26:22Z",
          "updatedAt": "2020-10-29T02:26:22Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "Optional information parameters can be useful, and if the past is prologue, they'll eventually be useful to shave off round-trips on auxiliary data in what's after all a latency-sensitive initial setup.\r\n\r\nSo, in that regard, if we keep those useful parameters in:\r\n- might it make sense to be very clear on what guarantees (as to authentication, compromise resistance, resistance to key compromise ...) the server can expect at the time it sends these optional parameters?\r\n- would it make sense to make an opt-in to those parameters a strong signal, maybe by committing to it in a ciphersuite string?",
          "createdAt": "2020-11-02T20:56:00Z",
          "updatedAt": "2020-11-02T20:56:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, on reflection, I think keeping the parameters is probably the best path forward. @kevinlewi, how do you want to deal with point (1)?",
          "createdAt": "2020-11-02T23:53:49Z",
          "updatedAt": "2020-11-02T23:53:49Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "For #1, recapping the summary from @hugokraw :\r\n\r\n> Ok. So we can eliminate them from the AKE messages but have an explicit specification that the values idU and idS in the KDF are those specified in the envelope or, if omitted there, then pkU and pkS (with a note that pkU will need to be computed by the client if not transmitted in the envelope).\r\n\r\nSo, let's remove their presence from the AKE messages, and I would vote for setting idU = pkU and idS = pkS when computing the AKE components (instead of reusing idU and idS that were optionally specified in the envelope).",
          "createdAt": "2020-11-03T00:42:23Z",
          "updatedAt": "2020-11-03T00:42:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems reasonable to me. Can you please draft a PR?",
          "createdAt": "2020-11-03T03:01:58Z",
          "updatedAt": "2020-11-03T03:01:58Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> So, let's remove their presence from the AKE messages, and I would vote for setting idU = pkU and idS = pkS when computing the AKE components (instead of reusing idU and idS that were optionally specified in the envelope).\r\n\r\nDo you mean removing idU and idS from the envelope, even as optional, and always using pkU and pkS as the identities in the AKE? I am responding to that interpretation. If that's not what you were saying, ignore this.\r\n\r\n Identities are central to authorization, access control, etc. and password protocols are central to these services so I think we need to leave flexibility there. Having the optional idU, idS in the envelope and pkU, pkS as default seems like a good balance between flexibility and ease of implementation.",
          "createdAt": "2020-11-03T06:14:31Z",
          "updatedAt": "2020-11-03T06:14:31Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw That is not quite what I mean; I am all for keeping idU and idS as optional parameters in the envelope. However, the **AKE portion** also refers to idU and idS: in particular, the values referenced [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1138-L1139). The question is -- should these simply be set to idU = pkU and idS = pkS, or should they be the same idU and idS that were optionally specified in the envelope?\r\n\r\nI am advocating for idU = pkU and idS = pkS just for the **AKE portion**, the values [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1138-L1139). It would be great to get your thoughts on this!",
          "createdAt": "2020-11-04T21:12:56Z",
          "updatedAt": "2020-11-04T21:12:56Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There is no use for idU and idS transported in the envelope other than to serve as identities in the AKE in lieu of any other identity that the parties may use to initially identify each other (for the client to know which server to contact and for the client to let the server know what user record to fetch). For example, I use hugokraw as my moniker in github but github may actually use my email address as my official identity (I don't know if this is the case, it is an imaginary example as far as I can tell).  I find it too limiting to dictate applications what's the identity they want to bind the AKE to.",
          "createdAt": "2020-11-05T06:23:34Z",
          "updatedAt": "2020-11-05T06:23:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Summary of discussion from the call: If there is no identity in the envelope, the AKE ID matches the public key. Conversely, if there is an identity in the envelope, that is the used in AKE.\r\n\r\n@hugokraw, @kevinlewi: does this match your understanding? \r\n\r\nIf so, we should elaborate on [this section](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-ake-execution-and-party-ide) to explain the differences between these identities and their respective use cases. In the process, we should recommend one implementation strategy for applications, e.g., by recommending that the AKE ID be the public key, and if a separate identity is desired, it's put in the envelope. In doing so, we should add text to deal with the case where application identities are long -- perhaps too long to store in the envelope. In such cases, a hash of the identity might be stored in the envelope and threaded into the AKE, and the server needs to check the hash against the long-form identity. ",
          "createdAt": "2020-11-06T22:58:29Z",
          "updatedAt": "2020-11-06T23:04:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent -- yes, thank you, this matches my understanding!\r\n\r\nJust to double-check, the same logic applies for idS, of course, right? (Default to pkS, unless idS is specified in the envelope, in which case use that)",
          "createdAt": "2020-11-06T23:10:41Z",
          "updatedAt": "2020-11-06T23:10:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Good (and yes, same logic for idS).\r\n\r\nNote: Currently, [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#finalizerequest) we say \"Applications may optionally include pkU, idU, or idS....\" in the envelope. We may want to clarify that if pkU is to be used as idU, this value needs to be sent in the envelope or the client would need to compute pkU from skU.\r\n",
          "createdAt": "2020-11-07T05:12:23Z",
          "updatedAt": "2020-11-07T05:12:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood @hugokraw Thanks! There is one more edge case to discuss:\r\n\r\nSuppose idU and idS are part of the envelope, but they are stored as a secret_credential (encrypted under `rwdU`) as opposed to something that the server can read in plaintext? The server will not be able to perform the AKE key derivation since it cannot read these values in place of idU and idS.\r\n\r\nAlso, what if they are stored authenticated in the envelope under cleartext_credentials? Do we expect the server to read the values without trying to check the MAC on them (since that would also require `rwdU`)?\r\n\r\nOf course, one way to simplify all of this is to simply default idU = pkU and idS = pkS and not try to have the server read the envelope's contents.",
          "createdAt": "2020-11-09T05:13:59Z",
          "updatedAt": "2020-11-09T05:15:04Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If idU and/or idS are stored under secret_credential, the server needs some other form of access to these values. The server cannot decrypt or authenticate the envelope; only the client in possession of the password (and after computing rwdU) can. Typically, the server will store these values separately or can derive them from other information it has, e.g., it knows its own identity idS or it derives idU from the identity it uses to identify the user's record. If the values are stored in the envelope in cleartext, the server can choose to read them from there; it is an implementation issue.",
          "createdAt": "2020-11-09T15:48:19Z",
          "updatedAt": "2020-11-09T15:48:19Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense. In that case, I propose that we set the default behavior to use idU = pkU and idS = pkS. And then, if the wrapper protocol wishes to use a custom idU and idS, then the OPAQUE protocol can accept these custom parameters from the wrapper protocol and use them in the AKE instead. Thus, the envelope would be completely ignored when doing this calculation.",
          "createdAt": "2020-11-09T19:05:13Z",
          "updatedAt": "2020-11-09T19:05:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If the envelope's identities are (effectively) ignored, would we keep idU and idS as valid credential types?",
          "createdAt": "2020-11-09T20:17:20Z",
          "updatedAt": "2020-11-09T20:17:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood That's a fair question -- perhaps we can create a separate issue to discuss the inclusion of idU and idS in the envelope, once we land the changes prescribed here?",
          "createdAt": "2020-11-09T20:21:53Z",
          "updatedAt": "2020-11-09T20:21:53Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The question is whether the client needs to accept the identities provided by the wrapper as the client cannot authenticate those. If authentication is needed then one must either use the default pkS identity for S or otherwise idS needs to be authenticated by the envelope. To illustrate the need for authentication, consider a setting where the application running on the client side has an access control policy with some permission rules for accessing a resource R.  Both idS and idS* are known server names to which the user may connect so both names have defined permissions for resource R. Note that the policy is defined in terms of names, not public keys (as with subject names in certificates vs.  public keys), and the names are received from the AKE layer once authentication succeeds (the AkE may pass several elements to the higher layers, including the peer's identity).\r\n\r\nNow suppose the client connects to idS who runs a rogue wrapper that provides the client with the correct envelope for idS but gives idS* as the identity.  The client will end the AKE successfully but with identity idS*. Indeed, the server (whose real name is idS) will authenticate using his own private key (corresponding to the public key in the envelope) but will enter the name idS* to the AKE which the client will do too (as it is using the identity provided by the wrapper). So the AKE level will pass to the access control policy the identity idS* and idS (not idS*) will be granted access to resource R.\r\n",
          "createdAt": "2020-11-09T22:36:22Z",
          "updatedAt": "2020-11-09T22:36:22Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw I am not entirely sure if you are proposing that we deviate from my [above comment](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74#issuecomment-724214162) (it seems like you are still in agreement), but I think to address the concern that you mentioned, the OPAQUE implementation should simply surface both idS (found in the envelope) and idS* (as output by the AKE) to the client, and allow the wrapper protocol on the client side decide whether or not it is valid for idS != idS*. Similarly for idU / idU* on the server-side.\r\n\r\n\r\n",
          "createdAt": "2020-11-09T23:34:54Z",
          "updatedAt": "2020-11-09T23:34:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand correctly your proposal, it says: \"Either use the default identities pkU, pkS, or let the wrapper decide on these identities.\" This presumes the wrapper application to be trusted and a final decision maker on what identities are acceptable.\r\nIn this case, I do not see the need to ever transport identities in the envelope. Or do you still think there is a point in allowing identities in the envelope in this case? How would they be used? \r\n\r\nI don't have an opinion on the trust one should put on the wrapper (I don't have enough use cases in mind to reason about it), but I'd hesitate to specify OPAQUE with such a universal trust assumption. It feels safer  (but maybe too limiting?) to make all decisions based on what OPAQUE can validate. Namely, follow the strict policy by which AKE identities are defined in the envelope and if they are missing from it then they default to pkU and pkS.",
          "createdAt": "2020-11-10T06:18:55Z",
          "updatedAt": "2020-11-10T06:18:55Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I think this makes sense, and we can first check for the existence of the identities in the envelope, and if they are missing, default to pkU and pkS (as we agreed to in [this comment](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74#issuecomment-723337010)).\r\n\r\nBut just as an FYI, since we must distinguish between the OPAQUE protocol run on the server versus the wrapper protocol that calls OPAQUE on the server, this means that the OPAQUE server protocol will have to **ask the wrapper protocol for the idU and idS it should use for the AKE**, since it cannot decrypt/authenticate the contents of the envelope. Just want to make sure we are clear on that.\r\n\r\nIf so, I believe we are good to go.",
          "createdAt": "2020-11-10T22:07:12Z",
          "updatedAt": "2020-11-10T22:07:12Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There are many ways in which the server can decide on the values of idS and idU. It can indeed ask the wrapper for those values but it could also  set idS and idU at registration (or later) and store them in the user's record, or it can read these values from the envelope if stored unencrypted there.  All these options are legit. \r\nNote that the setting here is very different for the user and server.  The user has no way of authenticating anything other than with his password (hence it can only authenticate information in the envelope) but the server has local storage with information (e.g., idS and idU) that it can trust.",
          "createdAt": "2020-11-11T04:01:54Z",
          "updatedAt": "2020-11-11T04:01:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi I think we can close this as resolved now. Do you want to do the honors?",
          "createdAt": "2020-11-12T23:32:38Z",
          "updatedAt": "2020-11-12T23:32:38Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks everyone for engaging in the discussions!",
          "createdAt": "2020-11-12T23:41:21Z",
          "updatedAt": "2020-11-12T23:41:21Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU3MzA5ODIzNDM=",
      "title": "Swap 3DH label strings around",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/75",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the 3DH key schedule computes two MAC and two encryption keys, as follows:\r\n\r\n```\r\nKm2 = HKDF-Expand-Label(handshake_secret, \"client mac\", \"\", Hash.length)\r\nKm3 = HKDF-Expand-Label(handshake_secret, \"server mac\", \"\", Hash.length)\r\nKe2 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"server enc\", \"\", key_length)\r\n```\r\n\r\n`Km2` is the key used to compute the server's MAC in `KE2`:\r\n\r\n```\r\nKE2 = credential_response, nonceS, info2, epkS, Einfo2, MAC(Km2; transcript2),\r\n```\r\n\r\nUsing the label `\"client mac\"` to derive `Km2` seems backwards. Let's swap them around, like so:\r\n\r\n```\r\nKm2 = HKDF-Expand-Label(handshake_secret, \"server mac\", \"\", Hash.length)\r\nKm3 = HKDF-Expand-Label(handshake_secret, \"client mac\", \"\", Hash.length)\r\nKe2 = HKDF-Expand-Label(handshake_secret, \"server enc\", \"\", key_length)\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\n```\r\n\r\ncc @hugokraw, @kevinlewi ",
      "createdAt": "2020-10-28T00:47:29Z",
      "updatedAt": "2020-11-02T23:54:07Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Definitely a typo. Good catch.",
          "createdAt": "2020-10-28T15:23:11Z",
          "updatedAt": "2020-10-28T15:23:11Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU3MzE0MzgzMjk=",
      "title": "Nail down AKE instantiations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/77",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TLS 1.3 *is* the SIGMA-I instantiation, so I think we should drop this from the OPAQUE document. It's redundant, and will likely cause confusion between people who want to choose between one or the other. \r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-10-28T13:24:01Z",
      "updatedAt": "2021-02-03T00:38:54Z",
      "closedAt": "2021-02-03T00:38:54Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this one. It is important to show that OPAQUE can use any AKE protocol and 3DH/HMQV are of a very special type. In particular, signature-based protocols are always KCI-secure while KEM-based (and \"implicitly authenticated\") are not always. Moreover, if you go by efficiency and you do not want to use HMQV because of the patent, then SIGMA-I is more efficient than 3DH. These are illustrations of the protocol if you want to build it as standalone, not necessarily with TLS. Those building upon TLS are more likely to use the version based on exported authenticators than a 3-flow handshake. \r\nYou can always choose 3DH as the must-to-implement protocol and leave SIGMA-I as optional.",
          "createdAt": "2020-10-28T15:33:17Z",
          "updatedAt": "2020-10-28T15:33:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see any variant in the document as mandatory to implement. I see them as different flavors of AKEs that applications can choose to implement based on their needs. And I think that decision tree should look like the following:\r\n\r\n- If we don't need signatures for authentication, use 3DH (or HMQV)\r\n- If we do need signatures for authentication, use TLS 1.3 with OPAQUE\r\n\r\nCurrently, the decision tree is something like the following:\r\n\r\n- If we don't need signatures for authentication, use 3DH\r\n- If we do need signatures for authentication, use SIGMA-I or TLS 1.3 with OPAQUE. (How do we decide to use TLS 1.3 or SIGMA-I?)\r\n\r\nThe core of this issue is that I don't think it's best to introduce *yet another* AKE with the same shape as TLS 1.3. ",
          "createdAt": "2020-10-28T16:21:09Z",
          "updatedAt": "2020-10-28T16:21:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that there is no need to have a must-to-implement version other than for interoperability tests. But I am not sure that someone using a standalone implementation of OPAQUE will necessarily need all the complexities of TLS 1.3 to implement a simple OPAQUE-SIGMA version. An example of a protocol that would favor a signature-based instantiation that is not TLS 1.3 is IKEv2, although they would use SIGMA-R. Yet illustrating SIGMA-I in the document would help that case too.",
          "createdAt": "2020-10-28T16:38:24Z",
          "updatedAt": "2020-10-28T16:38:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "So, as I see it, the delta between OPAQUE-SIGMA-I and TLS 1.3+OPAQUE is the wire format, not much more. If, however, we drop the \"info\" and additional fields (extensions) from OPAQUE-SIGMA-I, then there is a substantial difference. I would be in favor of keeping OPAQUE-SIGMA-I if it dropped extensions, because otherwise it's essentially TLS 1.3 but with a different wire format, and I don't think that rises to the level needed to specify yet another AKE.",
          "createdAt": "2020-10-28T19:11:54Z",
          "updatedAt": "2020-10-28T19:11:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not convinced that the complexity of implementing SIGMA-I with the info fields is same as implementing TLS 1.3. It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? Once we already define the flows for 3DH and HKDF, having them for SIGMA is no big deal. I am not sure that eliminating the SIGMA specific elements makes a huge difference.\r\nAnd I am not sure that we will end defining a flavor of OPAQUE with TLS 1.3 that will use just the three handshake flows (as opposed to defining it with EA and 5 flows).",
          "createdAt": "2020-10-28T22:26:41Z",
          "updatedAt": "2020-10-28T22:26:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? \r\n\r\nThis is my key point: there are probably very few. I don't think it's wise for us to standardize something that the majority of folks may not understand when or how to use when the TLS 1.3 instantiation exists. Moreover, folks who think they can make an informed decision between the two and get it wrong will likely have a bad day. \r\n\r\n> It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? \r\n\r\nThat's a fair point! If the TLS WG decided to forgo all but the EA flow, then certainly there's a larger difference between SIGMA-I and TLS 1.3+OPAQUE. But if not, I think the delta between these two is small enough that it's not in the CFRG's (or IETF's) best interest to specify.",
          "createdAt": "2020-10-28T22:31:53Z",
          "updatedAt": "2020-10-28T22:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Meta comment: perhaps we should also ask the list and see what they think?)",
          "createdAt": "2020-10-28T22:36:14Z",
          "updatedAt": "2020-10-28T22:36:28Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "It has to be understood that these AKEs are \"informational\"/illustrative, not intended as full specifications. Having the unspecified/optional info fields makes it very clear that we are not providing a full specification. \r\n\r\nI am ok with raising this in the list. ",
          "createdAt": "2020-10-28T22:42:08Z",
          "updatedAt": "2020-10-28T22:42:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It has to be understood that these AKEs are \"informational\"/illustrative, not intended as full specifications. Having the unspecified/optional info fields makes it very clear that we are not providing a full specification.\r\n\r\nAha, well, that's the source of this disagreement! I was approaching this as a complete specification, as that allows us to provide test vectors. If it's incomplete, I'm not sure how we provide test vectors. This definitely seems like something that list should weigh in on. I'll craft a message!",
          "createdAt": "2020-10-28T22:45:41Z",
          "updatedAt": "2020-10-28T22:45:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "You can produce test vectors that omit all optional fields. Or you can omit these optional fields from the specification as I just wrote in another thread and say in English that such elements may need to be transmitted by applications but we do not specify them as they will be application specific (we do say that they need to be included in the transcript).",
          "createdAt": "2020-10-28T23:10:12Z",
          "updatedAt": "2020-10-28T23:10:12Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "I saw the message on the list. I don't subscribe, so I'll comment here: a complete OPAQUE-3DH instantiation would be very helpful to me. BTW, the document is getting much easier for me to understand.",
          "createdAt": "2020-12-11T19:36:20Z",
          "updatedAt": "2020-12-11T19:36:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved, given #128 and #133. (SIGMA-I and HMQV will move to an appendix. We won't specify wire format specifics or provide test vectors, but we'll sketch how that could be done in future documents.)",
          "createdAt": "2021-02-03T00:38:54Z",
          "updatedAt": "2021-02-03T00:38:54Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU3Mzc0NDI1MjI=",
      "title": "Use of VOPRF should mention which mode is used",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/79",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Presumably we want to use the VOPRF with modeBase set (as opposed to modeVerifiable). But I could not find this mentioned anywhere in the spec in its current state",
      "createdAt": "2020-11-06T04:12:30Z",
      "updatedAt": "2020-11-09T16:39:34Z",
      "closedAt": "2020-11-09T16:39:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, it's the base mode. Do you want to take this and send a PR?",
          "createdAt": "2020-11-06T20:31:46Z",
          "updatedAt": "2020-11-06T20:31:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #80. Closing.",
          "createdAt": "2020-11-09T16:39:34Z",
          "updatedAt": "2020-11-09T16:39:34Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU3NDAzNjA3NDQ=",
      "title": "Add core OPAQUE protocol test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/82",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These would omit the AKE integration pieces, since the wire format for that's still unclear.",
      "createdAt": "2020-11-11T00:49:17Z",
      "updatedAt": "2021-02-03T00:37:33Z",
      "closedAt": "2021-02-03T00:37:33Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, as we no longer distinguish the \"core\" from the actual AKE.",
          "createdAt": "2021-02-03T00:37:33Z",
          "updatedAt": "2021-02-03T00:37:33Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU3NDMyNTE5NzE=",
      "title": "XOR-based encryption for Ke2 and Ke3 encryption keys in AKE?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/83",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [the definition of Ke2 and Ke3](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1071-L1075), the encryption keys used to encrypt the optional Einfo parameters in the AKE section, it seems like the application would need to pick an encryption algorithm for OPAQUE to use here.\r\n\r\nCan we avoid this selection and simply use an XOR-based one-time pad for encryption here (is this secure)? Thus, instead of setting key_length to be a fixed constant, it would simply be the length of Einfo2 and Einfo3.",
      "createdAt": "2020-11-15T13:00:20Z",
      "updatedAt": "2020-12-21T16:46:59Z",
      "closedAt": "2020-12-21T16:46:58Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw ^",
          "createdAt": "2020-11-15T21:51:22Z",
          "updatedAt": "2020-11-15T21:51:22Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The encryption needs to be authenticated-encryption. One could make the point that because the transcript is mac-ed anyway (currently specified only for 3DH/HMQV), then IND-CPA encryption could be enough, hence also xor.  However, I am always wary of such indirect assurances, i.e., using one element in the protocol (the MAC in this case) for two different reasons. The concern is that in the future, one of the reasons may not be relevant any more (because of some other change in the protocol or its requirements) and people will forget it was needed for another reason. A  good example is SIGMA. We could define that the whole transcript not only is signed but also MACed. Then you could use xor for encryption. But since SIGMA does not really need MACing the transcript then eventually the protocol could be simplified by only MACing the identity forgetting that the MAC also server to implement authenticated encryption. And given that GCM is so widespread now, it would be simpler to specify the encryption as GCM.\r\nImportant: Do you want to have a full specification for one of these protocols, say 3DH, at the level of allowing interoperable implementations? In that case we really need to make some choices for instantiating these functions.",
          "createdAt": "2020-11-16T20:30:26Z",
          "updatedAt": "2020-11-16T20:30:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the points. I think the only worry I have with specifying the encryption in this manner is that it brings additional complexity into the protocol, despite not being required for the core OPAQUE functionality. But overall I am supportive of it.\r\n\r\nI'm interested to hear what @chris-wood has to say on doing a full spec for one of the AKE protocols.",
          "createdAt": "2020-11-16T20:59:20Z",
          "updatedAt": "2020-11-16T20:59:20Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking about this and we do need to have a **simple**, full instantiation of OPAQUE to be used for interoperability testing but also for whoever wants a simple aPAKE with the benefits of OPAQUE. I assume that the modularity of design and specification has some important benefits (e.g., making it easier to integrate with existing AKE protocols such as TLS or IKE) but it may also obscure the simplicity of OPAQUE (e.g, when implemented with 3DH).  We should not let people conclude, erroneously,  that OPAQUE is too complex.",
          "createdAt": "2020-11-18T22:16:17Z",
          "updatedAt": "2020-11-18T22:16:17Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Is your conclusion that we could still opt for a simple XOR-based encryption scheme here (since the transcript is already mac-ed), and that we could leave a clear note in the specification stating why XOR-based encryption is OK and what would need to change if the transcript were no longer to be mac-ed?",
          "createdAt": "2020-11-18T23:14:15Z",
          "updatedAt": "2020-11-18T23:14:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. That works. I am not sure what would be considered simpler by implementers: encryption implemented by XOR-ing with a bit stream output by HKDF or a call to GCM with a key output by HKDF. Your call, guys.",
          "createdAt": "2020-11-19T02:59:47Z",
          "updatedAt": "2020-11-19T02:59:47Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ^",
          "createdAt": "2020-11-23T03:03:26Z",
          "updatedAt": "2020-11-23T03:03:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's probably easiest to stick with normal AEADs for AKE encryption, though note that this really depends on #77 (or more generally AKE specificity). For example, if we go with the \"this document just specifies templates for *actual* AKEs,\" then any future document describing a *specific* AKE with its wire format would deal with this encryption. But if we decide to specify a *specific* AKE in this document, then we'd have to deal with it.\r\n\r\nI lean towards being specific in this document, rather than punting to implementers and future document authors. (It seems wrong to deliver a partially baked protocol in the standard.)",
          "createdAt": "2020-11-24T01:48:39Z",
          "updatedAt": "2020-11-24T01:48:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we are in agreement to have one full specification that includes the AKE part. Now we \"just\" need to agree on the details and choices, including which of the three AKEs in the document - HMQV is the most efficient but it is out for IP reasons :-(",
          "createdAt": "2020-11-24T18:52:21Z",
          "updatedAt": "2020-11-24T18:52:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My vote would be 3DH. This would allow us to then sketch HMQV and SIGMA-I variants (sort of as we do now). ",
          "createdAt": "2020-11-25T14:34:59Z",
          "updatedAt": "2020-11-25T14:34:59Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me.",
          "createdAt": "2020-11-25T20:24:29Z",
          "updatedAt": "2020-11-25T20:24:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing to track a complete 3DH instantiation in #77.",
          "createdAt": "2020-12-21T16:46:58Z",
          "updatedAt": "2020-12-21T16:46:58Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU3NDM5MjA4NzQ=",
      "title": "note regarding omitting skU from envelope and deriving it from rwd instead",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/84",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in the source there's a commented out part `## Envelope considerations` which mentions that not even `skU` needs to be included in the credentials wrapped in the envelope, instead skU can be derived from `rwd`. there's a note that this part should be \"brought back after updating\". if this is indeed the case, do not forget to change \r\n> Applications MUST include skU in secret_credentials\r\nin the {#protocol-messages} section.",
      "createdAt": "2020-11-16T15:18:02Z",
      "updatedAt": "2021-04-15T15:00:33Z",
      "closedAt": "2021-04-15T13:26:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we need to remove that commented out text. I'll file a PR for that.",
          "createdAt": "2020-11-16T20:22:20Z",
          "updatedAt": "2020-11-16T20:22:20Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "why do you want to remove it instead of bringing it back? i think this part makes sense.",
          "createdAt": "2020-11-16T21:27:23Z",
          "updatedAt": "2020-11-16T21:27:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> i think this part makes sense.\r\n\r\nI need to think about this more, though my sense is that the bandwidth saved is not worth the additional complexity. The original I-D had this to say about the issue:\r\n\r\n```\r\n   Note (storage/communication efficient EnvU): It is possible to\r\n   shorten EnvU by including PubS in ClrEnv and omitting SecEnv and any\r\n   other value from EnvU.  In this case, the user's key PrivU is derived\r\n   from RwdU; e.g., the value PAD in KEYS is used as a seed for a key\r\n   generation procedure that outputs PrivU (the length of PAD will\r\n   depend on the specific key generation procedure).  Such EnvU consists\r\n   of Nonce, PubS and the HMAC value, resulting in less storage at the\r\n   server and less communication from server to client.  The server can\r\n   further minimize storage space by deriving per-user OPRF keys kU from\r\n   a single global secret key using a PRF, and it can use the same pair\r\n   (PrivS,PubS) for all its users.  In this case, the per-user OPAQUE\r\n   storage consists of Nonce, PubU and HMAC(Khmac; PubS).  While it may\r\n   be \"tempting\" to omit Nonce for space savings, this can lead to\r\n   vulnerabilities (see below).\r\n```\r\n\r\n@hugokraw, what do you think?",
          "createdAt": "2020-12-02T02:22:22Z",
          "updatedAt": "2020-12-03T05:07:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am sure that there are cases where such a savings will be meaningful and I am sure it will not be the typical case; I can't say much more than that. Frankly, the main reason I wanted to \"document\" this option is that in Bjorn Hasse's AuCPace paper, the amount of storage and/or communication was the only aspect on which AuCPace had some performance advantage. That paper compared against a very wasteful interpretation of what OPAQUE needed and I wanted to document the fact that one can actually be very minimal in envelope's size. I would prefer to make progress with the specification without entering this level of optimization but if there are potential users of OPAQUE for which these savings are important we could at least leave it as a remark. ",
          "createdAt": "2020-12-03T04:47:30Z",
          "updatedAt": "2020-12-03T04:47:30Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nIf so, then I think it would be great to incorporate this optimization into our specification, especially since this will affect how test vectors are generated.\r\n\r\nIf not, then I think we are better off not addressing this optimization, unless there are compelling reasons for practictioners to minimize the extra 32 bytes that are being used for encoding skU.",
          "createdAt": "2020-12-04T01:09:01Z",
          "updatedAt": "2020-12-04T01:09:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nIt depends on the key pair. HPKE [defines specifies a couple derivation functions](https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-derivekeypair) for popular groups. But this isn't exhaustive. Right now, I'm leaning towards not including this optimization, but perhaps this is also something we should bring up to the list. ",
          "createdAt": "2020-12-04T01:15:21Z",
          "updatedAt": "2020-12-04T01:15:21Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nThe universal way is to assume that the key generation procedure works on a string of random bits as input and therefore you can always produce that number of bits out of the RO applied to rwdU. This is simple for the case of EC keys but would not be so simple for an RSA private key (which requires sampling prime numbers).",
          "createdAt": "2020-12-05T18:07:22Z",
          "updatedAt": "2020-12-05T18:07:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello,\r\n\r\ncan't rwdu be used as input to h2c's HashToScalar and serve as a private key? (This is how I understood OPAQUE the first time I read about it - as an alternative to a secret key used for the envelope)",
          "createdAt": "2020-12-06T01:26:05Z",
          "updatedAt": "2020-12-06T12:45:21Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "With the latest advancements here, I'd like to bring this back up.\r\n\r\nConsideration to support RSA in the Sigma setup (or anything other that hasn't defined a secure deterministic key pair generation) made this a blocker.\r\n\r\nSince the 'main' AKE now is 3DH and that the group used for 3DH[ is set to be the same as the one used in the OPRF](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/104#issuecomment-772114793), we can leverage hashing _rwdu_ to the field for the secret key (e.g. hash-to-scalar() in hash-to-curve terminology). This would nicely lower the complexity and size of the envelope construction.\r\n\r\nI'm thinking about something like this:\r\nRegistration:\r\n```\r\nClient:\r\n1. N = Unblind(blind, response.data)\r\n2. y = Finalize(pwdU, N, \"OPAQUEXX\")\r\n3. nonce = random(32)\r\n4. rwdU = HKDF-Extract(nonce, Harden(y, params))\r\n5. sku, pku = DeriveKeysFromSeed( rwdu )\r\r\n6. authKey = HKDF-Expand( rwdu, \"AuthKey\")\r\n7. authTag = Hmac ( authkey, nonce || pku || pks )\r\n8. envU = envelope(nonce, authTag)\r\n\r\nC -> S : pku, envU\r\n```\r\n\r\nThe envelope does not contain encrypted secret material anymore.\r\n\r\nThen during authentication:\r\n```\r\nC -> S : oprf request, AKE request\r\nS -> C : oprf response, AKE response, pks, envU\r\n```\r\n\r\nThe client then does the same steps as during registration and checks the tag. Upon successful verification, uses sku, pku, and pks to proceed with the AKE.\n\nThis works for AKEs accepting a `DeriveKeysFromSeed` function, which derives a key pair from a seed.\nIn the case of 3DH over the groups supported in OPRF, this would be the hash-to-curve `HashToScalar()` function (+ a DST).\n\nThe envelope would be reduced to this\n```\nenvelope {\n    nonce\n    authTag\n}\n```",
          "createdAt": "2021-02-03T19:45:24Z",
          "updatedAt": "2021-02-07T23:18:01Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i understand that this would be a 3rd kind of envelope config, besides base and custom-identifier. but i'm still very much in favor of this.",
          "createdAt": "2021-02-03T22:03:24Z",
          "updatedAt": "2021-02-03T22:03:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef, @bytemare: would you be able to propose this new envelope as a PR?",
          "createdAt": "2021-02-15T18:46:21Z",
          "updatedAt": "2021-02-15T18:46:21Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sure\r\n",
          "createdAt": "2021-02-15T18:54:37Z",
          "updatedAt": "2021-02-15T18:54:37Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hmmm interesting, in this case there is no need for an envelope. which brings up the question if there is no envelope, should there be a mode-flag sent as AAD or will all of this be implicit and the HMAC verified over a virtual packet consisting of the modeflag, the nonce and the server pubkey? i assume we still want the nonce in there for the authentication of the mode and the server pubkey. or do we drop the whole envelope thing altogether? in the latter i guess the km[23] auth hmac would serve as a deterrent to partitioning oracles, right?",
          "createdAt": "2021-02-15T20:32:23Z",
          "updatedAt": "2021-02-15T20:32:23Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes, i remember. but this fragment is from a time, when the envelope was made up of a secret and a cleartext env part. in the current spec the cleartext is not part of the envelope anymore, only of the authentication tag calculation. how the client takes possession of the server pubkey is not specified anymore. it might be sent along by the server, or it might be pre-shared. but i guess the point is - if we stick with this, that we should still do an hmac over the server pubkey even in this case. and if we do, we might want to do this including a nonce. and if we send a nonce we can also send a mode flag. but the question is. if this is necessary at at all, or can all of this be skipped and the security of the protocol not be weakened by doing so.",
          "createdAt": "2021-02-15T21:10:26Z",
          "updatedAt": "2021-02-15T21:10:26Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm sorry, it seems the Github app has some issues, my comments keep disappearing. Here is my original comment:\r\n\r\n# \r\n\r\nThe draft has the following comment\r\n\r\n> It is possible to dispense with encryption in the construction of envelope to\r\n> obtain a shorter envelope (resulting in less storage at the server and less\r\n> communication from server to client). The idea is to derive client_private_key from prk.\r\n> However, for cases where client_private_key is not a random string of a given length, we\r\n> define a more general procedure. Namely, what is derived from prk is a random\r\n> seed used as an input to a key generation procedure that generates the pair\r\n> (client_private_key, client_public_key). In this case, secret_credentials is empty and cleartext_credentials\r\n> contains server_public_key. The random key generation seed is defined as\r\n> HKDF-Expand(KdKey; info=\"KG seed\", L)\r\n> where L is the required seed length. We note that in this encryption-less\r\n> scheme, the authentication still needs to be random-key robust which HMAC\r\n> satisfies.\r\n\r\nThis is where my suggestion came from, reducing the envelope to only keep the nonce and authentication tag, so the client can verify before continuing the AKE.\r\n",
          "createdAt": "2021-02-15T21:17:56Z",
          "updatedAt": "2021-02-15T21:17:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "true, if the server pubkey is being sent along this could be a problem, but if the server pubkey is preshared somehow and authenticated out-of-band, like e.g. during registration then i guess not, but that also means (which in some cases is totally ok) that the client stores some \"state\" the server pubkey.\r\nbtw the clients long-term pubkey is being stored by the server upon registration, in a secured channel. so that cannot be replaced by an attacker.",
          "createdAt": "2021-02-15T21:30:14Z",
          "updatedAt": "2021-02-15T21:30:14Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, I'm switching to a computer, this bug is really annoying, I'm terribly sorry.\r\n_(original message)_\r\n#\r\nIf it's possible to have no envelope at all and still keep the same level of security, that would be ideal (and I would love that!).\r\n\r\nThe 'client's trace' would be very loosely coupled, with the client not knowing if it got the right OPRF evaluation. On registration, the public key the client sends back to the server would not be authenticated.",
          "createdAt": "2021-02-15T21:31:59Z",
          "updatedAt": "2021-02-15T21:31:59Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On registration, the public key the client sends back to the server would not be authenticated.\r\n\r\niiuc registration requires a secured channel, like tls.",
          "createdAt": "2021-02-15T21:39:56Z",
          "updatedAt": "2021-02-15T21:39:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the client can still verify using km[23] an authentication tag.",
          "createdAt": "2021-02-15T21:40:34Z",
          "updatedAt": "2021-02-15T21:40:34Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we have no encryption, is the nonce even necessary? We could do the following, but I'm not sure we'd loose a security property:\r\n```\r\nprk = HKDF-Extract(hardened, nil)\r\nskc, pkc = deriveKeyPair(prk)\r\nauthKey = HKDF-Expand(prk, \"AuthKey\", Nh)\r\nauthTag = hmac( authKey, pkc || pks )\r\nenvelope = authTag\r\n```\r\n\r\nIf we went _envelope-less_:\r\n\r\nIn the AKE, the client computes `ikm` using the `skc` and `pks` long-term values. So one can assume that this is sufficient to proof possession of the right AKE mac keys, and thus verify KE2-mac and produce KE3-mac.",
          "createdAt": "2021-02-15T21:41:48Z",
          "updatedAt": "2021-02-15T23:50:53Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood what do you think?\r\n\r\nIf we went _envelope-less_, would the AKE macs be sufficient proofs that the client derived the right key pair?",
          "createdAt": "2021-02-15T21:51:35Z",
          "updatedAt": "2021-02-15T21:51:35Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This minimization of the protocol reminds me of this[ joke](https://eartstohear.wordpress.com/2015/09/01/fresh-fish-sold-here-daily/) .\r\nInterestingly, your suggestion of getting rid of the whole envelope and building on the AKE authentication *may* work with 3DH (one would need to prove it). In the case of SIGMA, if enc_server_info is empty, the protocol breaks completely. It  allows for an offline dictionary attack after a single session with the attacker acting as man in the middle between server and client. \r\n\r\nHowever, I do not think that assuming the client has the server's public key would be the common case (indeed, one of the main advantages of PAKEs is that you do not assume PKI or any form of trusted server's public key). In this case, the server sends its public key  to the client which must be authenticated by the client. This will require an HMAC computed on pkU. So deriving skU directly from prk would not obviate the envelope, it will be the same as now except for contents.encrypted_creds being empty (hence also pseudorandom_pad being omitted).  \r\n",
          "createdAt": "2021-02-15T22:27:01Z",
          "updatedAt": "2021-02-15T22:28:36Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "true, my whole context is 3dh.\r\nhowever the last time i checked (since there is a lot changing still all the time i might be very wrong) the specification removed the part formerly known as \"cleartext envelope\", and left it unspecified how the pkS and optionally the id[US] are being recieved/stored/etc by the client. the only part afais that is specified is how to calculate the mac over the envelope and use the pkS/id[SU] as aad. so it leaves the door open for storing this info in the client. for example i can easily imagine a setup where the client is a javascript implementation provided by the server via https containing already the pkS hardcoded in the js. the current specification leaves that open to the implementation. if this is not something that is desired we should say so in the spec i guess.",
          "createdAt": "2021-02-15T22:37:06Z",
          "updatedAt": "2021-02-15T22:37:06Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that you can find scenarios where you'll have pkS cached or hardwired into the client (e.g., an app in your phone that you download from the apple store). I would not \"prohibit\" such configuration but I also don't want to build on it as a common case. ",
          "createdAt": "2021-02-15T22:47:26Z",
          "updatedAt": "2021-02-15T22:47:26Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I confirm, this suggestion is thought in the 3DH setup, as the document is now focused on 3DH.\r\n\r\nI can agree that this situation may look like the joke you're thinking about, but I hope you're not taking any offense that we're making these suggestions that _make sense_. You're the expert here, you know best :)\r\n\r\nRegarding the server key caching, building OPAQUE on it would indeed go against the very usefulness of aPAKEs, like you already mentioned in other comments. But it would be very useful to store the public key as a configuration parameter like the others (group and hash identifiers, etc.)\r\n\r\nIn the case we keep the envelope, would the nonce still be necessary, and the authentication tag suffice?",
          "createdAt": "2021-02-15T22:52:20Z",
          "updatedAt": "2021-02-15T22:52:20Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "`I can agree that this situation may look like the joke you're thinking about, but I hope you're not taking any offense `\r\n\r\nNot at all! No offense. To the contrary, these are good and non trivial  questions. They are welcome.",
          "createdAt": "2021-02-15T23:37:02Z",
          "updatedAt": "2021-02-15T23:37:02Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "`In the case we keep the envelope, would the nonce still be necessary, and the authentication tag suffice?`\r\n\r\nIf you cache pkS (and assume it is authentic) and derive skU from prk, then it would seem that just applying HMAC to a fixed string (under auth_key) would suffice. Not sure if there is a use for the nonce in this case. If you really want to specify something like this in this document, I would need to think more about it.",
          "createdAt": "2021-02-15T23:43:57Z",
          "updatedAt": "2021-02-15T23:43:57Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I was more thinking about the regular case, where we don't cache anything, and the user only knows their password. \r\n\r\nLike in this previous comment\r\n\r\n> Since we have no encryption, is the nonce even necessary? We could do the following, but I'm not sure we'd loose a security property:\r\n> ```prk = HKDF-Extract(hardened, nil)\r\n> skc, pkc = deriveKeyPair(prk)\r\n> authKey = HKDF-Expand(prk, \"AuthKey\", Nh)\r\n> authTag = hmac( authKey, pkc || pks )\r\n> envelope = authTag",
          "createdAt": "2021-02-15T23:49:45Z",
          "updatedAt": "2021-02-15T23:51:01Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> skc, pkc = deriveKeyPair(prk)\r\n> authKey = HKDF-Expand(prk, \"AuthKey\", Nh)\r\n> authTag = hmac( authKey, pkc || pks )\r\n> envelope = authTag\r\n\r\nIt should be: \r\nskc, [pkc] = deriveKeyPair(prk)\r\nauthKey = HKDF-Expand(prk, \"AuthKey\", Nh)\r\nauthTag = hmac( authKey, pks )\r\nenvelope = (pks, authTag)\r\n\r\nHere pkc is recomputed  from prk only if needed by the client (none of the protocols we consider need that and for the case of elliptic curve keys, computing pkc costs an exponentiation, so no need to compute if not essential) and it does not need to be authenticated under hmac.  \r\npks does need to be transported in the envelope.\r\nIt could be omitted if it is assumed that the client has it. Even in this case it would be ood to send authTag so the client can check if the stored pks is authentic.\r\n\r\n\r\n",
          "createdAt": "2021-02-16T00:44:15Z",
          "updatedAt": "2021-02-16T00:44:15Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Doesn't the server need the client's pkc? (i.e. with the envelope)",
          "createdAt": "2021-02-16T00:49:25Z",
          "updatedAt": "2021-02-16T00:56:20Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I see. Only at registration, actually. During login, the client doesn't need its public key.",
          "createdAt": "2021-02-16T00:58:35Z",
          "updatedAt": "2021-02-16T01:01:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm supportive of this change under the condition that we have a *standardized* way to deterministically derive keys from a seed. HPKE provides a number of algorithms for NIST curves, which would suffice for the 3DH groups here. But it's not clear to me we want to rely on this. \r\n\r\nNote that I think this should remain as a separate EnvelopeMode. We could call it `SeedMode`, and the semantics could be as follows:\r\n\r\n- The envelope is empty (and thus consumes no bytes on the wire).\r\n- The client private key pair is derived from the OPRF output.\r\n\r\n@kevinlewi, what's your take?",
          "createdAt": "2021-02-18T22:59:35Z",
          "updatedAt": "2021-02-18T23:07:28Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we already rely on hash-to-curve for the OPRF, why could rely on its hash-to-field for the scalar",
          "createdAt": "2021-02-18T23:43:31Z",
          "updatedAt": "2021-02-18T23:43:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Since we already rely on hash-to-curve for the OPRF, why could rely on its hash-to-field for the scalar\r\n\r\nThis is fine for prime order groups. I want to emphasize again that there may be other AKE instantiations that *do not* have such groups.",
          "createdAt": "2021-02-18T23:50:34Z",
          "updatedAt": "2021-02-18T23:50:34Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "In #104, I understand that the group in 3DH must match what we use for OPRF, which is defined using prime-order groups. I'm confused.",
          "createdAt": "2021-02-19T00:02:01Z",
          "updatedAt": "2021-02-19T00:02:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, that's fine if we're using an AKE that is based on groups, like 3DH. That does not work if we're using an AKE based on, say, signatures, like SIGMA-I. ",
          "createdAt": "2021-02-19T00:15:34Z",
          "updatedAt": "2021-02-19T00:15:34Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I see. I was still fixed on using 3DH.\r\n\r\n> The envelope is empty (and thus consumes no bytes on the wire).\r\n\r\nSee above\r\n\r\n> Interestingly, your suggestion of getting rid of the whole envelope and building on the AKE authentication may work with 3DH (one would need to prove it). In the case of SIGMA, if enc_server_info is empty, the protocol breaks completely. It allows for an offline dictionary attack after a single session with the attacker acting as man in the middle between server and client.\r\n> \r\n> However, I do not think that assuming the client has the server's public key would be the common case (indeed, one of the main advantages of PAKEs is that you do not assume PKI or any form of trusted server's public key). In this case, the server sends its public key to the client which must be authenticated by the client. This will require an HMAC computed on pkU. So deriving skU directly from prk would not obviate the envelope, it will be the same as now except for contents.encrypted_creds being empty (hence also pseudorandom_pad being omitted).\r\n\r\nMy takeaway is:\r\n- > getting rid of the whole envelope and building on the AKE authentication may work with 3DH (one would need to prove it)\r\n\r\nand we don't have that prove, yet.\r\n\r\n- > the server sends its public key to the client which must be authenticated by the client. This will require an HMAC computed on pkU\r\n\r\nSo we still need an envelope, that would just be the authentication tag.",
          "createdAt": "2021-02-19T00:39:20Z",
          "updatedAt": "2021-02-19T00:39:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "After some thought and reviewing the comments here, I am not sure I am a big fan of adding the support for an extra envelope mode for this feature.\r\n\r\nMy understanding is that the main motivation for this third envelope mode is to reduce the size of the envelope, right? If it is a strictly better solution than the current proposal with \"base mode\", then I think we should aim to replace the existing \"base mode\" with one which incorporates these envelope optimizations, rather than introduce a third mode. Also, would there be an analogous version of this which supports custom identifiers but also with a smaller envelope size? Presumably we would not introduce a fourth new envelope mode, but instead this would simply be an improvement to the already-existing custom identifier mode as well.\r\n\r\nNow, if we decide that the current proposal for base mode has properties that cannot be replicated with this compressed envelope proposal, then I think we should weigh the pros and cons of having those properties versus saving on the envelope bandwidth directly. How important is it that we minimize the size of the envelope / omit sending pkS across the wire, if it comes at the cost of dealing with extra assumptions that could end up being a footgun for the wrapping application?\r\n\r\nAnyway, very interesting discussion. Looking forward to you all's thoughts on this!",
          "createdAt": "2021-02-20T11:47:37Z",
          "updatedAt": "2021-02-20T11:47:37Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "> My understanding is that the main motivation for this third envelope mode is to reduce the size of the envelope, right? If it is a strictly better solution than the current proposal with \"base mode\", then I think we should aim to replace the existing \"base mode\" with one which incorporates these envelope optimizations, rather than introduce a third mode.\r\n\r\nTotally aligned with you, here. I was also thinking that it would be an interesting candidate to replace the base mode. The philosophy would then be\r\n\"Base mode envelope is for KeyGenFromSeed() compatible setups and doesn't store any secrets. Custom mode envelope offers encrypted secrets storage, that can be used for setups without a KeyGenFromSetup() function.\"\r\n\r\nOther than reducing the size of the envelope, it slightly reduces the complexity of building the envelope and saves some calls to hashing.\r\n\r\n> Also, would there be an analogous version of this which supports custom identifiers but also with a smaller envelope size?\r\n\r\nDo you have an example in mind?\r\n\r\n> How important is it that we minimize the size of the envelope / omit sending pkS across the wire, if it comes at the cost of dealing with extra assumptions that could end up being a footgun for the wrapping application?\r\n\r\nAgreed that we need to be sure what we're doing here :)",
          "createdAt": "2021-02-20T13:32:56Z",
          "updatedAt": "2021-02-20T13:32:56Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "By the way, thinking more about the security of the Seed Mode proposal:\r\n\r\nBase Mode:\r\n- Client chooses skU from uniformly generated randomness\r\n\r\nSeed Mode:\r\n- Client derives skU directly from rwdU, which is in turn derived from (low) entropy of password and entropy of server's oprf_key.\r\n\r\nOne concern that I have with Seed Mode is that the client really has to trust that the server generated an independent oprf_key from fresh randomness in order to have confidence in its own skU. This is not an assumption that the client has to make in Base Mode.\r\n\r\nTo illustrate a hypothetical attack that would work on Seed Mode, but not on Base Mode: Imagine the server accidentally re-uses the same oprf_key for two clients, and these two clients happen to register with the same password. Then, their skUs will be identical, and in the AKE section, a *passive eavesdropper* may be able to learn things about the exchange that it wouldn't be able to learn if we had used Base Mode.\r\n\r\nOf course, the above attack assumes that the server actually re-used the oprf_key... but the nice thing about Base Mode is that the re-use of the oprf_key there does not lead to this kind of passive eavesdropper attack... right?\r\n\r\nAt any rate, I think we should be careful about introducing this kind of optimization unless we have a security proof in the UC framework which will give us the confidence we need to support it.",
          "createdAt": "2021-02-20T23:23:08Z",
          "updatedAt": "2021-02-20T23:26:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, @kevinlewi. (This more strongly motivates the potential for this to be a separate mode, rather than a replacement for the base mode since analyzing it may take more time, which may ultimately slow things down.)",
          "createdAt": "2021-02-21T01:48:32Z",
          "updatedAt": "2021-02-21T01:48:32Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed with @kevinlewi this justifies the need to keep the nonce in the envelope.",
          "createdAt": "2021-02-21T02:34:57Z",
          "updatedAt": "2021-02-21T02:34:57Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "It is true that in the seed mode you depend more on the quality of the OPRF key created on the server side. But in the base mode you depend entirely on the client randomness (if the client creates the key, which is what I expect to be the common case) and this will in many cases be of less quality than the server's.  For seed mode, the client should choose a random nonce that would be part of the seed derivation. While it is a public value, it still helps to randomize on top of the server's OPRF key. Also, this nonce will help against the case of a server that reuses the OPRF key with more than one user. Even if two users have the same password, the different nonces will produce different seeds.\r\n\r\nAre we now involving the account name, say, user@server.com, in the derivation of (what we used to call) rwd?\r\nShould we? Is there a well defined (deterministic and repeatable) identity string like that?\r\n\r\nOn the point of servers reusing the OPRF key with different users, there needs to be a HUGE warning in the RFC not to do that.   Btw, one of the mitigation of enumeration attacks uses a prf with userid name as input to derive the OPRF keys, so it ensures different oprf keys for different users.  ",
          "createdAt": "2021-03-01T22:33:55Z",
          "updatedAt": "2021-03-01T22:33:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #154.",
          "createdAt": "2021-04-15T13:26:43Z",
          "updatedAt": "2021-04-15T15:00:33Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "You mean #154 :-)",
          "createdAt": "2021-04-15T14:51:13Z",
          "updatedAt": "2021-04-15T14:51:13Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU3NDM5MjY0NzY=",
      "title": "protocol messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/85",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in the specification there is a part which defines `{#protocol-messages}`:\r\n```\r\nenum {\r\n    registration_request(1),\r\n    registration_response(2),\r\n    registration_upload(3),\r\n    credential_request(4),\r\n    credential_response(5),\r\n    (255)\r\n} ProtocolMessageType;\r\n\r\nstruct {\r\n    ProtocolMessageType msg_type;    /* protocol message type */\r\n    uint24 length;                   /* remaining bytes in message */\r\n    select (ProtocolMessage.msg_type) {\r\n        case registration_request: RegistrationRequest;\r\n        case registration_response: RegistrationResponse;\r\n        case registration_upload: RegistrationUpload;\r\n        case credential_request: CredentialRequest;\r\n        case credential_response: CredentialResponse;\r\n    };\r\n} ProtocolMessage;\r\n```\r\nin our implementation at https://github.com/stef/libopaque we omitted implementing this, for the following reasons:\r\n  * this is depending on how an application is using this protocol,  it might not be necessary to wrap protocol messages in such frames, for example because the app already has it's own framing, or different ways to communicate this.\r\n  * parsing any kind of input from possible adversaries should be done higher up the stack, where possibilities are richer to do so in memory safe ways or by implementing language security mechanisms to do so.\r\n\r\nlibopaque does however implement the credential and envelope structures.",
      "createdAt": "2020-11-16T15:24:55Z",
      "updatedAt": "2020-11-16T20:31:55Z",
      "closedAt": "2020-11-16T20:31:55Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, as you point out, this isn't strictly necessary to implement OPAQUE, so we ought to remove it from the spec. @kevinlewi, objections?",
          "createdAt": "2020-11-16T20:16:39Z",
          "updatedAt": "2020-11-16T20:16:52Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am all for removing this!",
          "createdAt": "2020-11-16T20:17:29Z",
          "updatedAt": "2020-11-16T20:17:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! See #86 for the change.",
          "createdAt": "2020-11-16T20:26:35Z",
          "updatedAt": "2020-11-16T20:26:35Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU3NDgwNDc4ODI=",
      "title": "credential_lists in CreateRegistrationResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/87",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in this section https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#registration-messages\r\n\r\n```\r\nstruct {\r\n    opaque data<0..2^16-1>;\r\n    opaque pkS<0..2^16-1>;\r\n    CredentialType secret_types<1..255>;\r\n    CredentialType cleartext_types<0..255>;\r\n} RegistrationResponse;\r\n```\r\nSpecifies\r\n\r\n> - secret_credentials_list, a list of CredentialType values clients should include in the secret_credentials list of their Credentials structure\r\n> - cleartext_credentials_list, a list of CredentialType values clients should include in the cleartext_credentials list of their Credentials structure\r\n\r\nwhat if a CredentialType is in both of these lists? Why not pack this information in 10 bits, where each CredentialType has 2 bits for signalling:\r\n```c\r\n  NotPackaged = 0,  // field is not packaged in envelope\r\n  InSecEnv = 1,        // field is encrypted\r\n  InClrEnv = 2          // field is plaintext, but authenticated\r\n```",
      "createdAt": "2020-11-21T16:07:33Z",
      "updatedAt": "2021-01-08T00:43:17Z",
      "closedAt": "2021-01-08T00:43:17Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "depending on #84 being removed or reinstated, its also interesting what happens if `skU` is included in clearttext_types. especially if #84 removes the commented out section it also means that the whole information with 2bits per CredentialType would even fit into only one byte, assuming that `skU` is mandatory to be included in secret_types\r\n  ",
          "createdAt": "2020-11-21T16:29:41Z",
          "updatedAt": "2020-11-21T16:29:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> what if a CredentialType is in both of these lists\r\n\r\nA credential should only be in one or the other. (We should add text saying that doing otherwise is a protocol violation. I certainly don't see a reason for it, at least.) We can address #84 separately.",
          "createdAt": "2020-11-24T01:43:29Z",
          "updatedAt": "2020-11-24T01:43:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "No longer relevant (and so this issue can be closed) since credentials list is not a thing anymore (after #102)",
          "createdAt": "2021-01-08T00:43:17Z",
          "updatedAt": "2021-01-08T00:43:17Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU3NDgwNDk5NTc=",
      "title": "id missing in CredentialRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/88",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in the section https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#authenticated-key-exchange-messages CredentialRequest is defined as:\r\n\r\n```\r\nstruct {\r\n    opaque data<1..2^16-1>;\r\n} CredentialRequest;\r\n```\r\nand right below that is this line:\r\n> data : An encoded element in the OPRF group. See {{I-D.irtf-cfrg-voprf}} for a description of this encoding.\r\nand in the https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#createcredentialresponserequest section it is even referred to as:\r\n```\r\n1. (kU, envU, pkU) = LookupUserRecord(request.id)\r\n```\r\n\r\neven though trivial, it might make sense to include id in the CredentialRequest structure definition.",
      "createdAt": "2020-11-21T16:17:43Z",
      "updatedAt": "2020-12-02T03:15:07Z",
      "closedAt": "2020-12-02T03:15:07Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "See #65 for the prior discussion on the removal of the id parameter from CredentialRequest.\r\n\r\nMy interpretation of the `LookupUserRecord(request.id)` portion is that it is meant for the wrapper protocol to perform the lookup, so that those details are not kept as part of the OPAQUE protocol.\r\n\r\n@chris-wood Thoughts on this / perhaps editing the text to make it more clear that OPAQUE doesn't handle lookup and doesn't manage the id in its CredentialRequest message?",
          "createdAt": "2020-11-23T03:06:33Z",
          "updatedAt": "2020-11-23T03:06:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That referenced line in the text is a bug (it should have been removed). I'm definitely supportive of clarifying the text to make it clear that identity selection and transfer between client and server is not part of OPAQUE's job. @kevinlewi, will you have time to make a PR for this?",
          "createdAt": "2020-11-24T01:41:25Z",
          "updatedAt": "2020-11-24T01:41:25Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU3NDgxMDk1Mzg=",
      "title": "rename StoreUserRecord to indicating the finalization instead of optional persistence",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/89",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just as we dropped the ProtocolMessages part, for the protocol it might be not necessary to call the function StoreUserRecord. For instance my implementation does not care about any kind of persistence or transport of the outcome of the protocol. It might be that the use-case does not need the storage of the user record, for example by just keeping it in memory, or the record might be further processed before storage. Thus i propose to rename the function to `FinalizeUserRecord` instead.",
      "createdAt": "2020-11-21T21:50:54Z",
      "updatedAt": "2021-01-14T01:57:47Z",
      "closedAt": "2021-01-13T22:39:41Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good suggestion! Like the wrapping protocol message frames, this also isn't strictly necessary. I'll take a stab at removing this text.",
          "createdAt": "2020-11-24T01:44:08Z",
          "updatedAt": "2020-11-24T01:44:08Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "well actually the function itself is kind of necessary. it adds at least the OPRF key to the record, but possibly also a per-user skS. the result is a record to be stored or persisted or whatever. the point is, that it is not really about storage of the record, but about adding the server secrets to it, that are user-specific.",
          "createdAt": "2020-11-24T02:11:51Z",
          "updatedAt": "2020-11-24T02:11:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Somewhat unrelated question, but:\r\n\r\nShould this specification define a format for the serialized version of the \"finalized object\" containing (envU, pkS, skS, pkU, kU)? Something like:\r\n```\r\nCredentialRecord {\r\n  opaque envU<1..2^16-1>;\r\n  opaque kU<1..2^16-1>;\r\n  opaque pkU<1..2^16-1>;\r\n}\r\n```\r\n\r\nAnd actually pkS does not need to be stored here, because it is already a part of the credentials object, via:\r\n\r\n\"Applications MUST include skU in secret_credentials and pkS in either cleartext_credentials or secret_credentials.\"\r\n\r\nAnd we likely do not want to advocate for storing skS somewhere like this, so we can retain/amend the comment:\r\n\r\n\"If skS and pkS are used for multiple users, the server can store these values separately and omit them from the user's record.\"",
          "createdAt": "2020-12-02T02:23:10Z",
          "updatedAt": "2020-12-02T02:23:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great question, @kevinlewi. Over in HPKE we chose to not specify storage wire formats, since they were primarily an implementation detail. That came back to haunt us when we needed to send serialized HPKE contexts between processes. So my sense is that this might be useful if we anticipate a use case where we would need to move these records around between different OPAQUE implementations. Otherwise, I think we ought to leave it to the wrapper protocol and application. ",
          "createdAt": "2020-12-02T03:14:32Z",
          "updatedAt": "2020-12-02T03:14:32Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it would be something that OPAQUE implementations would have to implement, and not leave to their wrapper protocols, since: what is a wrapper protocol expected to do with envU, kU, pkU other than treat them as raw bytestrings that should be serialized in some format?\r\n\r\nSo, if it's likely the case that OPAQUE protocols will be implementing the serialization in their own manner, I think it would be nice if we define a standard way to organize envU, kU, pkU. But this does raise other questions... should we include a version byte in this serialization?",
          "createdAt": "2020-12-03T03:52:57Z",
          "updatedAt": "2020-12-03T03:53:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> what is a wrapper protocol expected to do with envU, kU, pkU other than treat them as raw bytestrings that should be serialized in some format?\r\n\r\nIf these were serialized and minted by implementation A, then implementation A would presumably know how to parse them. I think this is useful only if, for example, implementation A mints the records and implementation B consumes them. I could see that happening in practice if, e.g., the registration and login phases were two separate processes running different implementations, wherein the registration process minted CredentialRecords and then the login process consumed them. If you think arrangements like this are likely, I see no harm in adding something like CredentialRecord.\r\n\r\nAs for serialization: yes, we should definitely version them. I'd just stick in the same version used for the protocol version, e.g.:\r\n\r\n~~~\r\nstruct {\r\n   uint16 version;\r\n   uint16 length;\r\n   select (0xff00) { // version 00 for the draft, or whatever\r\n      // information about the configuration, e.g., OPRF suite and so on, since that determines kU's encoding \r\n      Envelope envU;\r\n      Scalar kU;\r\n      opaque pkU<0..2^16-1>;\r\n   }\r\n} CredentialRecord;\r\n~~~",
          "createdAt": "2020-12-03T04:05:17Z",
          "updatedAt": "2020-12-03T04:05:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points, I see. Yes, I think this scenario could be likely, since registration and login may need to be in different languages (for example).\r\n\r\nThe struct looks good, except -- why do we need a `uint16 length;` field? Seemingly that could be omitted.",
          "createdAt": "2020-12-03T04:18:13Z",
          "updatedAt": "2020-12-03T04:18:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The struct looks good, except -- why do we need a uint16 length; field? Seemingly that could be omitted.\r\n\r\nImagine one added support for two versions of OPAQUE at the same time, yet the login only knows how to process one specific version. Since the contents of the record depend on the version, there needs to be a way for implementations that don't support a given version to skip over records they cannot parse, and the length field does just that. So for example, an implementation would read the version field and, if it's unsupported, skip `length` bytes to the next record in a list, and repeat. ",
          "createdAt": "2020-12-03T04:21:27Z",
          "updatedAt": "2020-12-03T04:21:27Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "This would only be a problem if the wrapper protocol stores these records in a contiguous sequence of bytes with no delimiters for the beginnings of each record, though, right?\r\n\r\nI don't imagine that this would ever occur... but perhaps I'm missing something. At the very least, these records would be stored as values of a map, or elements of an array.",
          "createdAt": "2020-12-03T04:46:12Z",
          "updatedAt": "2020-12-03T04:46:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that's true! If a wrapper chose to store these in a map from idU -> [records], then perhaps this would be relevant. If it has some other (simpler) way to delineate different records, we can certainly omit the length. \r\n\r\n@kevinlewi, would you mind proposing a PR for the record format?",
          "createdAt": "2020-12-03T05:09:19Z",
          "updatedAt": "2020-12-03T05:09:19Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i don't know how the hpke storage formats came to haunt you guys, but i would say that since we do not specify protocol message formats, storage formats also do not need to be specified, or if they do, they might be specified in a different rfc, together with wire formats. the question for me, is is this about the cryptographic protocol or the communication/application protocol, and for me, i prefer to stick to the cryptographic protocol only. since the communication/application protocol brings along a lot of stuff as an low level implementer would not like to implement.\r\n\r\ni am also worried about \"variable length\" records, that means complexity, i believe the implementation should know exactly how big a record or any protocol message is, without encoding it in the message. implementing parsing of these things means added complexity, and added complexity means attack surface. it is already worrying that `idU` and `idS` might be free-form strings with random lengths - i would really prefer allowing only uuids/hashes or similar fixed-width strings, that would eliminate variable lengths parsing from fixed configuration setups of opaque.",
          "createdAt": "2020-12-08T17:17:16Z",
          "updatedAt": "2020-12-08T17:17:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @stef, thanks for the comments on this, I think you bring up good points.\r\n\r\nI agree that we should stick to only specifying the cryptographic protocol. But, to clarify, aren't we already specifying message / wire formats (e.g. the bytes that consist of a RegistrationRequest) in this RFC? I see this as still being part of the cryptographic protocol. The reason being that we want a wrapper protocol to be able to not have to worry about the internals of the OPAQUE implementation, and if we did not specify the message / wire formats, then it must mean that the wrapper protocol would have to be exposed to the specifics behind kU, rwdU, etc. (which in my opinion is undesirable).\r\n\r\nA similar argument I think can be made for why we may want to specify storage formats for the password file. If we do not, then doesn't this mean that the OPAQUE protocol must expose to the wrapper protocol the individual components that make up the password file (pkU, envU, kU), and we would leave it up to the wrapper protocol to decide what to do with these objects? In my opinion, it would feel cleaner to have the OPAQUE protocol dictate how these objects would be serialized together, so that the wrapper protocol need not have to interpret what each of pkU, envU, and kU mean.\r\n\r\n> i am also worried about \"variable length\" records, that means complexity, i believe the implementation should know exactly how big a record or any protocol message is, without encoding it in the message. implementing parsing of these things means added complexity, and added complexity means attack surface.\r\n\r\nI agree with this -- I think one way in which we might hope to simplify things would be to consider the suggestions I made in #99 regarding the simplification of the envelope construction. However, this would still mean that we have a \"custom identifier\" mode, which does not solve the problem of the variable-length `idU` and `idS`. Perhaps we can draft a separate issue to talk specifically about whether or not would be a good idea to enforce fixed-width strings for `idU` and `idS`.",
          "createdAt": "2020-12-10T10:54:11Z",
          "updatedAt": "2020-12-10T10:54:11Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "xposting this here what i commented on the merged change:\r\n\r\n> i'm not sure this is a good idea, different use-cases might not need all the bells and whistles. i think i asked in an issue if this is about the standardization of the protocol or it goes beyond that and standardizes also serialization of all kind of wire and storage elements. in implementations using only one instantiation of the protocol the parameters are fixed, and don't need to be stored. if an implementation does not follow the spec and does not store this redundant info in that case, will it still be standards compliant? also some implementations might want to go beyond the currently specified two envelope setups and may want to make all credential extensions configurable, i can see reasons for all configurations. i think there should be a limit of what is part of the standard, and what is free for implementations to decide themselves, and again depending on different configurations of how credential extensions are created this can lead to very different storage formats. my take is to not specify neither the storage format of the record, nor actually the configuration of the envelope. test vectors can still be provided for the protocol, especially if serialization is not fixed, in that case the test vectors can be provided as results of the various steps of the protocol, there is no combinatoric explosion.",
          "createdAt": "2021-01-14T01:57:46Z",
          "updatedAt": "2021-01-14T01:57:46Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU3NDkyOTgxMDU=",
      "title": "Proposal: Completely remove all mention of idU and idS for the sake of simplicity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/90",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'd like to open a discussion on the following proposal: to **completely remove all mention of idU and idS** from the OPAQUE spec (aside from places where we can refer to it as guidance for an implementor of a wrapper protocol that calls OPAQUE). To be clear, this change would mean that we set idU = pkU and idS = pkS in all locations where idU and idS appear in the current draft (not to completely remove their inclusion from the draft).\r\n\r\n(Note: Past discussion on this issue occurred in #74, spawned from the question of \"Can we simply set idU = static pkU and idS = static pkS?\". This will be a continuation of some of the discussion in that issue.)\r\n\r\nThe current state of the draft suggests that we involve idU and idS in the following places:\r\n1) [As potential parameters which can be supplied to the envelope](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L414-L415) as either secret or cleartext credentials\r\n2) If they are specified in the envelope, then [they must be input as parameters to the AKE login](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1064-L1066) (by at least the server). If they were not specified in the envelope, then pkU and pkS are used in their place. They are then used to affect the [AKE key derivation](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1113-L1114).\r\n3) In the past there have also been discussions around potentially incorporating idU as part of the initial input to the OPRF: namely, instead of doing OPRF(key, password), do something like OPRF(key, HKDF(password, idU)).\r\n\r\n## Proposal\r\n\r\nDefer all mention of idU and idS to the wrapper protocol that calls OPAQUE, do not allow them to be specified in the envelope, and use pkU and pkS in their place within the AKE section.\r\n\r\nFor wrapper protocols that wish to supply an idU and idS which should be protected by the security guarantees of the OPRF, **we should instead recommend these wrapper protocols to take advantage of the [export_key parameter](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L651)** to do custom encryption/authentication for the bindings between idU/pkU and idS/pkS.\r\n\r\n### Pros\r\n\r\n- When we ultimately provide test vectors for OPAQUE, it will of course be simpler to not have to include idU and idS as parameters to the test vector generation.\r\n- Also, the above logic where the server must remember how the envelope was constructed in order to figure out how to set idU and idS is something that I suspect will trip up implementors. At the very least, we would need to produce test vectors which specifically test for these kinds of edge cases (what happens if idU and idS are specified in the envelope, and the server mis-specifies them in AKE, or what if they were not specified in the envelope, but the server tries to specify them, etc.).\r\n\r\nThe advantage to this proposal is that we can remove all of this complexity and potential for errors from the implementation side. The result is that OPAQUE no longer references any application-specific idU and idS parameters, which to me feels much cleaner than our current state where there are many conditionals and optional parameters to check (a nightmare for generating test vectors and verifying that an implementation can support all possible settings bug-free).\r\n\r\n### Cons\r\n\r\nThe main worry for removing idU and idS is the potential for a loss of generality (what if a wrapper protocol wants to tie idU and idS into the OPRF/AKE security guarantees?). I propose that we recommend wrapper protocols to use export_key for this purpose, so the details of idU and idS can remain outside of the OPAQUE protocol. There is still a cost here, because previously we used HKDF(RwdU, ...) to encrypt idU and idS, whereas now they would be using export_key, which would amount to an extra HKDF computation or two. But I think this price is totally worth the simplicity that it brings the OPAQUE protocol, especially since this is a client-side operation, and we are already recommending clients to compute a memory-hard hash function which will be way more expensive.\r\n\r\nAnd finally, to address (3), we should recommend wrapper protocols to pre-hash idU and the password before starting the OPAQUE protocol, again so that we can avoid incorporating the idU parameter within the OPAQUE protocol.\r\n\r\ncc: @hugokraw , @chris-wood ",
      "createdAt": "2020-11-24T02:59:07Z",
      "updatedAt": "2020-11-30T20:51:52Z",
      "closedAt": "2020-11-30T20:51:51Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I strongly oppose this for several reasons. Here are some:  \r\n\r\n> The result is that OPAQUE no longer references any application-specific idU and idS parameters\r\n\r\nOPAQUE is an authenticated key exchange protocol and there is no meaning to authentication without identities. Who you are exchanging a key with is not less important than the secrecy and randomness of the key. As such, OPAQUE must have idU and idS as essential elements, and indeed you cannot derive a key without them. So the only question is who determines these identities and how they are communicated in the protocol. We simplified the treatment by setting defaults (pkU and pkS) and providing a native mechanism to change this in an *authenticated* way if so desired.  If you eliminate the use of the envelope for this transmission of identities you need to either say \"sorry, you can only use pkU and pkS as identities\" (which is too restrictive) or create yet another mechanism for this authenticated transmission. I find this more complex and prone to error than including the id's in the envelope. In particular, the export key is intended for extensions to OPAQUE, not to serve a prime functionality as authenticating identities.  \r\n\r\n> the server must remember how the envelope was constructed\r\n\r\nThe server is the one to set these mechanisms at registration and there is no reason it forgets them. Moreover, the server stores the identities and it never needs to look at the envelope (except as a space optimization in case the identities contained in the envelope are not encrypted).  \r\n\r\n> we should recommend wrapper protocols to pre-hash idU and the password before starting the OPAQUE protocol, again so that we can avoid incorporating the idU parameter within the OPAQUE protocol.\r\n\r\nI would not remove idU from the AKE key derivation even if you included it under the OPRF. It is important to keep the modular composition of OPRF and AKE where each part delivers what is expected from such component. Also, one has to be careful (actually we may want to have a note on this) to avoid any replacement or instantiation of a user's identity with something like H(uid, password). If someone thinks of this as an identity then it is likely to think it does not require secrecy. Of course, if you publish H(id, password) you broke aPAKE completely as you can do an offline attack on the password just given idU.",
          "createdAt": "2020-11-25T21:18:05Z",
          "updatedAt": "2020-11-25T21:18:05Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Hugo, in reading your response, I realize that my original proposal might have been slightly unclear -- I am not advocating for removing idU and idS, but instead advocating for fixing idU = pkU, idS = pkS, and **not allowing** for the wrapper protocol to set idU and idS to anything else. (I will edit the original text to clarify this.) In other words, I am proposing to say:\r\n\r\n>  \"sorry, you can only use pkU and pkS as identities\" (which is too restrictive)\r\n\r\nCan you elaborate a bit more on why this is too restrictive, and why export_key cannot be used in the manner I suggested?\r\n\r\n> In particular, the export key is intended for extensions to OPAQUE, not to serve a prime functionality as authenticating identities.\r\n\r\nI see the use of export_key in my proposal not as authenticating identities, but simply allowing for a binding between the wrapper protocol's understanding of idU, and pkU.\r\n\r\n---\r\n\r\nBy the way, I want to place emphasis on the **simplicity** that I am aiming for with this proposal. I agree that by not allowing for custom idU and idS, we are making it more difficult for a wrapper protocol to get the security benefits of using custom idU and idS. I just want us to be cognizant of the costs that come with the increased complexity of supporting a custom idU and idS. If we come to an agreement that this increased complexity is worth the support for the feature, then we should definitely support it.\r\n\r\nOne way that I see the complexity being increased by supporting custom idU and idS here is the following. Let's say we come across an OPAQUE implementation in the wild. How difficult is it to check whether or not it complies with this specification? How many edge cases does one need to verify with the OPAQUE implementation (adding custom idU, putting idU in the envelope but not reusing it in the AKE section, etc.) in order for the community to be able to confidently say that it is in compliance? At the very least, we would need to provide a set of test vectors which test each edge case. I'd like for us to keep in mind that we do not want the complexity of correctness verification to be too large. Otherwise, we may end up in a situation where we produce a complete specification, but implementations frequently have bugs.",
          "createdAt": "2020-11-25T21:38:39Z",
          "updatedAt": "2020-11-25T22:01:01Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I appreciate any simplification but not enough in this case to \"outsource\" the management of identities outside the protocol. The identities need to be communicated in an authenticated way and I prefer not to trust wrappers or random implementers to take good care of it. Is the complexity we are talking about coming from letting wrappers choose identities that are neither pkU, pkS or those included in the envelope?  Would it be ok if we limit implementations to reduce flexibility of choosing identities to the following line:\r\nIf Envelope.Ids != null  set  IdU=envelope.idU, idS=envelope.idS else set  idU=pkU, idS=pkS\r\nand everywhere else use idU and idS as set in this line?\r\nWould that still leave corner cases?\r\n",
          "createdAt": "2020-11-25T22:54:01Z",
          "updatedAt": "2020-11-25T22:54:01Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is the complexity we are talking about coming from letting wrappers choose identities that are neither pkU, pkS or those included in the envelope?\r\n\r\nNo, I believe that we are already disallowing for this to occur. The identities must be set in the envelope, or if not set, then default to pkU and pkS. So, this is not where the extra complexity would be coming from.\r\n\r\nAfter some more thought on this + your suggestions, @hugokraw, I think I can reduce my concerns down to the following:\r\n1) There is a lot of flexibility in how the envelope is configured. What if the server says that the envelope contains an idU but no idS, or vice versa? We would need to produce test vectors for each possible setting and check that the appropriate behavior occurs in the AKE section, which is quite cumbersome.\r\n2) Setting idU and idS to be the empty string in the envelope is very different from not setting idU and idS in the envelope. I'm worried that implementations will get this wrong, since often the empty string is syntactically similar to \"not being set\", and so we may need to add test vectors to address this as well.\r\n\r\nEssentially both of these issues can be boiled down to reducing the complexity of setting the structure of the envelope. One solution I can think of for addressing this potential ambiguity is to take note from the VOPRF RFC and perhaps define \"modes\" for the envelope, either a \"base mode\" which does not set idU and idS, and a \"custom identifier mode\" which requires idU and idS to be set in the envelope.\r\n\r\nI have some other concerns about the customizability of the envelope, which I plan to create an issue about to address all at once. So I will close out this issue and instead defer further discussion of the above two points to a new issue about simplifying the complexity of the envelope itself.\r\n\r\nThanks for the fruitful discussions -- hope this makes sense!",
          "createdAt": "2020-11-30T20:51:51Z",
          "updatedAt": "2020-11-30T20:51:51Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU3NTE4Mzg3MTE=",
      "title": "Update to the new VOPRF draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/91",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-26T21:44:13Z",
      "updatedAt": "2020-12-01T22:21:45Z",
      "closedAt": "2020-12-01T22:21:45Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU3NTU3ODkzNjE=",
      "title": "Remove RequestMetadata type",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/94",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This struct stores the scalar across Request/Finalize calls, which both happen on the client. There's no need to serialize or send this value on the wire anywhere, so we should just defer its representation to the underlying implementation. Given that the OPRF API is already a dependency we expose, I suggest we replace RequestMetadata with the actual type `Scalar`. \r\n\r\nWhile we're in here, we might also consider removing superfluous wrappers around OPRF types (like `RegistrationRequest` and `CredentialRequest`). \r\n\r\n@kevinlewi, what do you think?",
      "createdAt": "2020-12-03T03:42:32Z",
      "updatedAt": "2020-12-03T04:14:20Z",
      "closedAt": "2020-12-03T04:14:20Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me. Just to be clear, none of the changes that you are referencing will actually affect the bytes being output by these functions, right? They are just syntactic changes to clean up the presentation if I am understanding correctly.",
          "createdAt": "2020-12-03T03:48:43Z",
          "updatedAt": "2020-12-03T03:48:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, partly. RequestMetadata contains a vector encoding of a scalar (so a serialized scalar prefixed by its length), but that's not really needed. What I'm suggesting is that we just output a scalar, e.g.:\r\n\r\n```\r\nCreateCredentialRequest(pwdU)\r\n\r\nInput:\r\n- pwdU, an opaque byte string containing the user's password\r\n\r\nOutput:\r\n- request, an CredentialRequest structure\r\n- r, an OPRF Scalar value\r\n\r\nSteps:\r\n1. (r, M) = Blind(pwdU)\r\n2. Create CredentialRequest request with M\r\n3. Output (request, r)\r\n```",
          "createdAt": "2020-12-03T03:52:03Z",
          "updatedAt": "2020-12-03T03:52:03Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, got it. Yes, this makes sense, I believe in my implementation I already omitted the length prefix anyway.",
          "createdAt": "2020-12-03T03:56:13Z",
          "updatedAt": "2020-12-03T03:56:13Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU3NTY2MTMyNTY=",
      "title": "Envelope correctness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The record sent from client to server during the registration phase is as follows:\r\n\r\n~~~\r\nstruct {\r\n    Envelope envelope;\r\n    opaque pkU<0..2^16-1>;\r\n} RegistrationUpload;\r\n~~~\r\n\r\nAs is, the server has no assurance that the private key corresponding to `pkU` is inside (or derived from) the envelope. This raises two questions:\r\n\r\n1) Does the client need to prove possession of `skU`?\r\n2) If so, how would this work (non-interactively) for DH-based public keys? If not, we should probably add text clarifying why this isn't needed.",
      "createdAt": "2020-12-03T21:41:04Z",
      "updatedAt": "2023-01-22T00:53:38Z",
      "closedAt": "2020-12-16T21:08:11Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Although it would be nice if the client could prove possession of `skU`, I don't think it merits the extra complexity / computation that would be required, since I cannot imagine a scenario in which the server would need the assurance that the private key corresponding to `pkU` is inside the envelope. Did you have an example scenario in mind?",
          "createdAt": "2020-12-04T00:44:10Z",
          "updatedAt": "2020-12-04T00:44:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nothing comes to mind right now, though I haven't given it much thought. ",
          "createdAt": "2020-12-04T01:13:15Z",
          "updatedAt": "2020-12-04T01:13:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's close this for now. We can re-open if needed later on.",
          "createdAt": "2020-12-16T21:08:11Z",
          "updatedAt": "2020-12-16T21:08:11Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't mean to reopen, but should we mention in the doc that we have thought of this but don't see it as necessary?",
          "createdAt": "2023-01-22T00:53:38Z",
          "updatedAt": "2023-01-22T00:53:38Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU3NTY3MDY2MTc=",
      "title": "Defining SerializeExtensions and DeserializeExtensions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/97",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L444-L446): Don't these functions need to be defined somewhere? At least they should sort the extensions by their type, perhaps in increasing order. It seems defining these in the specification is a requirement to producing compatible test vectors.\r\n\r\ncc: @chris-wood ",
      "createdAt": "2020-12-04T00:53:48Z",
      "updatedAt": "2021-01-11T15:07:16Z",
      "closedAt": "2021-01-11T15:07:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At least they should sort the extensions by their type, perhaps in increasing order.\r\n\r\nSorting isn't required, since each extension is identified by its type. That said, adding more detail so their implementation is clear wouldn't hurt.",
          "createdAt": "2020-12-04T01:18:04Z",
          "updatedAt": "2020-12-04T01:18:04Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "If one implementation decides to sort the credentials in increasing order, and another decides to sort the credentials in decreasing order, then they will end up with a different HMAC output. Our test vectors will pick some ordering in order to generate the HMAC, and so seemingly this ordering should be spelled out in the specification, right?",
          "createdAt": "2020-12-04T02:07:44Z",
          "updatedAt": "2020-12-04T02:07:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, yeah, good point about different implementations. I\u2019ll draft up a PR for this soon.",
          "createdAt": "2020-12-04T02:11:40Z",
          "updatedAt": "2020-12-04T02:11:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is addressed by #107, which removes these credential serialize functions. The structs are already in wire format and don't need further serialization.",
          "createdAt": "2021-01-06T22:18:35Z",
          "updatedAt": "2021-01-06T22:18:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved.",
          "createdAt": "2021-01-11T15:07:15Z",
          "updatedAt": "2021-01-11T15:07:15Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU3NTY3MDk3ODM=",
      "title": "Removing auth_data from the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/98",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think we should remove the [`auth_data` field](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L455) in the envelope, but still keep it as part of the [HMAC derivation process](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L639-L641). The only reason why this might be set is if it contains a credential that is marked as a member of cleartext_credentials. But in this case, why not just make it a secret_credentials instead?\r\n\r\nThe advantage of cleartext_credentials are only apparent when the credential itself is NOT included in auth_data (and hence does not affect the total size of the envelope).",
      "createdAt": "2020-12-04T01:02:09Z",
      "updatedAt": "2021-01-08T00:42:38Z",
      "closedAt": "2021-01-08T00:42:38Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a fine idea, but we still need a way for the client to know what values to include in the HMAC computation. Would the server supply, in its CredentialResponse, the list of cleartext_credential types used?",
          "createdAt": "2020-12-10T22:20:19Z",
          "updatedAt": "2020-12-10T22:20:19Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed in #102 ",
          "createdAt": "2021-01-08T00:42:38Z",
          "updatedAt": "2021-01-08T00:42:38Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU3NTY3MTMzMjc=",
      "title": "Simplifying the options for the credentials list in the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/99",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue is related to #87 and #90, in which the complexities of the setting of the envelope have come up.\r\n\r\nOne problem I foresee happening with allowing the server to choose what parameters should be optional, [which go in secret_credentials, which go in cleartext_credentials, etc.](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L442) is that it becomes cumbersome to manage exhaustive test vectors that would test all of the edge cases (combinations of these settings). And if we choose to only provide test vectors for some default setting, we run the risk of an implementation in the wild incorrectly implementing support for a non-default setting that we did not provide test vectors for.\r\n\r\nTo remedy this, one approach we could take would be to allow for only a small (maybe 2?) set of options for organizing the credentials in the envelope. Perhaps a \"base mode\" and a \"custom identifier mode\", and we could spend a single byte to dictate the mode for the envelope (similar to the VOPRF RFC with the byte representing the base mode or verifiable mode). Base mode would be some default, and \"custom identifier mode\" would support a custom idU and idS being included as secret_credentials.\r\n\r\nIf this sounds good, then now we just need to decide what modes we will support, and what each mode will look like.\r\n",
      "createdAt": "2020-12-04T01:10:53Z",
      "updatedAt": "2021-01-08T23:27:36Z",
      "closedAt": "2021-01-08T00:42:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this idea. Given that the number of credential types is likely quite small, I'm in favor of simplifying things and offering two modes here. For the \"custom identifier mode,\" either idU or idS could be nil, if desired, right? Or would we require that they both non-nil?",
          "createdAt": "2020-12-10T22:17:59Z",
          "updatedAt": "2020-12-10T22:17:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should allow for nil idU and idS, because it is not easy to check/enforce that idU and idS, and even if it were easily checkable, it is still an additional check that the OPAQUE implementation would have to do, which increases complexity.",
          "createdAt": "2020-12-10T22:42:11Z",
          "updatedAt": "2020-12-10T22:42:11Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Both idu and ids are used in the \"info\" / \"transcript\" (naming is not consistent) parameter in HKDF. Having them _nillable_ means the HKDF only relies on the nonces. I don't know if that's a problem.\r\n\r\nMoreover, both idu and ids are used in Sigma.",
          "createdAt": "2020-12-23T10:23:23Z",
          "updatedAt": "2020-12-23T11:18:41Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The default behavior (base mode) is for them to be set to pkU and pkS. Only in customIdentifier mode can they be set to arbitrary strings. We discussed this a bit -- and we decided to allow null values to be set, since it is up to the wrapper protocol to dictate what should represent valid identities for idU and idS. Even if we were to disallow null values, they could still be set to 1-byte values... so the best we can do is to advise for defaulting to base mode unless the implementer really wants to use the custom identifier mode in this manner.",
          "createdAt": "2021-01-08T00:42:02Z",
          "updatedAt": "2021-01-08T00:42:02Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved by #102 ",
          "createdAt": "2021-01-08T00:42:22Z",
          "updatedAt": "2021-01-08T00:42:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you very much for the additional information :)",
          "createdAt": "2021-01-08T23:27:36Z",
          "updatedAt": "2021-01-08T23:27:36Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU3NjEyNTY1MDI=",
      "title": "export_keys also need AE with RKR",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/100",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "since my implementation has been prominently featured in the \"partitioning oracles paper\" i was thinking that the export_key must also only be used with key-committing AE schemes. i think this should be emphasized where export_keys are mentioned in the draft.",
      "createdAt": "2020-12-10T13:48:07Z",
      "updatedAt": "2020-12-21T16:42:15Z",
      "closedAt": "2020-12-21T16:42:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, this is an interesting point. @hugokraw, are there key-committing restrictions for the export key in terms of how it can be used by applications?",
          "createdAt": "2020-12-16T21:24:14Z",
          "updatedAt": "2020-12-16T21:24:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a good question but the answer is no. The export key has no special restrictions except for the remark in the {#export-usage} section: _The exporter_key MUST NOT be used in any way before the HMAC value in the envelope is validated._",
          "createdAt": "2020-12-16T21:56:48Z",
          "updatedAt": "2020-12-16T21:56:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I'll draft a PR that notes this in the Security Considerations.",
          "createdAt": "2020-12-17T01:59:43Z",
          "updatedAt": "2020-12-17T01:59:43Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be merged with PR 101 - see comment there.",
          "createdAt": "2020-12-17T06:23:03Z",
          "updatedAt": "2020-12-17T06:23:03Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU3NzMyOTUxNDE=",
      "title": "Sigma-I signature algorithm specification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/103",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nSigma uses signatures, for which no algorithm has been specified in the current draft.\r\n\r\nsku/pku can be generated and used independently from the ciphersuite used in the rest of the protocol and stored in the envelope. This would introduce one more parameter, and for Sigma only, if OPAQUE allows for that kind flexibility. From what I understand, the number of parameters is already a concern.\r\n\r\nHow should the Sigma signature algorithm be set or chosen ?",
      "createdAt": "2020-12-22T22:39:11Z",
      "updatedAt": "2021-02-03T20:29:00Z",
      "closedAt": "2021-02-03T20:29:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We're not specifying a wire format version of SIGMA-I, so this will need to be done in a future draft that specifies SIGMA-I. Thus, I'm closing this for now.",
          "createdAt": "2021-02-03T20:29:00Z",
          "updatedAt": "2021-02-03T20:29:00Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU3NzM3MDYyMTU=",
      "title": "Specify group for AKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/104",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft does not specify what groups can or should be used for the AKE. I first thought it was the same as for the OPRF.\r\n\r\nShould the group for the AKE be the same as for the OPRF, or is an additional parameter necessary?",
      "createdAt": "2020-12-23T12:03:22Z",
      "updatedAt": "2021-02-03T00:35:30Z",
      "closedAt": "2021-02-03T00:35:30Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this has been addressed now (it must match the one used for the OPRF). Let's close this",
          "createdAt": "2021-02-03T00:35:30Z",
          "updatedAt": "2021-02-03T00:35:30Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU3NzQ2MTE0ODI=",
      "title": "Update wrapper protocol APIs to pass in credentials to FinalizeRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/105",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Following up on the comment above, we might simplify things by delegating the \"credential construction\" logic to the wrapper protocol, which (a) knows the mode and (b) has the relevant information (skU, idU, pkS, idS, etc). That would make the interface to `FinalizeRequest` something like so:\r\n\r\n```\r\nFinalizeRequest(pwdU, creds, blind, response)\r\n```\r\n\r\nWhere `creds` contains the `secret_credentials` and `cleartext_credentials`, already in wire format form, to use when creating the envelope.\r\n\r\n_Originally posted by @chris-wood in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/102#issuecomment-749720379_",
      "createdAt": "2020-12-25T03:13:54Z",
      "updatedAt": "2021-01-06T21:48:01Z",
      "closedAt": "2021-01-06T21:48:01Z",
      "comments": []
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU3ODE4MTcwMjQ=",
      "title": "3DH transcript is incomplete",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/108",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The 3DH transcript used in the key schedule [currently includes only the nonces and identity](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-4.2.2.2). This means the contents of info1, info2, and the core OPAQUE messages are not mixed into encryption or MAC keys, which seems less than idea. They are included in the transcript that is covered by the MAC, but I don't see why wouldn't *also* include them in the key schedule. \r\n\r\n@hugokraw, can this be improved?",
      "createdAt": "2021-01-08T03:37:18Z",
      "updatedAt": "2021-02-17T19:49:20Z",
      "closedAt": "2021-02-17T19:49:20Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The protocol is secure as defined. Adding more elements to the key derivation does not hurt, even if not strictly necessary, but omitting elements is insecure. In particular, including the transcript instead of the currently defined info, may not include identities as these may not be appear in the transcript (are idU and idS necessarily transmitted explicitly as part of the transcript?) and identities are needed in the derivation.\r\nYou could just add a transcript element to the key derivation in addition to \"info\". In this case, the derivation of SK could use transcript3 as currently defined, but the derivation of handshake_secret cannot use transcript2. It will need to define a new value transcript2' that stops before Einfo2. \r\nI am not sure the extra complexity is worth given that the simpler derivation suffices here.\r\n\r\nTypo: The elements marked with * in the protocol description to indicate that they are optional appear as _ in the published draft (e.g., info1_)",
          "createdAt": "2021-01-08T18:04:44Z",
          "updatedAt": "2021-01-08T18:04:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this issue? @chris-wood ",
          "createdAt": "2021-02-02T00:56:14Z",
          "updatedAt": "2021-02-02T00:56:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think so. It's quite inconsistent that the transcript used for key confirmation is not that which is used for key derivation. We should unify these two, as has been done in TLS 1.3. I'll use this issue to track that.",
          "createdAt": "2021-02-14T21:45:46Z",
          "updatedAt": "2021-02-14T21:45:46Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Session id's (nonces in this case) and identities is all you need as input to the key derivation. As I answered before, I am ok with adding transcript to the derivation mainly to avoid these questions, but it does not have a real cryptographic function once you authenticate the transcript during the handshake. If you add the transcript you may remove the nonces from info as they are part of the transcript, but you need to keep the identities (in addition to the transcript) which may not be part of the transcript.  ",
          "createdAt": "2021-02-14T22:14:30Z",
          "updatedAt": "2021-02-14T22:14:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I understand that these are necessary, but it's awkward (from a protocol perspective) to omit everything else that's actually sent over the wire. We should follow best practice here, which is to fold as much into the transcript and key schedule as possible.",
          "createdAt": "2021-02-14T22:27:11Z",
          "updatedAt": "2021-02-14T22:27:11Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Where is the elegance of simplicity? Ok. Add the transcript but keep the identities as explicit entries, in addition to the transcript.",
          "createdAt": "2021-02-15T04:35:45Z",
          "updatedAt": "2021-02-15T04:35:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My claim is that it's less elegant as-is. The proposal allows clients and servers to only keep a running hash that includes the identifies and transcript processed so far. In contrast, the current text requires endpoints to do special processing of the KE messages to extract the nonces. It's more complex in practice.",
          "createdAt": "2021-02-15T04:38:52Z",
          "updatedAt": "2021-02-15T04:38:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with this. Elegance and aestethics are contextual and in the eye of the beholder. And, you are right, the running hash is the right way to go. When all the fog of these changes dissipates, I'll have to take a comprehensive look at the specification. Right now, I see parts and pieces and not the whole picture. ",
          "createdAt": "2021-02-15T04:45:26Z",
          "updatedAt": "2021-02-15T04:45:26Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU3ODE4MjA0NDQ=",
      "title": "Remove optional fields from 3DH",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/109",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The 3DH instantiation currently allows servers to send plaintext info in the second message, clients to send plaintext info in the third message, and clients to send encrypted info in the third message. This seems like too many options. In particular:\r\n\r\n1. Since there is no cryptographic algorithm negotiation as part of the protocol, the primary benefit of info2 is to avoid server encryption in the second flight. This means that applications need to make a determination about what data is sensitive or not. (Servers already have the encryption keys at this point, so they can send anything they need encrypted and avoid giving applications an option.)\r\n2. Clients have the encryption keys necessary to encrypt application info in the third message. Similar to (1), this means applications must make a choice about what data is sensitive. Removing that choice, by folding info3 into einfo3, simplifies things. \r\n3. Sending application info in the third flight does not make much sense to me in general. If clients need to send info in the third flight, it can be encrypted using keys derived from the output of OPAQUE, i.e., the main traffic secret `SK`, rather than keys derived from `handshake_secret`. I can't think of an example where a client would want to send data in the third flight that MUST be processed before the key confirmation message.\r\n\r\nBased on the above, I think we should do the following: remove `info2`, `info3`, and `einfo3` from the protocol. `info1` and `einfo2` are sufficient for clients and servers to safely exchange application info as a preamble to the traffic secret, and all other info can be sent, encrypted, under a key derived from SK. \r\n\r\n@hugokraw, @kevinlewi, what do you think?",
      "createdAt": "2021-01-08T03:48:00Z",
      "updatedAt": "2021-02-03T21:52:52Z",
      "closedAt": "2021-02-02T00:55:43Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am all for this! Especially if there is no decrease in security.",
          "createdAt": "2021-01-08T04:04:46Z",
          "updatedAt": "2021-01-08T04:04:46Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am ok with removing info2 and info3. I would leave einfo3 as there is no security decision to make here. If you are in a setting that requires sending something in the third flow, you use it. If there is no need for it, you don't. So the decision is a purely functional one, not security related. I find it hard to say that no reasonable application will need to use einfo3, , in particular, given that it is the first place where the client can communicate encrypted information to the server. ",
          "createdAt": "2021-01-08T19:46:53Z",
          "updatedAt": "2021-01-08T19:46:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I find it hard to say that no reasonable application will need to use einfo3, , in particular, given that it is the first place where the client can communicate encrypted information to the server.\r\n\r\nMy claim is that an application which needs to send info in the third message can send it encrypted with a key derived from SK, not from a handshake secret. This means there's effectively two ways to send information in the third flight -- either in einfo3 or in application data -- and it seems simpler to just force applications to use application data. ",
          "createdAt": "2021-01-08T20:03:11Z",
          "updatedAt": "2021-01-08T20:03:11Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Kevin, didn't one of your applications used the key as a token rather than to encrypt data as soon as the handshake was done? That would be an example of an application that could use einfo3 (which may or may not be Kevin's case but still a reasonable one).",
          "createdAt": "2021-01-08T21:47:35Z",
          "updatedAt": "2021-01-08T21:47:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, the application I had in mind relied on the *server encrypting data to the client*, using the shared secret established at the end of the key exchange. einfo3 is used for data being sent from client to server.\r\n\r\nBut, to clarify the original question: Right now, the draft says to compute:\r\n```\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\n```\r\nand use Ke3 as the encryption key for encrypting einfo3. What I would like to understand is: why do we need to derive this encryption key in this manner; why not just rely on using the shared secret as the encryption key instead?\r\n\r\nIf there are no *security concerns* with doing so, then we would like to remove einfo3 from the specification and defer it to the wrapper protocol that calls OPAQUE, since the wrapper protocol will have access to the shared secret and can choose to encrypt whatever equivalent of einfo3 it wishes.\r\n",
          "createdAt": "2021-01-08T21:53:26Z",
          "updatedAt": "2021-01-08T21:53:26Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume that by shared secret you mean SK. In that case, anything encrypted under SK must be considered application data and nothing that upon which the server will decide to establish the key or authenticate the client. The encrypted information SHALL NOT be part of the key exchange, If it is part of the key exchange then it needs to be sent in the clear or encrypted under Ke3 (otherwise you break the essential indistinguishability property of the key exchange). \r\nI was thinking of an application where the shared key SK is not intended for use  immediately at the end of the key exchange but later as some form of token  (in which case you may not want SK to be used immediately after the key exchange).",
          "createdAt": "2021-01-08T22:22:48Z",
          "updatedAt": "2021-01-08T22:22:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was thinking of an application where the shared key SK is not intended for use immediately at the end of the key exchange but later as some form of token (in which case you may not want SK to be used immediately after the key exchange).\r\n\r\nHmm, couldn't this application derive two keys from SK -- one for sending encrypted info immediately, and another for future usage as you suggest? I think what @kevinlewi is zeroing in on is the desire to remove application-specific knobs from the handshake, since it complicates the specification and implementation.",
          "createdAt": "2021-01-08T22:31:19Z",
          "updatedAt": "2021-01-08T22:31:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Hmm, couldn't this application derive two keys from SK\r\n\r\nYes, it could. In my eyes it is a less elegant solution and requires the application to understand how to derive these two keys and handle the secure information. \r\n\r\nI agree with reducing as much as possible the security decisions an implementation/application needs to make (such as \"should I  send this in the clear or encrypted\") but whether I need to send something or not as part of the 3rd message (w/o having to decide on encrypting it or not) is a simpler question for the implementation. \r\n\r\nHowever, since this is an issue that does not have immediate security consequences (except for applications that may handle insecurely information that could have been accommodated in einfo3) I will go with your preference.",
          "createdAt": "2021-01-08T22:55:05Z",
          "updatedAt": "2021-01-08T22:55:05Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello,\r\n\r\nif I may, my two cents.\r\n\r\nAs an [implementer](https://github.com/bytemare/opaque), I find this discussion very interesting and am very happy it takes place. I did not understand the necessity of `info2 `and `info3 ` within the messages as `einfo2` and `einfo3` were available (there would be a redundancy having the plaintext message and encrypted message), and agree that leaving `info2 `and `info3` out would be preferable.\r\n\r\nAs for encrypting data in the third message, it really is a specific need of some applications and their choice to send it at that moment, hence not the protocol's responsibility (so no `einfo3` either). The document could give indications to implementors and users on how to properly use the output shared secret key (e.g. derive per need - encryption, token, etc.), and cite immediate usage for encryption as an example.",
          "createdAt": "2021-01-09T00:29:12Z",
          "updatedAt": "2021-01-09T00:54:38Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> The document could give indications to implementors and users on how to properly use the output shared secret key (e.g. derive per need - encryption, token, etc.), and cite immediate usage for encryption as an example.\r\n\r\nThanks, I think this is a good suggestion -- perhaps it would be worth adding a short sentence/paragraph to explain this.",
          "createdAt": "2021-01-10T01:56:56Z",
          "updatedAt": "2021-01-10T01:56:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i have not quite understood concrete applications of these fields. however i have a feeling that the `*info*` fields can be related to protocols building upon opaque and can be used to convey protocol specific info, while the application would always use shared secret SK.",
          "createdAt": "2021-01-24T20:17:11Z",
          "updatedAt": "2021-01-24T20:17:11Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef The purpose of these fields is to allow for the sending of information that can be authenticated (in the case of info1) and authenticated+encrypted (in the case of info2) **before** the shared secret SK is established.\r\n\r\nI believe this issue may also be closed now that the info fields have been clarified, but please reopen if there is more discussion to be had here.",
          "createdAt": "2021-02-02T00:55:43Z",
          "updatedAt": "2021-02-02T00:55:43Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks @kevinlewi i do understand what security properties these fields come with. what i wonder is concrete examples/use-cases how/where these fields are used - specifically what they would contain. one might assume that e.g. the MHF parameters would be such, but iirc that is not a good example. what would be good examples?",
          "createdAt": "2021-02-03T21:52:52Z",
          "updatedAt": "2021-02-03T21:52:52Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU3ODMyODI1NTA=",
      "title": "Encryption in the AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/111",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What encryption method should we use to encrypt the `einfo2` field of the AKE section?\r\n\r\nI propose that we go with a simple XOR + HKDF based approach. Namely, take the current `Ke2` encryption key, feed it as input to `HKDF-expand`, and xor it with the plaintext to be encrypted. We can obtain the length parameter for HKDF-expand by simply measuring the length of the plaintext (correspondingly, the length of the ciphertext when we need to decrypt).\r\n\r\nThis XOR-based encryption method does not provide integrity, and only works for a single use of the `Ke2` encryption key, but I believe this is OK because `Ke2` only gets used exactly once anyway, and integrity is already provided by the MAC that is computed using `Km2`.\r\n\r\nIn particular, I want to avoid using more heavyweight but traditional algorithms like AES-GCM-256 / ChaCha20-Poly1305 because this increases complexity of the specification.\r\n\r\nThoughts? @hugokraw @chris-wood ",
      "createdAt": "2021-01-11T11:15:35Z",
      "updatedAt": "2021-02-02T00:53:23Z",
      "closedAt": "2021-02-02T00:53:23Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Several comments:\r\n- While using GCM seems heavyweight relative to simple xor, some implementations may prefer it to xor since they already have the code that uses GCM for handshake traffic protection, e.g., borrowed from TLS. But fixing the encryption method avoids negotiation which is a real simplification. If  @chris-wood is ok with this, then I am ok with it too.\r\n- One needs AEAD here. The fact that it is a one-time key does not replace that requirement. For example, if an application were to send some negotiation information under einfo2, an attacker could flip some bits to change the offered security parameters.\r\n- The question that remains is whether to add an HMAC on top of the xor-generated ciphertext for achieving authenticated encryption or to count instead on the 3DH MAC for that purpose. Doing the latter would be secure and would indeed eliminate the need for the additional HMAC (and the derivation of an additional HMAC key). I do dislike this idea on \"principle\" grounds. I always advocate the principle that one should not use the same component for two different purposes, see for example https://mailarchive.ietf.org/arch/msg/cfrg/5ithq2sRpf7QZZ_pk_jrdGJwy3k/\r\nIn the case at hand, I can think of a future variant of the protocol where the server sends the MAC on a 4th flow, thus removing the MAC protection of  einfo2 (this case is not completely hypothetical: Stas and I have a variant of OPAQUE with some interesting properties that just does that). However, if you guys think this consideration is too academic and a note on it would suffice then I can go with it. \r\n- One has to be careful about determining the length of the plaintext to be encrypted; ambiguity in determining length leads to some attacks in some cases.",
          "createdAt": "2021-01-11T15:58:43Z",
          "updatedAt": "2021-01-11T15:58:43Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments @hugokraw!\r\n\r\n> The question that remains is whether to add an HMAC on top of the xor-generated ciphertext for achieving authenticated encryption or to count instead on the 3DH MAC for that purpose.\r\n\r\nI agree with these points. However, I am leaning towards relying on the 3DH MAC and omitting the \"extra HMAC on top of the xor-generated ciphertext\", although I think we can (and should) definitely add a note in the description of the encryption of einfo2 that we critically rely on the 3DH MAC for integrity (and that future amendments should take this into account when modifying the protocol).\r\n\r\nThe main reason why I would like to avoid adding another HMAC is that it seems wasteful in terms of bandwidth. This will increase the message length by another 16 or 32 bytes, even if einfo2 is only 1 byte long -- and in the case where einfo2 is 0 bytes long, do we still generate the HMAC? If so, it seems wasteful, and if not, then implementations must take care to check for the length of einfo2 and case on whether or not it is empty. While doable, it means that when we generate test vectors for implementations to match against, we may need to generate an extra set of test vectors that ensure that implementations explicitly do this check.",
          "createdAt": "2021-01-11T16:39:52Z",
          "updatedAt": "2021-01-11T16:39:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If einfo2 is omitted then no need for the HMAC. I am not sure how crucial the bandwidth issue is and if it is enough of a reason to  make this decision (I would prefer to have the HMAC in the spec and havea note saying that if bandwidth is critical enough then the HMAC can be skipped, assuming the 3DH MAC stays in that same flow. If we do decide to forgo the HMAC all together then there should be a note on the essential need for the 3DH MAC in the same flow AND that no action should be taken on the basis of information encrypted under einfo2 before that 3DH MAC is verified.",
          "createdAt": "2021-01-11T17:00:55Z",
          "updatedAt": "2021-01-11T17:00:55Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Does that mean that 3DH will be used exclusively as the AKE ?",
          "createdAt": "2021-01-21T23:23:14Z",
          "updatedAt": "2021-01-21T23:23:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Applications can choose to use any AKE they want with OPAQUE. For example TLS would use their handshake AKE (essentially SIGMA-I). IKE  and Signal could use it with variants of SIGMA-R and 3DH, respectively, and PQ AKEs could use it with some PQ KEM-based protocols. The 3DH protocol as specified here serves as one fully-specified AKE for applications that do not want to develop or adapt other AKEs and, very importantly, as a basis for interoperability testing. Probably also as a \"must implement\" for implementations that call themselves \"compliant\" with the standard (but this may not apply here as this is an informational RFC, I guess). @chris-wood can say more in this regard. \r\n",
          "createdAt": "2021-01-22T17:58:24Z",
          "updatedAt": "2021-01-22T17:58:24Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> but this may not apply here as this is an informational RFC, I guess\r\n\r\nMy understanding is that we are very much shooting for a concrete RFC for implementations to measure compliance against.\r\n\r\n> Does that mean that 3DH will be used exclusively as the AKE ?\r\n\r\nThat is the current direction that we are going in. @chris-wood posed this question to the mailing list (https://mailarchive.ietf.org/arch/msg/cfrg/N5AsUuSTEBcrfGCgxirPI0xFkps/), as we are also trying to figure out if we should be supporting AKEs other than 3DH here.",
          "createdAt": "2021-01-22T18:12:05Z",
          "updatedAt": "2021-01-22T18:12:05Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that we now implement the XOR + HKDF based approach here (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1023-L1024), I believe this issue can be closed.\r\n\r\nPlease reopen if this is still unresolved!",
          "createdAt": "2021-02-02T00:53:23Z",
          "updatedAt": "2021-02-02T00:53:23Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU3ODM3NjcyMTA=",
      "title": "Suggested Changes 1/11/21",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "I read through the draft (https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html on 1/11/21), and have a few comments.\r\n\r\n-\tAdd `pwdU` to section 1.2\r\n-\tAdd OPRF `KeyGen()` to section 2 (referenced in section 3.2.2.2)\r\n-\tThe type of `mode` in the `InnerEnvelope` struct should be `EnvelopeMode`\r\n-\tSection 3.1: The text above the definition of the `Envelope` and `InnerEnvelope` structs says, \u201cThese credentials are embedded into the following structure\u2026\u201d. I therefore expected to see a `SecretCredentials` struct and `CleartextCredentials` struct in either `Envelope` or `InnerEnvelope`. There is a field for \u201cencrypted_creds\u201d, which could correspond to the encryption of the `SecretCredentials`, but there still seems to be no place where `CleartextCredentials` can be embedded into these structs.\r\n-\tBe consistent about the use of parens for functions which output multiple values (see protocol diagrams at top of section 3.2 and at the top of 3.3)\r\n-\tNotation for kU: section 1.2 says \u201ckU refers to U's private OPRF key\u201d. Without any other context, I expect this to be something generated by the user, and known only to the user. But in reality, kU is a per-user key generated by the server, and not revealed to the client. Is there a different way to describe `kU` to avoid this potential confusion?\r\n-\tOPRF blind is referred to as both `blind` and `r`. Make this consistent for clarity.\r\n-\tNeed to define the `Credentials` structure mentioned at the end of section 3.1: fields of this struct are referenced in section 3.2.2.3, but never defined.\r\n-\tSection 3.2.2.3 step 7: uses `len(pt)`, but I\u2019m not sure what `pt` is supposed to be/refer to. Perhaps `secret_creds`?\r\n-\tSection 3.2.2.3 step 11: \u201cCreate InnerEnvelope contents\u201d. I read this as \u201cCreate [an unnamed] InnerEnvelope body\u2026.\u201d, but you apparently intended to name the struct `contents`, since you then refer to it in step 12. If you gave this a non-English-word name, this would be clearer, since there are no typesetting clues.\r\n-\tIs it really necessary to define a variant of `CleartextCredentials`? Why not always use the larger struct? This is only included as AAD; it is not actually transmitted or stored. It\u2019s adding a lot of extra complexity with no apparent benefit. Implementations can always used a short fixed value if they would otherwise want to use the truncated `CleartextCredentials`.\r\n-\tThe type of OPRF group elements isn\u2019t consistent: in section 3.2.1, it\u2019s an (undefined!) type `SerializedElement data`; in section 3.3.1, it\u2019s `opaque data<1..2^16-1>`\r\n-\tSection 3.3.2.3: The \u201cOutputs\u201d list a `SecretCredentials` and an export key, but the diagram shows that RecoverCredentials outputs (skU, pkS, export_key)\r\n-\tSuggestion: incorporate generic AKE messages into the protocol in section 3.3. It would be nice to have a complete diagram of the generic protocol. Currently, you have a partial diagram in section 3.3 and a textual description of the full protocol in the intro of section 4.\r\n-\tSection 4 intro: \u201cHowever, an instantiation where both AKE and data encryption are quantum safe\u2026\u201d Is this encryption referring to the EnvU encryption defined in section 3.2.2.3? If so, isn\u2019t the encryption already quantum safe? If that\u2019s the case, I\u2019d change this to \u201cHowever, an instantiation where AKE is quantum safe\u2026\u201d to avoid confusion.\r\n-\tSection 4.1: struct `HkdfLabel` contains the field opaque label<8..255> = \"OPAQUE \" + Label; Is `Label` required to be non-null, or is the string required to be null-terminated? The string \u201cOPAQUE \u201c has length 7, so I\u2019m wondering why the minimum field size is 8. (I see that this is consistent with TLS1.3, but I don\u2019t see an explanation there either.)\r\n-\tSection 4.2.1: This section defines, e.g., ` KE1 = credential_request, nonceU, info1*, epkU`, so that KE1 contains the credential_request. However, at the top of section 4, the high-level protocol shows credential_request being sent in addition to KE1. This is another reason it would be helpful to have a complete diagram of the generic protocol (with, e.g., a generic 3-message AKE). For this particular issue, I think KE1 should only include AKE message components; it should not include the credential_request. Similarly for KE2 and section 4.3.1.\r\n-\tSection 5: \u201cFuture specifications \u2026 MAY introduce other AKE instantiations.\u201d Also allow for/mention the possibility of defining alternate OPRFs. For example, https://eprint.iacr.org/2020/1532 gives a lattice-based (and hence PQ) OPRF.\r\n-\tSection 6.6: What does \u201cskipping the key exchange part\u201d mean? Does it mean somehow truncating the protocol/skipping the AKE entirely? Or does it mean not using the exchanged key after a successful authentication? In general, I\u2019m not sure what I would have to do to violate this section, which means I could easily violate it without knowing.\r\n",
      "createdAt": "2021-01-11T22:58:23Z",
      "updatedAt": "2021-02-06T00:00:17Z",
      "closedAt": "2021-02-06T00:00:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @crockeea, for the detailed review! I reviewed the comments and turned those applicable into action items below. (Some are already addressed, so I omitted those.) I responded to specific comments below that list. Please let me know if I misunderstood any of your feedback.\r\n\r\nTasks:\r\n- [x] Add pwdU to section 1.2 (notation)\r\n- [x] The type of mode in the InnerEnvelope struct should be EnvelopeMode\r\n- [x] Section 3.1: Clarify that not all credentials are embedded in the envelope\r\n- [x] Be consistent about the use of parens for functions which output multiple values (see protocol diagrams at top of section 3.2 and at the top of 3.3)\r\n- [x] Clarify kU ownership\r\n- [x] Section 3.2.2.3 step 7: s/len(pt)/len(secret_creds)\r\n- [x] Section 3.2.2.3 step 11: Rename InnerEnvelope from \"contents\" to something less confusing, perhaps \"inner_envelope\"?\r\n- [ ] Update Section 4 OPRF+AKE text description with a diagram like that in the registration and authentication steps.\r\n- [x] Clarify HkdfLabel \"Label\" properties (Is Label required to be non-null, or is the string required to be null-terminated?)\r\n- [x] Section 5: Allow future OPRFs to be chosen, possibly citing PQ OPRFs (https://eprint.iacr.org/2020/1532).\r\n\r\nComments:\r\n\r\n> Add OPRF KeyGen() to section 2 (referenced in section 3.2.2.2)\r\n\r\nThis is already in Section 2, where we say, \"We also assume the existence of a function KeyGen from [I-D.irtf-cfrg-voprf], which generates an OPRF private and public key.\"\r\n\r\n> Section 3.1: The text above the definition of the Envelope and InnerEnvelope structs says, \u201cThese credentials are embedded into the following structure\u2026\u201d. I therefore expected to see a SecretCredentials struct and CleartextCredentials struct in either Envelope or InnerEnvelope. There is a field for \u201cencrypted_creds\u201d, which could correspond to the encryption of the SecretCredentials, but there still seems to be no place where CleartextCredentials can be embedded into these structs.\r\n\r\nGood point! Only the secret credentials are actually included in the envelope. The cleartext credentials are omitted but ultimately folded into the MAC check. We can clarify the text to make this more clear.\r\n\r\n> Notation for kU: section 1.2 says \u201ckU refers to U's private OPRF key\u201d. Without any other context, I expect this to be something generated by the user, and known only to the user. But in reality, kU is a per-user key generated by the server, and not revealed to the client. Is there a different way to describe kU to avoid this potential confusion?\r\n\r\nGreat point. We can probably say something along the lines of, \"kU is a unique OPRF key for user U known only to the server.\"\r\n\r\n> Need to define the Credentials structure mentioned at the end of section 3.1: fields of this struct are referenced in section 3.2.2.3, but never defined.\r\n\r\nCredentials is meant to be an implementation-specific construct with fields listed in its description. We chose to not define this structure using standard notation since it's irrelevant for the description protocol. All that matters is that the core protocol can access the name fields from a Credentials object. (We do [something similar for HPKE] when generating encryption contexts.)\r\n\r\n> Is it really necessary to define a variant of CleartextCredentials? Why not always use the larger struct? This is only included as AAD; it is not actually transmitted or stored. It\u2019s adding a lot of extra complexity with no apparent benefit. Implementations can always used a short fixed value if they would otherwise want to use the truncated CleartextCredentials.\r\n\r\nHmm, I'm not sure I understand this comment. @crockeea, would you mind elaborating?\r\n\r\n> Suggestion: incorporate generic AKE messages into the protocol in section 3.3. It would be nice to have a complete diagram of the generic protocol. Currently, you have a partial diagram in section 3.3 and a textual description of the full protocol in the intro of section 4.\r\n\r\nI think it's more readable if the core protocol description is unencumbered by the AKE steps. How about a compromise: replace the textual description in Section 4 with a graphical description similar to that in Section 3?\r\n\r\n> Section 4 intro: \u201cHowever, an instantiation where both AKE and data encryption are quantum safe\u2026\u201d Is this encryption referring to the EnvU encryption defined in section 3.2.2.3? If so, isn\u2019t the encryption already quantum safe? If that\u2019s the case, I\u2019d change this to \u201cHowever, an instantiation where AKE is quantum safe\u2026\u201d to avoid confusion.\r\n\r\nI think this is referring to the encryption of data sent during and after the AKE, though I'm now not certain :) @hugokraw, can you double check this paragraph?\r\n\r\n> Section 4.1: struct HkdfLabel contains the field opaque label<8..255> = \"OPAQUE \" + Label; Is Label required to be non-null, or is the string required to be null-terminated? The string \u201cOPAQUE \u201c has length 7, so I\u2019m wondering why the minimum field size is 8. (I see that this is consistent with TLS1.3, but I don\u2019t see an explanation there either.)\r\n\r\nHmm, good question. I don't recall off hand. I filed [this issue](https://github.com/tlswg/tls13-spec/issues/1207) against the TLS 1.3 update to track this question.\r\n\r\n> Section 4.2.1: This section defines, e.g., KE1 = credential_request, nonceU, info1*, epkU, so that KE1 contains the credential_request. However, at the top of section 4, the high-level protocol shows credential_request being sent in addition to KE1. This is another reason it would be helpful to have a complete diagram of the generic protocol (with, e.g., a generic 3-message AKE). For this particular issue, I think KE1 should only include AKE message components; it should not include the credential_request. Similarly for KE2 and section 4.3.1.\r\n\r\nThis is an interesting point. Mixing them together was done to highlight that the OPAQUE messages MUST be included in the AKE transcript. I'll see if we can show this requirement differently without losing readability.\r\n\r\n> Section 6.6: What does \u201cskipping the key exchange part\u201d mean? Does it mean somehow truncating the protocol/skipping the AKE entirely? Or does it mean not using the exchanged key after a successful authentication? In general, I\u2019m not sure what I would have to do to violate this section, which means I could easily violate it without knowing.\r\n\r\nIt means, for example, just running the OPRF flow and then doing nothing with the recovered credentials. Do you think it would be useful or valuable to be more specific here?",
          "createdAt": "2021-01-14T22:40:14Z",
          "updatedAt": "2021-01-26T03:00:06Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "- For the OPRF `KeyGen`, my confusion stemmed from looking in the OPRF API list and not finding `KeyGen` there. I propose adding the following to the OPRF API list:\r\n   ```\r\n   KeyGen(): Generates an OPRF private and public key. OPAQUE only requires an OPRF private key. We write (kU, _) = KeyGen() to denote use of this function for generating secret key kU (and discarding the corresponding public key).\r\n   ```\r\n   and removing the corresponding text from the paragraph below the list.\r\n- For `Credentials`: I'm not very familiar with standard practices here, but should we perhaps point out that this struct is implementation-specific? Otherwise it just looks like it's missing/an error.\r\n- \"variant of CleartextCredentials\": Section 3.1 contains two definitions of the `CleartextCredentials` struct, and `EnvelopeMode` is an enum that indicates which struct type is contained in the envelope (as I write this it strikes me that this is really not right: `CleartextCredentials` are not part of the envelope (at least not the `Envelope` struct)!). Can we get away with using a single `CleartextCredentials` struct? This eliminates the need for the `EnvelopeMode` enum, which results in a simpler and easier-to-understand protocol. I'm not seeing what benefit we get from defining two different `CleartextCredentials` structs with an enum to switch between them.\r\n- On a related note: section 3.1 also defines `SecretCredentials` twice, but there are no differences between the two definitions. If you do end up keeping two structs for `CleartextCredentials` for some reason, then section 3.1 should define `SecretCredentials` only once. and view `EnvelopeMode` as switching between the two definitions of `CleartextCredentials`. (The current approach is to use the `EnvelopeMode` to switch between alternate definitions of both `*Credentials` types.)\r\n- \"Core Protocol diagram\": To me, the \"core\" protocol is the combination of the OPRF and the AKE, and section 3 purports to describe the \"Core Protocol\". However, if you're proposing replacing the textual description with a diagram similar to section 3.3 augmented with the AKE messages, I'd be okay with that. As long as the complete (generic) diagram is somewhere.\r\n- @hugokraw Regarding the paragraph about quantum safety: \"OPAQUE may be instantiated....[h]owever, an instantiation where both AKE and data encryption are quantum safe, but the OPRF is not, would still ensure...\" I read that as \"an instantiation [of OPAQUE]\", and when I think about the security of \"OPAQUE\", I think about the authentication/key exchange protocol itself, _not_ what happens after that (which seems to me to be beyond the scope of this specification). We should be clear which encryption scheme this is referring to.\r\n- \u201cskipping the key exchange part\u201d: Yes, it would be valuable to be more specific here. I see two possible interpretations of the current paragraph. It either addresses a situation where\r\n   - someone executes OPAQUE (by which I mean the OPRF+AKE), gets the key, and then throws the key away\r\n   - someone executes only an OPRF (or perhaps what you currently refer to as the \"core protocol\") without any sort of key exchange\r\n\r\nI think most of my confusion on several of these points arises because the document appears to define the \"core protocol\" as just the OPRF portion. I'm not sure why, since, as you point out, the AKE is _required_ for security. As written, the AKE comes off as a \"second-class citizen\". By including the AKE as part of the \"core protocol\", we make it clear that the AKE is a required part of OPAQUE. There is no longer the possibility of \"skipping the key exchange\", because it would be clear that a protocol that does an OPRF without an AKE is _not_ OPAQUE.\r\n\r\nWe should also more clearly define the scope of the specification. It refers only to the key exchange and authentication, and not to anything outside that (i.e., usage of OPAQUE in a larger protocol). This would, for example, clear up any confusion about which encryption scheme is referred to in the post-quantum security paragraph: it could only refer to the encryption scheme in the OPAQUE protocol itself.",
          "createdAt": "2021-01-15T00:56:38Z",
          "updatedAt": "2021-01-15T00:56:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Regarding the paragraph about quantum safety: \"OPAQUE may be instantiated....[h]owever, an instantiation where both AKE and data encryption are quantum safe, but the OPRF is not, would still ensure...\" I read that as \"an instantiation [of OPAQUE]\", and when I think about the security of \"OPAQUE\", I think about the authentication/key exchange protocol itself, not what happens after that (which seems to me to be beyond the scope of this specification). We should be clear which encryption scheme this is referring to.\r\n\r\nI suggest moving this text to the security considerations as subsection titled \"Quantum-safe instantiation\" with the following edited text:\r\n\r\nOPAQUE may be instantiated with any post-quantum (PQ) AKE protocol with the security properties (KCI resistance and forward secrecy) outlined in {{security-considerations}}. To obtain a quantum-safe OPAQUE instantiation, also the OPRF needs to be quantum safe. Recent progress towards defining such OPRF can be found in [cite https://eprint.iacr.org/2020/1532]. We do stress that an OPAQUE instantiation where the AKE protocol is quantum-safe but the OPRF is not, would still ensure data security against future quantum attacks since breaking the OPRF does not retroactively affect the security of data transferred over a quantum-safe secure channel.\r\n\r\n@crockeea @chris-wood Is that better? \"quantum-safe secure channel.\" is short for \"data transferred under a  quantum-safe encryption scheme with a key derived from a quantum-safe AKE\". You may want to be more explicit.\r\n",
          "createdAt": "2021-01-15T23:13:41Z",
          "updatedAt": "2021-01-15T23:13:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Section 6.6: What does \u201cskipping the key exchange part\u201d mean? Does it mean somehow truncating the protocol/skipping the AKE entirely? Or does it mean not using the exchanged key after a successful authentication? In general, I\u2019m not sure what I would have to do to violate this section, which means I could easily violate it without knowing.\r\n\r\nI suggest the following replacement text for that section:\r\n\r\nOPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While for user identification focus is often on the authentication part, we stress that the key exchange element is essential for data protection.  Authenticating the user but not protecting the data in the ensuing session is analogous to carefully checking a visitor's \r\n credential at the door and then leaving the door open for others to enter freely.\r\n\r\n@crockeea @chris-wood Is this better? I am ok with removing this remark all together. I heard this question a couple of times (why we need key exchange) so I wanted to make this point. But if it is confusing we can do without it.",
          "createdAt": "2021-01-15T23:19:36Z",
          "updatedAt": "2021-01-15T23:19:36Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "From @crockeea \r\n> I think most of my confusion on several of these points arises because the document appears to define the \"core protocol\" as just the OPRF portion. I'm not sure why, since, as you point out, the AKE is required for security. As written, the AKE comes off as a \"second-class citizen\". By including the AKE as part of the \"core protocol\", we make it clear that the AKE is a required part of OPAQUE. \r\n\r\n@chris-wood @kevinlewi We must make sure that readers understand that there is no OPAQUE without AKE. So @crockeea suggestions in this regard are *very* important.",
          "createdAt": "2021-01-15T23:23:14Z",
          "updatedAt": "2021-01-15T23:23:14Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\nAs an observer, I felt that the AKE part has been put aside, indeed. But I interpreted it as \"we first need to thoroughly define secret credential recovery, and then we'll do the AKE parts\".\r\n\r\nAs a reader and implementer, I have a lot of questions relative to the part post-secret-retrieval, as the draft doesn't go much into details, yet.",
          "createdAt": "2021-01-19T16:50:37Z",
          "updatedAt": "2021-01-19T16:50:37Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "> OPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While for user identification focus is often on the authentication part, we stress that the key exchange element is essential for data protection. Authenticating the user but not protecting the data in the ensuing session is analogous to carefully checking a visitor's\r\ncredential at the door and then leaving the door open for others to enter freely.\r\n\r\nI'm still confused by this one. I think we need to be more clear about the model to which you are referring. In particular, what does \"data protection\"/\"protecting the data\" refer to? It sounds like protection of data in a larger protocol, but that's not explicit, and it should be.",
          "createdAt": "2021-01-19T19:15:05Z",
          "updatedAt": "2021-01-19T19:15:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I was referring to the fact that most of the time the exchange between server and client does not stop at the success/failure of the user authentication but it is followed by some activity between client and server which typically carries some data. The KE part of PAKE is needed to derive a key that will protect such data. Given that this comment seems to generate more confusion than good, I propose removing it all together. ",
          "createdAt": "2021-01-19T21:10:30Z",
          "updatedAt": "2021-01-19T21:10:30Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Data protection\" may indeed be interpreted as regulatory compliance to \"Data Protection\" (e.g. GDPR and such).\r\n\r\nMaybe replace this with\r\n\r\n> OPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While for user identification focus is often on the authentication part, we stress that the key exchange element is essential for providing means to encrypt subsequent the communication session. Authenticating the user but not providing confidentiality and integrity for the data in the ensuing session is analogous to carefully checking a visitor's credential at the door and then leaving the door open for others to enter freely.",
          "createdAt": "2021-01-20T14:58:09Z",
          "updatedAt": "2021-01-20T14:58:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this text. If others are happy with it, let's keep it. If it is still (potentially) confusing, I am ok with removing it all together.",
          "createdAt": "2021-01-20T15:02:05Z",
          "updatedAt": "2021-01-20T15:02:05Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "I'd like to keep something in the draft along these lines, but I am still confused. Specifically:\r\n> we stress that the key exchange element is essential for providing means to encrypt subsequent the communication session.\r\n\r\nDoes this mean I have to protect subsequent data _with the OPAQUE key_, or is it just pointing out that confidentiality and integrity are important cryptographic properties? Could I obtain confidentiality and integrity with an independent key? For example, what if I did OPAQUE inside a TLS channel (not as part of the handshake)? Is this comment saying that I (still) _must_ use the OPAQUE key to protect data inside the TLS channel to obtain any guarantees about authentication?",
          "createdAt": "2021-01-20T22:12:25Z",
          "updatedAt": "2021-01-21T02:17:08Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I see what you mean. Another aspect of this has been discussed [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/109#issuecomment-757061307).\n\nHow about this\n\n> OPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While user identification often focuses on the authentication part, we stress that the key exchange element is essential for providing a shared secret. This shared secret is suitable for different use cases, e.g. session tokens or means to encrypt the subsequent communication session. Authenticating the user but not providing confidentiality and integrity for the data in the ensuing session is analogous to carefully checking a visitor's credential at the door and then leaving the door open for others to enter freely.\n\n(Another paragraph would need to explain how to derive different keys for different usaged using HKDF-Expand.)",
          "createdAt": "2021-01-21T00:43:59Z",
          "updatedAt": "2021-01-21T01:20:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Does this mean I have to protect subsequent data _with the OPAQUE key_, or is it just pointing out that confidentiality and integrity are important cryptographic properties? Could I obtain confidentiality and integrity with an independent key? For example, what if I did OPAQUE inside a TLS channel (not as part of the handshake)? Is this comment saying that I (still) _must_ use the OPAQUE key to protect data inside the TLS channel to obtain any guarantees about authentication?\r\n\r\nThis comment fully convinces me to drop this text. Eric is right about the possibility of running OPAQUE inside TLS without the need to generate a data-protection key by OPAQUE. Indeed, that is *exactly* how we plan to integrate OPAQUE with TLS. In this case, OPAQUE will serve as a \"post-handshake authentication\" of the TLS handshake without requiring to change the traffic keys established by the TLS handshake. It shows that in some cases it does make sense to run OPAQUE without deriving a data-protection key and therefore the text in question is, as Eric insisted, confusing.",
          "createdAt": "2021-01-21T06:21:39Z",
          "updatedAt": "2021-01-21T06:21:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@crockeea do you think a diagram in the authentication section is still needed? If not, I'll close this issue, since the remaining tasks were addressed.",
          "createdAt": "2021-02-04T17:48:47Z",
          "updatedAt": "2021-02-04T17:48:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this as resolved for now. @crockeea, if you think we still need to address points raised in this issue, can you please file separate issues for them? Thanks!",
          "createdAt": "2021-02-06T00:00:17Z",
          "updatedAt": "2021-02-06T00:00:17Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU3OTA2MjA0MTM=",
      "title": "I'd like to keep something in the draft along these lines, but I am still confused. Specifically, med to be, or does the",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/118",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'd like to keep something in the draft along these lines, but I am still confused. Specifically, about\r\n> we stress that the key exchange element is essential for providing means to encrypt subsequent the communication session.\r\n\r\nDoes this mean I have to protect subsequent data _with the OPAQUE key_, or is it just pointing out that confidentiality and integrity are important cryptographic properties? Could I obtain confidentiality and integrity with an independent key? For example, what if I did OPAQUE inside a TLS channel (not as part of the handshake)? Is this comment saying that I (still) _must_ use the OPAQUE key to protect data inside the TLS channel to obtain any guarantees about authentication?\r\n\r\n_Originally posted by @crockeea in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112#issuecomment-763983736_",
      "createdAt": "2021-01-21T02:14:26Z",
      "updatedAt": "2021-01-21T02:14:58Z",
      "closedAt": "2021-01-21T02:14:58Z",
      "comments": []
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU3OTEzNDUwNDQ=",
      "title": "Test vectors and naming",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/119",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'd like to reach an agreement on the names of variables we use for OPAQUE, which also impact the parameters to each of the test vectors we release. Here is what I have so far (open to feedback!):\r\n\r\nInputs:\r\n\r\n```\r\n    pk_u: Client's static public key\r\n    sk_u: Client's static private key\r\n    epk_u: Client's ephemeral public key\r\n    esk_u: Client's ephemeral private key\r\n    pk_s: Server's static public key\r\n    sk_s: Server's static private key\r\n    epk_s: Server's ephemeral public key\r\n    esk_s: Server's ephemeral private key\r\n    password: Client's password\r\n    id_u: idU\r\n    id_s: idS\r\n    blind_registration: Scalar used to blind client's password during registration\r\n    blind_login: Scalar used to blind client's password during login\r\n    oprf_key: kU, the server's secret key for the OPRF\r\n    envelope_nonce: nonce used for envelope\r\n    client_nonce: nonce from client used in AKE\r\n    server_nonce: nonce from server used in AKE\r\n    info1: Plaintext info field populated by client in first AKE message\r\n    info2: Encrypted info field populated by server in second AKE message\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\n    registration_request: First message of registration\r\n    registration_response: Second message of registration\r\n    registration_upload: Third message of registration\r\n    credential_request: First message of login\r\n    credential_response: Second message of login\r\n    credential_finalization: Third message of login\r\n    credential_file: The object stored by the server after registration has completed\r\n    export_key: The export_key parameter output by registration and login's final step on the client\r\n    session_key: The output of the client and server after the AKE\r\n```\r\n\r\nThere is also an opportunity to publish \"intermediate values\" here, such as the envelope bytes, the \"rwdU\" value, etc. They are not included here at the moment, but we could add additional values to represent them as well, if desired.",
      "createdAt": "2021-01-21T17:16:39Z",
      "updatedAt": "2021-02-11T15:03:30Z",
      "closedAt": "2021-02-03T00:32:02Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Awesome! I like this set of input values, they are indeed the minimum core values necessary to run the engine.\r\n\r\nRegarding naming, we could maybe shorten some of the obvious names?\r\n\r\n- `client_identifier` -> `client_id ` or even `idu`\r\n- `server_identifier` -> `server_id` or even `ids`\r\n- `blinding_factor_registration` -> `blind_registration`\r\n- `blinding_factor_login` -> `blind_login` or `blind_auth`\r\n\r\nThis set of inputs does not cover the parameters necessary for the test. I understand that all decisions regarding these have not been taken, yet. But some are still necessary to test, even just a first set. These are the ones I use;\r\n\r\nParameters:\r\n\r\n```\r\noprf_suite_id : The OPRF ciphersuite identifier used\r\nenvelope_hash_alg : The name of the hash algorithm used for the keying in the envelope stage\r\nmhf_alg : The name of the memory hard function used for rwdu\r\nmhf_parameters : A vector of parameters proper to the MHF algorithm to be used\r\nenvelope_mode : The envelope mode\r\nake_id : The AKE identifier/name\r\nake_group: The group which the DH will be operated in\r\nake_hash_alg : The name of the hash algorithm to be used in the AKE\r\n(If applicable - for Sigma)\r\nsigma_sig_alg : The name of the signature algorithm to be used (indicates also the nature of sku/pku)\r\n```\r\n\r\n( I tried different configurations for \"exploratory full tests\" (with different akes and other parameters) [here](https://github.com/bytemare/opaque/blob/main/vectors_test.go), but they need to be stripped down)",
          "createdAt": "2021-01-21T21:28:55Z",
          "updatedAt": "2021-01-21T21:28:55Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Also `password_file `-> `credential_file` to stay consistent with https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/7539e8665bae01e8c96f79b8f378f56dcbb8bab7/draft-irtf-cfrg-opaque.md#L666",
          "createdAt": "2021-01-21T21:56:03Z",
          "updatedAt": "2021-01-21T21:56:03Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "why these long ids? why not use the ids exactly as they are in the draft? so `client_s_pk` would be `pkU`",
          "createdAt": "2021-01-22T22:38:18Z",
          "updatedAt": "2021-01-22T22:38:18Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, I don't see a specific need to the lengthy human friendly naming",
          "createdAt": "2021-01-24T00:10:50Z",
          "updatedAt": "2021-01-24T00:10:50Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "- `client_s_sk/pk` -> `sku/pku`\n- `cliient_e_sk/pk` -> `esku/epku`\n- `server_s_sk/pk` -> `sks/pks`\n- `server_e_sk/pk` -> `esks/epks`",
          "createdAt": "2021-01-24T00:17:04Z",
          "updatedAt": "2021-01-24T00:17:04Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback @stef and @bytemare! I am not super tied to any of the original names I originally proposed, and am supportive of all of the changes mentioned. Will leave it up to @chris-wood to also chime in with his opinion!",
          "createdAt": "2021-01-25T06:17:21Z",
          "updatedAt": "2021-01-25T06:17:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I only care that the names are consistent across the spec and test vectors :-) to that end, if folks are generally okay with what's in the draft (pkU versus client_s_pk, for example), then my preference would be to stick with them.",
          "createdAt": "2021-01-25T16:00:46Z",
          "updatedAt": "2021-01-25T16:00:46Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 for consistency. What that might be in the end is less important, as long as one understands when reading the document and looks at the vectors.",
          "createdAt": "2021-01-26T00:02:03Z",
          "updatedAt": "2021-01-26T00:02:03Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef + @bytemare : I edited the original text to incorporate your suggestions. I decided to still use lowercase with underscores (pk_u instead of pkU, epk_u instead of epkU) for consistency. I also changed:\r\n- \"client_identifier\" -> \"id_u\" and \"server_identifier\" -> \"id_s\",\r\n- \"blinding_factor_registration\" -> \"blind_registration\" and \"blinding_factor_login\" -> \"blind_login\"\r\n- \"password_file\" -> \"credential_file\",\r\n- \"shared_secret\" -> \"session_key\"\r\n\r\nPlease let me know if you disagree with the lowercase styling, or if you have any other general feedback. Thank you again for your inputs!!",
          "createdAt": "2021-01-27T01:10:36Z",
          "updatedAt": "2021-01-27T01:10:36Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me \ud83d\ude42",
          "createdAt": "2021-01-27T09:09:50Z",
          "updatedAt": "2021-01-27T09:09:50Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i don't see the reason why not use exactly the same identifiers as in the spec, but i guess it's good enough.",
          "createdAt": "2021-01-27T22:38:07Z",
          "updatedAt": "2021-01-27T22:38:07Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Some proposed changes from @chris-wood:\r\n- Remove the `credential_file` parameter entirely from the outputs.\r\n- Follow the rest of the draft with variable names and abandon things like `pk_u` in favor of `pkU`, `registration_request` -> `RegistrationRequest`, `oprf_key` -> `kU`\r\n\r\nLet me know if there are any other suggestions, and I'll be happy to edit the top-level post \r\n",
          "createdAt": "2021-02-02T20:47:04Z",
          "updatedAt": "2021-02-02T20:47:04Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks a lot!",
          "createdAt": "2021-02-03T21:56:16Z",
          "updatedAt": "2021-02-03T21:56:16Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'm a bit confused, why is this issue closed? looking at \r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#opaque-3dh-test-vector-1\r\nand at https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/vectors/vectors.json i see a lot of parameters which i have no clue what they correspond to in the specification.",
          "createdAt": "2021-02-11T14:38:23Z",
          "updatedAt": "2021-02-11T14:38:23Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "huh. sorry, i see that the 3dh part does name some of these values as in the testvectors. will check the consistency of those.",
          "createdAt": "2021-02-11T15:03:30Z",
          "updatedAt": "2021-02-11T15:03:30Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWU3OTE1MDgwMzE=",
      "title": "Simplifying envelope construction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/120",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here are a subset of the steps for envelope construction:\r\n\r\n```\r\n1. N = Unblind(blind, response.data)\r\n2. y = Finalize(pwdU, N, \"OPAQUE01\")\r\n3. rwdU = HKDF-Extract(\"rwdU\", Harden(y, params))\r\n4. Create SecretCredentials secret_creds with creds.skU\r\n5. Create CleartextCredentials cleartext_creds with response.pkS\r\n   and custom identifiers creds.idU and creds.idS if mode is customIdentifier\r\n6. nonce = random(32)\r\n7. pseudorandom_pad = HKDF-Expand(rwdU, concat(nonce, \"Pad\"), len(pt))\r\n8. auth_key = HKDF-Expand(rwdU, concat(nonce, \"AuthKey\"), Nh)\r\n9. export_key = HKDF-Expand(rwdU, concat(nonce, \"ExportKey\"), Nh)\r\n...\r\n```\r\n\r\nCan we instead change this to:\r\n```\r\n3. nonce = random(32)\r\n4. rwdU = HKDF-Extract(nonce, Harden(y, params))\r\n5. Create SecretCredentials secret_creds with creds.skU\r\n6. Create CleartextCredentials cleartext_creds with response.pkS\r\n   and custom identifiers creds.idU and creds.idS if mode is customIdentifier\r\n7. pseudorandom_pad = HKDF-Expand(rwdU, \"Pad\", len(pt))\r\n8. auth_key = HKDF-Expand(rwdU, \"AuthKey\", Nh)\r\n9. export_key = HKDF-Expand(rwdU, \"ExportKey\", Nh)\r\n```\r\n?\r\n\r\nAdditionally, we could consider bundling up steps 7-9 into a single HKDF-Expand call, and taking slices of that output for each of the individual variables.",
      "createdAt": "2021-01-21T21:30:46Z",
      "updatedAt": "2021-02-02T19:52:20Z",
      "closedAt": "2021-02-01T14:31:15Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Replacing the static salt with the nonce, does is change any security property except added entropy ?",
          "createdAt": "2021-01-21T23:19:18Z",
          "updatedAt": "2021-01-21T23:19:18Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we are actually moving the incorporation of the nonce from steps 7-9 into step 3, so I don't think this is actually adding entropy. The only thing it accomplishes is removing the need for the static salt \"rwdU\".",
          "createdAt": "2021-01-22T02:58:17Z",
          "updatedAt": "2021-01-22T02:58:17Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "If I'm not mistaken, until now rwdu was not derived from the nonce. What I mean is that the nonce has more entropy than the string \"rwdu\" :)",
          "createdAt": "2021-01-22T08:55:20Z",
          "updatedAt": "2021-01-22T08:55:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "It is true that the rwdU will have more entropy now, but the only uses of `rwdU` in the current protocol are to be used to derive `pseudorandom_pad`, `auth_key`, and `export_key`, all of which incorporate the nonce into the HKDF. That's all I meant by saying that the overall entropy is the same.",
          "createdAt": "2021-01-22T18:07:27Z",
          "updatedAt": "2021-01-22T18:07:27Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Would it therefore be necessary to keep using the nonce in these HKDF derivations ? \nThe harden function could output something the length of rwdu + nonce, and that would be fed into the HKDF expansions.",
          "createdAt": "2021-01-23T23:42:56Z",
          "updatedAt": "2021-01-23T23:42:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "what would be the benefit of\r\n\r\n> Additionally, we could consider bundling up steps 7-9 into a single HKDF-Expand call, and taking slices of that output for each of the individual variables.\r\n?",
          "createdAt": "2021-01-24T20:04:05Z",
          "updatedAt": "2021-01-24T20:04:05Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "and what is the benefit of having the nonce included earlier in this procedure?",
          "createdAt": "2021-01-24T20:04:35Z",
          "updatedAt": "2021-01-24T20:04:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare I think there is a security benefit to having the nonce being chosen independently of the output of the harden function, actually. It means that if a (kU, pwdU) pair were reused for multiple users, we would still get independent export keys / auth keys / pseudorandom_pads.\r\n\r\n@stef: The only benefit is that we remove the need for a fixed string \"rwdU\" from this computation, and slightly simplify steps 7/8/9 to not involve concatenation of any strings.\r\n\r\nThis should not have any impact on anything except for simplicity.\r\n\r\nBumping this for @chris-wood / @hugokraw for comments",
          "createdAt": "2021-01-27T01:04:05Z",
          "updatedAt": "2021-01-27T01:04:05Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "simplification, and not concatenating strings is a very good reason to do this. thumbsup!",
          "createdAt": "2021-01-27T01:07:02Z",
          "updatedAt": "2021-01-27T01:07:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this suggestion a lot, with one exception: I'd prefer we keep the expand calls separate. There were, in the past, issues where the attacker played with the expand parameters to try and recover the secrets. Keeping them separate helps not reintroduce that issue.",
          "createdAt": "2021-01-30T15:25:06Z",
          "updatedAt": "2021-01-30T15:25:06Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi I understood this :) what I meant is to not keep using the nonce in HKDF-Expand.\r\nLike so https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/126/commits/00810795fa60f5a5e77cee205d1e698d3b533077#diff-09a16f0dd79bfde63faf766f3c58ba43f6795026ce020fa36006cfec7094cf0aR642",
          "createdAt": "2021-01-31T21:45:31Z",
          "updatedAt": "2021-01-31T21:45:31Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "General  comment: I appreciate that you guys add @hugokraw when discussing stuff that needs my attention. But since my attention these days is divided into so many things, please double check with me before approving any such crypto-relevant changes if I do not provide feedback.\r\n\r\nRegarding involving the nonce into the derivation of RwdU: I am ok with it. The reason Nonce was used in the derivation of pad is for the (not too common but possible case) that someone would re-register same PwdU (and without the server changing kU), but would change the registered skU. If this happened, one would be using the same pad to encrypt two different plaintexts.  But the proposed change is correct: Once you use the nonce to modify the RwdU derivation there is no need to include the nonce in the derivation of pseudorandom_pad as long as Nonce is chosen anew each time a password is registered (or re-registered). \r\n\r\nLastly, there was a comment in this thread about the nonce helping in the case of different users using the same password and same kU by the server. A server should  never use the same kU with two different users. We may want to add such remark in the security considerations and also around the place where we specify the choice of kU.  \r\n",
          "createdAt": "2021-02-01T05:01:19Z",
          "updatedAt": "2021-02-01T05:01:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Lastly, there was a comment in this thread about the nonce helping in the case of different users using the same password and same kU by the server. A server should never use the same kU with two different users. We may want to add such remark in the security considerations and also around the place where we specify the choice of kU.\r\n\r\nGood idea -- I'll make a note of this and address it in a future change.",
          "createdAt": "2021-02-01T13:36:33Z",
          "updatedAt": "2021-02-01T13:36:33Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "> as long as Nonce is chosen anew each time a password is registered (or re-registered)\r\n\r\nThis should be specified as well. Servers must ensure that the client doesn't reuse nonces. In practice, this means the server must retain these nonce (or a fingerprint) and validate new ones on each (re)-registration.",
          "createdAt": "2021-02-02T15:31:05Z",
          "updatedAt": "2021-02-02T16:56:37Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be specified but enforcement does not need to go all the way as you suggest. As long as the server chooses random independent keys for different users, the nonce in the envelope is of limited consequences (you only need it for the case where the user re-registers, does not change the password but chooses a new secret keys skU and the server does not change the user's OPRF key; and even then the damage of repeating or omitting the nonce is not very significant)",
          "createdAt": "2021-02-02T19:52:19Z",
          "updatedAt": "2021-02-02T19:52:19Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWU3OTE2NjUxMjc=",
      "title": "Change all occurrences of variable-length public/private keys to be fixed length?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/121",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "In the current version of the draft, there are occurrences such as:\r\n\r\n```\r\nstruct {\r\n    SerializedElement data;\r\n    opaque pkS<1..2^16-1>;\r\n} RegistrationResponse;\r\n```\r\n\r\n```\r\nstruct {\r\n    opaque pkU<1..2^16-1>;\r\n    Envelope envU;\r\n} RegistrationUpload;\r\n```\r\n\r\nShould we change these to instead say:\r\n```\r\n    opaque pkS[LK];\r\n```\r\n\r\nwhere `LK` is a fixed constant dependent on the group representation?\r\n\r\n@chris-wood ",
      "createdAt": "2021-01-22T03:24:18Z",
      "updatedAt": "2021-02-17T21:51:35Z",
      "closedAt": "2021-02-17T21:51:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems fine, but I would say that `LK` is not a function of the *group*, but simply the fixed length of an AKE public key. @kevinlewi, could you please propose text?",
          "createdAt": "2021-02-05T23:56:36Z",
          "updatedAt": "2021-02-05T23:56:36Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "See my comment on #132 ",
          "createdAt": "2021-02-09T05:48:07Z",
          "updatedAt": "2021-02-09T05:48:07Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "MDU6SXNzdWU3OTIzNDYyNDM=",
      "title": "envelope structure is not unambigious",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/122",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#credential-types-and-envelope-construction-data-types\r\n\r\ndefines the envelope as:\r\n```\r\nstruct {\r\n  InnerEnvelopeMode mode;\r\n  opaque nonce[32];\r\n  opaque encrypted_creds<1..2^16-1>;\r\n} InnerEnvelope;\r\n\r\nstruct {\r\n  InnerEnvelope contents;\r\n  opaque auth_tag[Nh];\r\n} Envelope;\r\n```\r\n\r\nwhy is the type of `encrypted_creds` `opaque` and not `SecretCredentials` as already defined right before this?\r\nthat `encrypted_creds` is actually `SecretCredentials` is only mentioned in the following \"prosa\" text.\r\n\r\nand then says this:\r\n\r\n> auth_tag : Authentication tag protecting the contents of the envelope, covering InnerEnvelope and CleartextCredentials.\r\n\r\nwhy is this `CleartextCredentials` not explicitly specified in the envelope struct?\r\n",
      "createdAt": "2021-01-22T22:27:03Z",
      "updatedAt": "2021-01-23T01:36:30Z",
      "closedAt": "2021-01-23T01:36:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> why is the type of encrypted_creds opaque and not SecretCredentials as already defined right before this?\r\n\r\n`encrypted_creds` is the *encrypted* form of `SecretCredentials`\r\n\r\n> why is this CleartextCredentials not explicitly specified in the envelope struct?\r\n\r\nNo cleartext credentials are included in the envelope -- they're only authenticated during the protocol (by being included in the MAC computation). ",
          "createdAt": "2021-01-22T23:54:36Z",
          "updatedAt": "2021-01-22T23:54:36Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hmmm. that kind of makes sense, i guess i was mislead by the previous version and the context implied by that. ",
          "createdAt": "2021-01-23T01:36:29Z",
          "updatedAt": "2021-01-23T01:36:29Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU3OTI4ODAwNTY=",
      "title": "bunch of questions - after a full reading of the latest draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/124",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "> 2OSP and OS2IP: Convert a byte string to and from a non-negative integer as described in {{?RFC8017}}.\r\n\r\nlink to https://tools.ietf.org/html/rfc8017#section-4.1 and https://tools.ietf.org/html/rfc8017#section-4.2\r\n\r\nperhaps also note that this is also known as the htons/ntohs functions in POSIX - implementors might find this very helpful!\r\n\r\n------- \r\n\r\n> kX: An OPRF private key used in role X. For example, kU refers to U's private OPRF key.\r\n\r\nis there any other role besides kU?\r\n\r\n------- \r\n\r\n> random(n): Generate a random byte string of length n bytes.\r\n\r\nnote that this random string should be of cryptographic quality. although there is a note under all the definitions saying so, it's better to have it closer where it matters and less ignored.\r\n\r\n\r\n------- \r\n\r\nin #cryptographic-protocol-and-algorithm-dependencies-dependencies\r\n\r\nthe note that only the base variant of the OPRF is needed is also a bit far away from where the OPRF dependency is specified.\r\n\r\n------- \r\n\r\n> auth_tag : Authentication tag protecting the contents of the envelope, covering InnerEnvelope and CleartextCredentials\r\n\r\nthen it notes:\r\n> The full procedure for constructing Envelope and InnerEnvelope from SecretCredentials and CleartextCredentials is described in {{finalize-request}}.\r\n\r\nwhich is:\r\n\r\n> 12. auth_tag = HMAC(auth_key, concat(contents, cleartext_creds))\r\n\r\nit's all there but quite dispersed spatially, someone trying to implement this has to jump around in the doc, it's very hard to read this spec sequentially.\r\n\r\n------- \r\n\r\n> Credential information corresponding to the configuration-specific mode, along with the user public key pkU and private key skU, are stored in a Credentials object with the following named fields:\r\n> skU, pkU, idU, idS\r\n\r\nit is not necessary to specify for interoperability how an implementation stores these values. also for security i think it is better to handle skU seperatately from the other values - or maybe not, depending on the configuration, if any of the other values is also to be kept secret. a sensible implementation wants to actually protect the sensitive values differently from the public values. maybe by storing them in mprotected/sanitized-after-use storage, in secure elements, or something else.\r\n\r\ni do see how it is a shortcut to list all the necessary items from the creds struture as an input to finalizerequest though.\r\n\r\n> Clients MUST NOT use the same key pair (skU, pkU) for two different accounts.\r\n\r\nwhy is this, when the server can use the same keypair for different accounts? in the case when idU == pkU this is not even possible i guess.\r\n\r\n------\r\n\r\n> pkS : An encoded public key that will be used for the online authenticated key exchange stage.\r\n\r\nadd explicitly that this is the *servers* pubkey\r\n\r\nsimilarly be explicit also about this:\r\n\r\n> pkU : An encoded public key, corresponding to the private key skU.\r\n\r\n-------\r\n\r\n#credential-file\r\n\r\nwe agree these things need to be persisted, however i do not see how this helps interoperability or security specifying this struct. i propose to change the wording to something like:\r\n\r\nthe server needs to be able to reproduce the following values for the online phase.\r\n\r\nan implementation might choose to generate kU by doing a KDF on some global secret value in combination with idU for example, then this storage of kU can be skipped. again we should realize that kU is a sensitive value which needs protection (like sanitization, possibly also at-rest encryption, not being swapped to disk, stored in a secure element, etc) while envU is an encrypted blob that does not need these kind of protections. in case pkU == idU it might be possbile that envU is stored in a hashdictionary that is indexed by idU, and thus pkU does not need to be stored at all. lumping these values together and requiring them to be stored in this structure creates unnecessary limitations on implementations. while this specification might harm security, it does not really improve interoperability.\r\n\r\neither delete this section, or make this optional, and put it into an non-binding appendix.\r\n\r\nanother thing against this, is the usage of export-keys, in case an implementation chooses to encrypt data with an export-key but wants to stay stateless on the client, then the export-key encrypted data might also be stored on the server.\r\n",
      "createdAt": "2021-01-24T20:01:04Z",
      "updatedAt": "2021-02-13T17:56:42Z",
      "closedAt": "2021-02-13T17:56:42Z",
      "comments": []
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU3OTc5MjE0MDg=",
      "title": "HMQV and SIGMA to an Appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/128",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "I want the HMQV and SIGMA specification to appear in an appendix. It serves as illustration and guidance for these and other instantiations.  Note that there is text referring to these protocols (e.g., introduction) that needs to be updated.",
      "createdAt": "2021-02-01T03:41:32Z",
      "updatedAt": "2021-02-05T21:00:08Z",
      "closedAt": "2021-02-05T21:00:08Z",
      "comments": []
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWU3OTg0NDUxMjI=",
      "title": "Clarify OPRF mode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/129",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "OPAQUE only requires the OPRF \"base\" mode, which does not have evaluation verification.",
      "createdAt": "2021-02-01T15:14:46Z",
      "updatedAt": "2021-02-03T00:40:47Z",
      "closedAt": "2021-02-03T00:40:46Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't this already addressed here, at the top of the \"Configurations\" section:\r\n\r\n> An OPAQUE configuration is a tuple (OPRF, Hash, MHF, EnvelopeMode). The OPAQUE OPRF protocol is drawn from the \"base mode\" variant of {{I-D.irtf-cfrg-voprf}}",
          "createdAt": "2021-02-03T00:39:35Z",
          "updatedAt": "2021-02-03T00:39:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing after agreement offline with @chris-wood ",
          "createdAt": "2021-02-03T00:40:46Z",
          "updatedAt": "2021-02-03T00:40:46Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU3OTg0NTEyMTA=",
      "title": "Elaborate on export_key usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/130",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "Applications can use export_key in a variety of ways (after OPAQUE completes successfully). The draft should describe some of these in more detail, perhaps in an appendix to keep the main body of text slim.\r\n\r\ncc @rot256",
      "createdAt": "2021-02-01T15:21:00Z",
      "updatedAt": "2021-02-03T20:16:23Z",
      "closedAt": "2021-02-03T20:16:23Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is one sample text that we could add to the appendix:\r\n\r\n> The export key can be used (separately from the OPAQUE protocol) to provide confidentiality and integrity to other data which only the client should be able to process. For instance, if the server is expected to maintain any client-side secrets which require a password to access, then this export key can be used to encrypt these secrets so that they remain hidden from the server.\r\n\r\nThis only describes one application, but it is the main application that comes to mind for me.",
          "createdAt": "2021-02-02T00:49:34Z",
          "updatedAt": "2021-02-02T00:49:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi, could you please throw this up in a PR? I think the proposed text is just right.",
          "createdAt": "2021-02-02T01:10:27Z",
          "updatedAt": "2021-02-02T01:10:34Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWU3OTg0Njg1MjM=",
      "title": "Static DH oracle text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/131",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "We should ensure that we acknowledge this type of attack in theory, and describe how OPAQUE deals with it. In particular, since each OPRF key is per-user, which means that any reduction in security is per-user, which is unlikely to be a problem in practice.",
      "createdAt": "2021-02-01T15:39:48Z",
      "updatedAt": "2021-02-17T03:09:49Z",
      "closedAt": "2021-02-17T03:09:49Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There is text in the security considerations section about this but it contains an error: A later paper by Cheon shows that one does not need the exponential memory. Also, we need to provide a reference to Taylor Campbel's comprehensive note on this. It is also worth noting Loup Vaillant observation on communication time (with the OPRF server), lower bounded by speed of light, given that this attack is inherently sequential. Maybe you will summarize these things in the OPRF draft and then we only refer to the fact that in OPAQUE kU is per user so this (anyway infeasible) attack would be directed to enable a dictionary attack against a single user.",
          "createdAt": "2021-02-01T19:52:32Z",
          "updatedAt": "2021-02-01T19:52:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "After reviewing this again, I'm inclined to remove most of the text in this section and simply delegate it to the OPRF draft. Would the following work, @hugokraw?\r\n\r\n```\r\nWhile one can expect the practical security of the OPRF function\r\n(namely, the hardness of computing the function without knowing the\r\nkey) to be in the order of computing discrete logarithms or solving\r\nDiffie-Hellman, Brown and Gallant {{BG04}} and Cheon {{Cheon06}} show an\r\nattack that slightly improves on generic attacks. However, in this case of OPAQUE,\r\nthese attacks are not practical as the number of queries translates to an equal \r\nnumber of failed authentication attempts by a single client. Therefore, the amount\r\nof work required of an attacker scales linearly with the number of target clients.\r\n```",
          "createdAt": "2021-02-14T22:56:51Z",
          "updatedAt": "2021-02-14T22:56:51Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "A bit edited:\r\nWhile one can expect the practical security of the OPRF function (namely, the hardness of computing the function without knowing the key) to be in the order of computing discrete logarithms or solving Diffie-Hellman, Brown and Gallant {{BG04}} and Cheon {{Cheon06}} show an attack that slightly improves on generic attacks.  For typical curves, the attack requires an infeasible number of calls to the OPRF and/or results in insignificant security loss (see oprf-rfc). For OPAQUE, these attacks are particularly impractical as they translate into an infeasible number of failed authentication attempts directed at individual users. \r\n\r\n(Note: It is true that the attack scales linearly  with the number of target users, but writing it that way it feels like a feasible attack. After all scaling linearly in the number of users is not a terrible limitation of attacks. The point here is that even for a single user it is totally infeasible;  while\"just being linear\" may obscure that fact. )",
          "createdAt": "2021-02-15T05:09:59Z",
          "updatedAt": "2021-02-15T05:09:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Perfect! PR incoming.",
          "createdAt": "2021-02-15T13:59:22Z",
          "updatedAt": "2021-02-15T13:59:22Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU3OTg1NDc5OTA=",
      "title": "HKDF-Expand limits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/132",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "RFC 5869 limits the output length of Expand to 255*HashLen, but the envelope ciphertext has a larger capacity. (In theory, HKDF can produce any number of bytes, but we should abide by the interface limitations.) ",
      "createdAt": "2021-02-01T17:13:19Z",
      "updatedAt": "2021-03-10T16:31:42Z",
      "closedAt": "2021-03-10T16:31:42Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have a suggestion for how we should address this? The only way in which our outputs might need to be variable size would be if we support super long key lengths, right? But this doesn't seem like it would happen based on the configurations / ciphersuites we plan to support.\r\n\r\nUnless I am missing something?",
          "createdAt": "2021-02-02T00:46:20Z",
          "updatedAt": "2021-02-02T00:46:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "After some offline discussion: in order to address this, we will limit all opaque key types to be at most 255 bytes instead of 2^16-1.",
          "createdAt": "2021-02-03T02:07:28Z",
          "updatedAt": "2021-02-03T02:07:28Z"
        },
        {
          "author": "rot256",
          "authorAssociation": "NONE",
          "body": "That is not enough for a 2048-bit RSA key.\r\n\r\n> Each public and private key value is an opaque byte string, specific\r\n> to the AKE protocol in which OPAQUE is instantiated.  For example, if\r\n> used as raw public keys for TLS 1.3 [RFC8446], they may be RSA or\r\n> ECDSA keys as per [RFC7250]\r\n\r\nDoes this mean that the spec bans the use of RSA?",
          "createdAt": "2021-02-03T18:41:09Z",
          "updatedAt": "2021-02-03T18:41:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> That is not enough for a 2048-bit RSA key.\r\n\r\nThis is an interesting point, but as I see it, one could just seed a PRNG with the secret bytes in the envelope. (This is related to #84.) Of course, I Am Not A Cryptographer, so perhaps this is bad practice? \ud83e\udd37 ",
          "createdAt": "2021-02-03T19:01:13Z",
          "updatedAt": "2021-02-03T19:01:13Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Deterministic generation of RSA keys is non-standard, and the tricks and hacks to make it work are quite \"roll your own\".",
          "createdAt": "2021-02-03T19:07:39Z",
          "updatedAt": "2021-02-03T19:07:39Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood : I think the current direction we are taking is to not support RSA keys, which means that the text that @rot256 linked to should be removed. Thoughts?\r\n\r\nThe group representations we *are* supporting are listed out in the Configurations section (https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#configurations-configurations) and those should all fit within the 255-byte limit.\r\n\r\nEdit: Additionally, In response to:\r\n\r\n> one could just seed a PRNG with the secret bytes in the envelope\r\n\r\nI am not so much a fan of allowing for flexibility in what goes in the secret bytes in the envelope, and hence I do not see a need for considering this. In my opinion, applications that wish to use the secrecy provided by OPAQUE can do so with the export_key parameter.",
          "createdAt": "2021-02-03T19:23:54Z",
          "updatedAt": "2021-02-03T19:26:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood : I think the current direction we are taking is to not support RSA keys, which means that the text that @rot256 linked to should be removed. Thoughts?\r\n\r\nYep, I think that's right. RSA is incompatible with 3DH anyway. For the SIGMA-I variant, we would need to make it clear that the envelope structure or its encryption mechanism would need to change. (Given that we don't have a use case for SIGMA-I right now, I think I'm fine with this outcome.)\r\n\r\n@hugokraw, one consequence of the change proposed in this issue is that it would limit OPAQUE-EA instantiations to non-RSA keys. I quite like this as a forcing function away from RSA, though I'm curious to hear your thoughts. \r\n\r\n> I am not so much a fan of allowing for flexibility in what goes in the secret bytes in the envelope, and hence I do not see a need for considering this. In my opinion, applications that wish to use the secrecy provided by OPAQUE can do so with the export_key parameter.\r\n\r\nI wasn't envisioning this being a flexible thing. I was suggesting that, rather than the envelope store the raw private key, it store a seed used to deterministically derive the key. In any case, that's a separate change if we are to make it, likely as part of #84.",
          "createdAt": "2021-02-03T19:30:35Z",
          "updatedAt": "2021-02-03T19:32:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> RFC 5869 limits the output length of Expand to 255*HashLen, but the envelope ciphertext has a larger capacity. (In theory, HKDF can produce any number of bytes, but we should abide by the interface limitations.)\r\n\r\nThis is an example of a tradeoff between simplicity and flexibility for future use.  I am all for simplicity but extensibility mechanisms have always proved useful in long-lived protocols. The discussion on the info fields we are having here illustrates this issue.\r\n\r\nPhilosophy apart, one can generate more than 255 octets with HKDF-Expand by calling HKDF-Expand(prk, \"Block 1\"), HKDF-Expand(prk, \"Block 2\"), etc., where each block contains 255 bytes.\r\n",
          "createdAt": "2021-02-04T18:48:06Z",
          "updatedAt": "2021-02-04T18:48:06Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> After some offline discussion: in order to address this, we will limit all opaque key types to be at most 255 bytes instead of 2^16-1.\r\n\r\nThis may not be sufficient for some post-quantum algorithms, including lattice-based constructions and hash-based signatures, or RSA (even 2048 needs 256 bytes).  There is always the option to only encrypt a seed to a PRG/PRF that generates the randomness from which one generates the private key (e.g., for RSA  you would encrypt two 256 values whose PRG expansions give you the primes that form your the private key). More precisely and more generally, the encrypted value is a seed to the key generation procedure). How time consuming this generation is depends on the PK scheme.  \r\nNote that long public keys (that cannot be compressed as in the case of private keys above) is not a problem since they do not need to be encrypted.",
          "createdAt": "2021-02-04T19:02:39Z",
          "updatedAt": "2021-02-04T19:02:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Deterministic generation of RSA keys is non-standard, and the tricks and hacks to make it work are quite \"roll your own\".\r\n\r\nI sent the previous response without reading the full thread so I am repeating some stuff people were already saying. The issue is not deterministic generation but expansion of a seed to a full key generation. Note that any key generation starts from a seed to a PRG so this technique is quite universal. Where the tricks come into play is for reducing the cost of key generation (that in our case happens online during user authentication). It is not the end of the world and hopefully not too much of an issue with RSA (whose coming the the end of its life) but it can be an issue with lattice based and other PQ algorithms.",
          "createdAt": "2021-02-04T19:07:43Z",
          "updatedAt": "2021-02-04T19:07:43Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, you're totally right, I was wrong in using that term, as I meant exactly what you described marvelously good. Thank you !\n\nAs for such a key reproduction for RSA, do you know about an acceptable method to reduce the cost to something acceptable if it reveals to be an issue ? (E.g. run in-browser on low power device)",
          "createdAt": "2021-02-07T22:35:54Z",
          "updatedAt": "2021-02-07T22:35:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not an expert on what implementations do these days for selecting random primes. But if we assume that primes are chosen by choosing a random value and testing for primality, then at time of password registration you would derive a PRF key P from rwdU. Then, test all values PRF_P(1), PRF_P(2), ... and choose the first two that are primes as your RSA primes. You can make the process of reconstructing the primes very efficient if you put in the envelope the positions i and j where the primes were found (these do not need to be encrypted).  ",
          "createdAt": "2021-02-07T22:49:49Z",
          "updatedAt": "2021-02-07T22:49:49Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "This was the method I was referencing to, but I'm not aware how \"standard\" it is (if it needs to be) or about reference paper on this. (Also, I'm always wary around RSA)",
          "createdAt": "2021-02-07T23:00:50Z",
          "updatedAt": "2021-02-07T23:00:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In #121, the proposal is actually to use fixed-length keys instead of variable ones. This means that rather than limiting the maximum key size to be 255 bytes as I wrote earlier, we would instead use a parameter (e.g. `Nk`) to denote the key size, which could be set by the particular ciphersuite.\r\n\r\nI believe this means that we can defer the conversation of whether or not PQ algorithms or RSA would be restricted by this 255-byte limit, since such future specifications could simply set the `Nk` value to whatever is appropriate.\r\n\r\nSee the new comment I appended to the PR here (https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/137#issuecomment-774785807) which should incorporate this.",
          "createdAt": "2021-02-07T23:11:37Z",
          "updatedAt": "2021-02-07T23:13:28Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought that the concern was that HKDF limits the output to 255*HashLen and one could presumably have some algorithms that would require a larger private key (but see below). How does fixing the length of the key to some parameter addresses this issue? if Nk is shorter than 255*HashLen then there wasn't a problem to start with and if it is larger then you still have an issue with HKDF not producing enough bits for the encryption pad.  I must be misunderstanding this.\r\n\r\nBtw, I got confused earlier in this thread when I said we have a limit of 255 bytes for the HKDF pad (hence for the private key). The limit is 255*HashLen bytes which for a minimal hashlen of 32 bytes gives 255*32 bytes =65,280 bits or almost 65KB which does not seem too restrictive. ",
          "createdAt": "2021-02-09T05:46:28Z",
          "updatedAt": "2021-02-09T05:46:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "So, the problem that we are discussing originates from lines like this:\r\n\r\n```\r\nstruct {\r\n  opaque client_private_key<1..2^16-1>;\r\n} SecretCredentials;\r\n```\r\n\r\nIt says that the `client_private_key` value is allowed to be of any length between 1 and 2^16-1 bytes. However, because this value is eventually fed into an HKDF computation, if it were to actually be 2^16-1 bytes long, we would run into conflict with the HKDF limitations.\r\n\r\nSo, a couple of options for resolving this issue:\r\n- Limit the size of this value to be between 1..2^8-1 bytes long. This would save us 1 byte on the length-prefixing of this value, and would resolve the HKDF limitation issue, but as you pointed out, this could be too restrictive for future PQ/RSA-based values.\r\n- Limit the size of this value to be at most 25532 bytes long. This could work too (as it gets around the HKDF limitation issue, and should be large enough for future PQ/RSA-based values), but it seems a bit inelegant to hardcode this value.\r\n- Restrict this value to be exactly `Nk` bytes long, where `Nk` would be a parameter configured based on the ciphersuite selection. As discussed in #121, these key values don't need to be of variable-length size anyway, and so I think it would be most elegant to just rely on the configuration specifying exactly what `Nk` is, and **ensuring, when we propose new configurations, that no configuration specifies an `Nk` that exceeds the HKDF limitations**. So for example, `Nk` for Ristretto-Sha512 would be set to `32`, and maybe a future PQ/RSA-based scheme could pick a larger `Nk`.\r\n\r\nAlso, restricting the value to be exactly `Nk` bytes long means that we no longer have to length-prefix these currently variable-length values (thus saving 1-2 bytes on the wire).\r\n\r\nHope that makes sense @hugokraw!",
          "createdAt": "2021-02-09T12:49:42Z",
          "updatedAt": "2021-02-09T12:51:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Your solution does not address the real issue here which is the limit of 8160 bytes imposed by HKDF. To me it makes more sense to have this as a limit instead of asking to configure the exact number. The latter reduces flexibility that future applications may want to have without much gain.  But, as always, for decisions that do not have a significant security/cryptography implication, I delegate to you guys.",
          "createdAt": "2021-02-09T18:12:06Z",
          "updatedAt": "2021-02-09T18:12:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw's [suggestion here](https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/141#issuecomment-780876330) should give us a way to specify a HKDF wrapper that avoids the length issue. I think the best thing is to just bake this into the spec, but underneath a new generic KDF interface. I'll work on a PR for this!",
          "createdAt": "2021-02-17T21:50:34Z",
          "updatedAt": "2021-02-17T21:50:34Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you think it is worth adding this additional level of abstraction? It is not very probable that this length issue will be encountered and a suggestion about this simple workaround should be enough, don't you think?",
          "createdAt": "2021-02-17T21:55:30Z",
          "updatedAt": "2021-02-17T21:55:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "PS: As you see, after preaching for generality, I am not recommending against it. You can't win...",
          "createdAt": "2021-02-17T21:58:00Z",
          "updatedAt": "2021-02-17T21:58:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The \"problem\" is that a suggestion isn't specific enough. The only ways forward I see are to say one of the following in the spec:\r\n\r\n1. If L < limit, don't do the workround. Else do the workaround. \r\n2. Always do the workaround, handling all L values.\r\n\r\nI'm suggesting we go with (2), since it makes things future proof and also removes this branch in code with very minimal overhead. ",
          "createdAt": "2021-02-17T21:58:59Z",
          "updatedAt": "2021-02-17T21:58:59Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If you want to specify this then the truly clean way of doing it is to use HKDF to derive a seed to a PRG and apply a PRG that is not limited in output length. But this would require another primitive and its instantiation. Your suggestion is equivalent to specifying a way to use HKDF as an unbounded-length PRG. (These may be too academic remarks, feel free to go the best way engineering calls for.)",
          "createdAt": "2021-02-17T22:07:41Z",
          "updatedAt": "2021-02-17T22:07:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If you want to specify this then the truly clean way of doing it is to use HKDF to derive a seed to a PRG and apply a PRG that is not limited in output length. But this would require another primitive and its instantiation. Your suggestion is equivalent to specifying a way to use HKDF as an unbounded-length PRG. \r\n\r\nYep, exactly! That's what I planned on doing. I'll try and prioritize a PR for this today. ",
          "createdAt": "2021-02-17T22:20:18Z",
          "updatedAt": "2021-02-17T22:20:18Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU3OTk4NDUxMTM=",
      "title": "Rename all instances of \"user\" and \"U\" to \"client\" and \"C\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/134",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "Per discussion with @chris-wood \r\n\r\nOpen to feedback / objections for this!",
      "createdAt": "2021-02-03T00:38:07Z",
      "updatedAt": "2021-02-03T20:27:18Z",
      "closedAt": "2021-02-03T20:27:18Z",
      "comments": []
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU4MDU5NjQ5Mjk=",
      "title": "KE2 and KE3 transcript mac pre-hashing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/142",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the poc, KE2 and KE3 have their transcript hashed before feeding it into the HMAC\r\n\r\nKE2 https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/opaque_ake.sage#L160\r\nKE3 https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/opaque_ake.sage#L207\r\n\r\nBut the draft doesn't mention these pre-hashing steps. This changes the HMAC output, thus don't conform with the design in the draft.\r\ncc @chris-wood and @kevinlewi",
      "createdAt": "2021-02-10T23:39:42Z",
      "updatedAt": "2021-02-17T19:49:34Z",
      "closedAt": "2021-02-17T19:49:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #147.",
          "createdAt": "2021-02-17T19:49:34Z",
          "updatedAt": "2021-02-17T19:49:34Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU4MDY0NDQzMDI=",
      "title": "follow rfc2119 to indicate requirement levels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/143",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "rfcs generally refer and use https://tools.ietf.org/html/rfc2119 to define requirement levels. this spec should follow that tradition diligently. ",
      "createdAt": "2021-02-11T14:33:06Z",
      "updatedAt": "2021-02-13T18:05:18Z",
      "closedAt": "2021-02-13T17:57:56Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC2119 [is already cited](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-1.1) for the purposes of requirement and normative language.",
          "createdAt": "2021-02-13T17:57:56Z",
          "updatedAt": "2021-02-13T17:57:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "aaah. i didn't see this in the source markdown file.",
          "createdAt": "2021-02-13T18:05:18Z",
          "updatedAt": "2021-02-13T18:05:18Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU4MDc4MzIzOTk=",
      "title": "Inconsistency between OPRF ciphersuites in draft-irtf-cfrg-voprf and draft-irtf-cfrg-opaque",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/146",
      "state": "CLOSED",
      "author": "rot256",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "draft-irtf-cfrg-voprf lists the following OPRF  instanciations:\r\n\r\n\r\n  OPRF(ristretto255, **SHA-256**)\r\n  OPRF(decaf448, SHA-512) \r\n  OPRF(P-256, SHA-256)\r\n  OPRF(P-384, SHA-512)\r\n  OPRF(P-521, SHA-512)\r\n\r\nHowever section 5 of draft-irtf-cfrg-opaque, says:\r\n\r\n\r\n   An OPAQUE configuration is a tuple (OPRF, Hash, MHF, EnvelopeMode).\r\n   The OPAQUE OPRF protocol is drawn from the \"base mode\" variant of\r\n   [I-D.irtf-cfrg-voprf].  The following OPRF ciphersuites are\r\n   supported:\r\n\r\n   *  OPRF(ristretto255, **SHA-512**)\r\n   *  OPRF(decaf448, SHA-512)\r\n   *  OPRF(P-256, SHA-256)\r\n   *  OPRF(P-384, SHA-512)\r\n   *  OPRF(P-521, SHA-512)\r\n\r\nIt seems like it should be SHA-256 in both places (targeting 128-bits of security)?",
      "createdAt": "2021-02-13T21:25:17Z",
      "updatedAt": "2021-02-14T21:32:09Z",
      "closedAt": "2021-02-14T21:32:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The [editor's copy](https://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html#name-oprfristretto255-sha-512) of draft-irtf-cfrg-voprf uses OPRF(ristretto255, SHA-512), which is why OPAQUE uses it. We chose SHA-512 because implementations using ristretto255 are more likely to also have a SHA-512 implementation (due to Ed25519 requiring SHA-512). See [this PR](https://github.com/cfrg/draft-irtf-cfrg-voprf/pull/203) and related issue(s).",
          "createdAt": "2021-02-14T21:32:09Z",
          "updatedAt": "2021-02-14T21:32:09Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWU4MTI3NzczNTE=",
      "title": "Inconsistency in test vectors regarding serialization of `encrypted_creds` in the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/150",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the draft, the `encrypted_creds` parameter of `InnerEnvelope` has a fixed key size: https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L502\r\n\r\nHowever, in the test vector generation code, the serialization of `InnerEnvelope` will length-prefix the `encrypted_creds`: https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/opaque_messages.sage#L104\r\n\r\nThis is an inconsistency in the test vectors, which mean that the hmac produced in the envelope is incorrect.",
      "createdAt": "2021-02-21T05:22:38Z",
      "updatedAt": "2021-02-21T23:36:45Z",
      "closedAt": "2021-02-21T23:36:45Z",
      "comments": []
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWU4MTI5ODEyMTI=",
      "title": "Consider renaming Test Vector sections",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/153",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Rather than calling these \"OPAQUE-3DH Test Vector 1, 2, 3, etc.\", should we give them more descriptive names based on the configuration? We already reference the fact that it is 3DH here.\r\n\r\n_Originally posted by @chris-wood in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/151#discussion_r579872996_",
      "createdAt": "2021-02-21T23:32:40Z",
      "updatedAt": "2021-04-16T13:37:47Z",
      "closedAt": "2021-04-16T13:37:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi do you have a suggestion for the naming convention? The [name is computed in the formatting script](https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/format_test_vectors.py#L126), so it should be pretty simple to change. :-) ",
          "createdAt": "2021-03-01T02:42:13Z",
          "updatedAt": "2021-03-01T02:42:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing absent a better suggestion! We can always revisit this later.",
          "createdAt": "2021-04-16T13:37:47Z",
          "updatedAt": "2021-04-16T13:37:47Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU4MjI3NzU0MzU=",
      "title": "Agree on a consistent format for all \"magic string\" constants",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/157",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here is a list of all of the constant strings currently specified in the protocol:\r\n\r\nStrings relating to envelope construction:\r\n- \"Pad\"\r\n- \"AuthKey\"\r\n- \"ExportKey\"\r\n\r\nStrings relating to the AKE section:\r\n- \"3DH\"\r\n- \"client mac\"\r\n- \"handshake secret\"\r\n- \"server mac\"\r\n- \"handshake enc\"\r\n- \"encryption pad\"\r\n- \"session secret\"\r\n- \"OPAQUE \"\r\n\r\nStrings coming from the VOPRF draft (out of scope for this draft, but here for reference):\r\n- \"VOPRF06-HashToGroup-\"\r\n- \"VOPRF06-Finalize-\"\r\n\r\nCan we agree on a convention for all of these strings?\r\n\r\nHere's my proposal: I say we change all of them (except for the VOPRF ones obviously) to look like \"AuthKey\", \"HandshakeSecret\", \"SessionSecret\", and to remove the space at the end of \"OPAQUE \".",
      "createdAt": "2021-03-05T05:59:58Z",
      "updatedAt": "2021-04-16T14:39:18Z",
      "closedAt": "2021-04-16T14:39:18Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 for CamelCase and space deletion",
          "createdAt": "2021-03-05T07:57:19Z",
          "updatedAt": "2021-03-05T07:57:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 as well!",
          "createdAt": "2021-03-05T21:23:36Z",
          "updatedAt": "2021-03-05T21:23:36Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "For OPAQUE defined strings, how about this:\r\n\r\nEnvelope construction:\r\n- \"OPAQUE-HashToScalar\"\r\n- \"Pad\"\r\n- \"AuthKey\"\r\n- \"ExportKey\"\r\n- \"MaskingKey\"\r\n- \"PrivateKey\"\r\n- \"OprfKey\"\r\n- \"CredentialResponsePad\"\r\n\r\nStrings relating to the AKE section:\r\n- \"3DH\"\r\n- \"OPAQUE-\" _(note the dash in lieu of the space, I believe this will lead to fewer implementation mishaps)_\r\n- \"ClientMAC\"\r\n- \"ServerMAC\"\r\n- \"SessionKey\"\r\n- \"EncryptionPad\"\r\n- \"HandshakeKey\"\r\n- \"HandshakeSecret\"\r\n\r\n_EDIT: updated_",
          "createdAt": "2021-04-08T13:26:27Z",
          "updatedAt": "2021-04-16T14:13:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Currently, the list of HashTo* DST's used are:\r\n\r\n| Designation | Value  | Used in | Defined in|\r\n| ------------- | ------------- | ------------- | ------------- |\r\n| ku h2s | nil | CreateRegistrationResponse(), CreateCredentialResponse() | / |\r\n| skc h2s | \"OPAQUE-HashToScalar\" | DeriveAkeKeyPair() | OPAQUE  |\r\n| password h2c | ? | VOPRF/Blind() | [VOPRF](https://github.com/cfrg/draft-irtf-cfrg-voprf) |\r\n| masking key h2s | ? | VOPRF/DeriveKeyPair()| [VOPRF](https://github.com/cfrg/draft-irtf-cfrg-voprf) |\r\n| oprf finalize | ? | VOPRF/Finalize() | [VOPRF](https://github.com/cfrg/draft-irtf-cfrg-voprf) |\r\n\r\n(\"?\" for now as they are still being discussed in [#236](https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/236) and [#244](https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/244).)\r\n\r\nIt could be useful to have them all listed in a section of the document and refer to them by constants in the functions where they are used.",
          "createdAt": "2021-04-14T00:01:15Z",
          "updatedAt": "2021-04-14T00:01:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare, @kevinlewi: I think we can close this now that #174 landed with the right strings. Strings used in the OPRF functions can be resolved in that document (as needed).",
          "createdAt": "2021-04-16T13:36:52Z",
          "updatedAt": "2021-04-16T13:36:52Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated the list above, for reference. I think we can close",
          "createdAt": "2021-04-16T14:13:47Z",
          "updatedAt": "2021-04-16T14:13:47Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWU4Mjc5MDAwNzI=",
      "title": "Hash output lengths",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/158",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new interfaces introduced in #155 decouple the hashing function from the underlying hash functions used in KDF and MAC. This opens the possibility to use an XOF for hashing. Per definition, they don't have a fixed size output, so a size for their use should be set.\r\n\r\nI suggest we also set 'length dependencies' between the output lengths and desired key lengths. For example, the `Expand()` output that yields `auth_key` should be of sufficient size for `MAC()`, and so on.\r\n\r\ncc @chris-wood @kevinlewi ",
      "createdAt": "2021-03-10T15:18:51Z",
      "updatedAt": "2021-04-21T14:12:47Z",
      "closedAt": "2021-04-21T14:12:47Z",
      "comments": []
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWU4MjgyNDcwOTE=",
      "title": "Test vector section should include configuration values for KDF, MAC, etc.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/159",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This includes specifying `Nm`, `Nx`, etc. values in addition to the KDF and MAC used.",
      "createdAt": "2021-03-10T19:43:25Z",
      "updatedAt": "2021-04-16T13:37:56Z",
      "closedAt": "2021-04-16T13:37:56Z",
      "comments": []
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU4Mjg5MjUyMTQ=",
      "title": "Replace instances of \"HMAC\" with \"MAC\" in main text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/160",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "After https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/155, some references to \"HMAC\" were left -- these should be updated to just refer to MAC",
      "createdAt": "2021-03-11T08:37:33Z",
      "updatedAt": "2021-04-15T15:18:04Z",
      "closedAt": "2021-04-15T15:18:04Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #154.",
          "createdAt": "2021-04-15T15:18:04Z",
          "updatedAt": "2021-04-15T15:18:04Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWU4MjkyNTEzNjg=",
      "title": "Revert AKE mac back to running hash",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/161",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#155 changed the AKE MAC payload from the output of a running hash to a call to Extract(). ",
      "createdAt": "2021-03-11T15:19:22Z",
      "updatedAt": "2021-03-11T20:05:44Z",
      "closedAt": "2021-03-11T20:05:44Z",
      "comments": []
    },
    {
      "number": 163,
      "id": "MDU6SXNzdWU4MzA4MDAzMzY=",
      "title": "3DH and X3DH",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/163",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Apologies if this has already been discussed or if it does not take into account security considerations already discussed.\r\n\r\nThe document describes that it is using 3DH as defined by Signal. However, this might not be completely accurate as Signal uses X3DH (as described here: https://signal.org/docs/specifications/x3dh/); even though, at the beginning, they were indeed using 3DH, as described here: https://signal.org/blog/simplifying-otr-deniability/ . So maybe there is a place to change that reference in the document.\r\n\r\nThe reason why Signal moved from 3DH to X3DH are many, but one of them is due to an attack on forward secrecy as provided by 3DH: an active adversary modifies the first flow from the Initiator to use an adversarially controlled ephemeral key, captures and drops the response from the Receiver, and then compromises the Initiator\u2019s long-term secret key. This attack requires a powerful adversary. This is also addressed in the specification itself (https://signal.org/docs/specifications/x3dh/ , section 4.5) and by the paper: https://content.sciendo.com/downloadpdf/journals/popets/2018/1/article-p21.xml\r\n\r\nSignal\u2019s X3DH protocol somewhat mitigates this attack by using signed prekeys. \r\n\r\nI haven't have the time to analyse this attack in the specific context of OPAQUE; but it could be that this has already been taken into account.\r\n\r\ncc./ @chris-wood ",
      "createdAt": "2021-03-13T04:10:42Z",
      "updatedAt": "2021-06-07T21:25:15Z",
      "closedAt": "2021-06-07T21:25:15Z",
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "body": "I'm not sure that X3DH actually stops the attack.\r\nThis attack is actually mostly an attack on the definitions.\r\nPFS says that as long as the LTKs are not compromised before the protocol completes then the attacker cannot derive the session key.\r\nThis leads to two points:\r\n1. If you consider that the server's identity and signed prekey are both LTKs (in as much as they are reused across sessions) then the attack on 3DH works just as well.\r\nA powerful attacker modifies the first flow to change the ephemeral key to one it controls, and then later compromises the server's identity and signed prekey.\r\n\r\n2. The attack on both 3DH and X3DH disappears if you add an explicit key confirmation step. In this case, client would not complete the protocol until it had received explicit proof that the server knows the derived key. \r\nThis requires the attacker to compromise the LTKs _before_ the protocol completes, thus meeting the definition of PFS.\r\n\r\nIn the case of OPAQUE the message KE2 includes a MAC keyed with Km2, which is derived from the output of 3DH, giving the client key confirmation.\r\nThe server gets key confirmation from the client from KE3, because of the MAC keyed with Km3. \r\n\r\nSo w.r.t. the draft, I think we should clean up the text:\r\n1. to say that Signal uses X3DH, it's important to get these things right. \r\n1. to say that the AKE does _not_ need explicit key confirmation, because OPAQUE has a separate key confirmation step.\r\n2. to make it easier to see where the keys actually come from, because at the moment it's a bit hard to see that Km2 is dependent on 3DH. \r\n",
          "createdAt": "2021-03-18T17:03:21Z",
          "updatedAt": "2021-03-18T17:03:21Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "My comment is not adding anything useful to the conversation, but just FTR that the link in the doc points to [this](https://signal.org/docs/specifications/doubleratchet/#recommended-cryptographic-algorithms), and I think it should point to [this](https://signal.org/docs/specifications/x3dh).",
          "createdAt": "2021-03-18T17:50:15Z",
          "updatedAt": "2021-03-18T17:50:15Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @jhoyla I agree. \r\nI'll send a PR and cc you ;)\r\n\r\n@bytemare \r\n\r\n> My comment is not adding anything useful to the conversation, but just FTR that the link in the doc points to this, and I think it should point to this.\r\n\r\n3DH is defined here: https://signal.org/blog/simplifying-otr-deniability/ (section: Potential Simplifications and Improvements) I think that is the document to point to. I don't think we should include the link to X3DH, as it might confuse readers but rather mention that Signal uses this variant. \r\n\r\nThank you!",
          "createdAt": "2021-03-18T18:16:28Z",
          "updatedAt": "2021-03-18T18:16:28Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh yes, totally agree! I didn't see it was there \ud83d\udc4d\r\n( it's not obviously written on it \ud83d\ude05 )",
          "createdAt": "2021-03-18T18:23:00Z",
          "updatedAt": "2021-03-18T18:23:30Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "ccing @hugokraw in case he has any thoughts on whether or not it would be necessary to move to X3DH instead of 3DH.",
          "createdAt": "2021-03-21T22:42:40Z",
          "updatedAt": "2021-03-21T22:42:40Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "No need to move to X3DH. X3DH cannot be used in a PAKE as it requires long-term keys on the client side.. As for the attack @claucece points to (namely lacking strong forward secrecy), this is addressed (as @jhoyla explains) by having explicit authentication by both parties via the MAC values. Strong forward secrecy is a built-in requirement in OPAQUE.\r\n\r\nAs for the relation to Signal, my original text said that \"3DH serves as a basis for the key-exchange protocol of SIGNAL.\" which I think is accurate. The reason we are using 3DH is because it is simple to describe and it is relatively efficient (more specifically, it is there because HMQV, which two less exponentiations, has a patent)",
          "createdAt": "2021-03-21T23:22:57Z",
          "updatedAt": "2021-03-21T23:24:40Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you @hugokraw for the explanation and @kevinlewi for the pointer ;) \r\n\r\nWe talked this offline with @jhoyla extensively and agree on this. \r\n\r\nWe will send a PR just with clarifications for a reader that gets confused, and cc you all into it for your comments ;)",
          "createdAt": "2021-03-22T20:08:25Z",
          "updatedAt": "2021-03-22T20:08:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@claucece, @jhoyla: should we still expect a PR for this issue? If not, can we close this out?",
          "createdAt": "2021-05-26T19:51:22Z",
          "updatedAt": "2021-05-26T19:51:22Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes! sorry about that. Thank you for reminding me. I'll send today, as I'm re-reading the draft ;)",
          "createdAt": "2021-05-27T14:00:14Z",
          "updatedAt": "2021-05-27T14:00:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #216.",
          "createdAt": "2021-06-07T21:25:15Z",
          "updatedAt": "2021-06-07T21:25:15Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWU4NDAxMTk4MjA=",
      "title": "Expand input name",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/165",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "We currently use `prk` as the input to `Expand()` calls for alignment with HKDF, but this deviates from the original paper which used `rwd`. The latter might be too easily confused with `pwd`, so how about we clarify and call it `randomized_pwd`? That would also be more in line with other naming conventions used in the doc, where we spell things out rather than use acronyms. \r\n\r\n@hugokraw, what do you think?",
      "createdAt": "2021-03-24T20:00:11Z",
      "updatedAt": "2021-04-15T23:49:09Z",
      "closedAt": "2021-04-15T23:49:09Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am ok with it.",
          "createdAt": "2021-03-24T20:18:39Z",
          "updatedAt": "2021-03-24T20:18:39Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "MDU6SXNzdWU4NDAxNjg0Mjg=",
      "title": "Adding test vectors for \"faked\" credential response?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/166",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "next-version"
      ],
      "body": "In https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/22, we added the option for a server to be able to issue a \"fake\" credential response in the absence of a password file for a registered user. The current draft also describes how this response should be constructed. Should we also include test vectors for this functionality?",
      "createdAt": "2021-03-24T21:12:48Z",
      "updatedAt": "2021-06-21T23:53:10Z",
      "closedAt": "2021-06-21T23:53:10Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "closed by #214 ",
          "createdAt": "2021-06-21T23:53:10Z",
          "updatedAt": "2021-06-21T23:53:10Z"
        }
      ]
    },
    {
      "number": 167,
      "id": "MDU6SXNzdWU4NDAyMDkxNDg=",
      "title": "Include primitive parameters in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/167",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "See [this comment](https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/164#pullrequestreview-620267851)!",
      "createdAt": "2021-03-24T22:02:45Z",
      "updatedAt": "2021-04-15T15:20:49Z",
      "closedAt": "2021-04-15T15:20:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Dupe of #159.",
          "createdAt": "2021-04-15T15:20:49Z",
          "updatedAt": "2021-04-15T15:20:49Z"
        }
      ]
    },
    {
      "number": 169,
      "id": "MDU6SXNzdWU4NDg3MjMyMDA=",
      "title": "3DH: highlight the usage of client_info and server_info",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/169",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In the 3DH instantiation, the fields `client_info` and `server_info` are marked as optional and application-specific. \r\n\r\n```\r\nclient_info\r\nOptional application-specific information to exchange during the protocol.\r\n\r\nenc_server_info\r\nOptional application-specific information to exchange during the protocol encrypted under key Ke2, defined below.\r\n```\r\n\r\nThe request here is to highlight in the document what are the possible use cases of these fields, and to remark the relevance of having these fields vs not having them at all.\r\n \r\n",
      "createdAt": "2021-04-01T19:16:52Z",
      "updatedAt": "2021-05-28T02:12:56Z",
      "closedAt": "2021-05-26T19:50:54Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "(not answering the question, but FTR: #172 adds that client_info is authenticated under the KE3 mac )",
          "createdAt": "2021-04-15T21:17:52Z",
          "updatedAt": "2021-04-15T21:17:52Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Some observations about these fields\r\n\r\nI'm not aware of many significant use cases for these fields. I'm very interested in examples that would undoubtedly justify these fields are kept. I can come up with valid ones, but they are weird enough they don't seem to solve any existing problem.\r\n\r\nAn important point to consider The `server_info `has strong constraints.\r\n_If it is used for client-specific values_, it may leak info about the client's existence and activity, harming the client enumeration mitigation effort to some degree. That means that it must be of constant length, whether the user exists or not. Keeping this coherent across and for all clients in time doesn't look to scale reasonably well.\r\nThis being considered, application-specific `server_info `might not even need encryption if we consider an attacker already has access to the application.\r\n\r\nThen again, `server_info `in KE2 instead of being in a message post-OPAQUE must justify a reasonable practical, security, or performance point. This point might be very niche and application-specific as well, thus not justifying `server_info `to be kept in-band. Maybe extracting its concept and specifying it in the appendix would be an acceptable compromise.\r\n\r\nAlso, there's a very interesting thread in #74 ",
          "createdAt": "2021-04-26T18:51:11Z",
          "updatedAt": "2021-04-26T18:51:11Z"
        },
        {
          "author": "afbase",
          "authorAssociation": "CONTRIBUTOR",
          "body": "# Prior Art And Use Cases\r\n\r\nIf any language from the OPAQUE draft is referenced below, it is in reference to the language found in commit [e221eaf](https://github.com/cfrg/draft-irtf-cfrg-opaque/tree/e221eaf702c2f018ad73bdfd3e043abbf8706b1f).\r\n\r\n>The request here is to highlight in the document what are the possible use cases of these fields, and to remark the relevance of having these fields vs not having them at all.\r\n\r\n_Please_ critique my use cases with the critique, let's focus on whether the client_info and server_info is useful here.\r\n\r\nI will follow up with prior art examples of where extra server information is provided in other authentication schemes in another comment (either Tuesday or Wednesday evening Pacific time)\r\n\r\n## Use Case 1 - Load Balancer with Multiple Backend Servers\r\n\r\nSuppose we have:\r\n  1. a client, \r\n  1. loadbalancer (LB),\r\n  1. N backend servers (ASCII Diagram -> N=3),\r\n  1. The client has completed a registration flow\r\n\r\n```\r\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n                        \u2502Client\u2502\r\n                        \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2518\r\n                           \u2502\r\n                           \u2502\r\n                           \u2502\r\n                           \u2502\r\n                           \u2502\r\n                           \u2502\r\n                           \u25bc\r\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Load Balancer \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n        \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                              \u2502\r\n        \u2502                  \u2502                                     \u2502\r\n        \u2502                  \u2502                                     \u2502\r\n        \u2502                  \u2502                                     \u2502\r\n        \u2502                  \u2502                                     \u2502\r\n        \u2502                  \u2502                                     \u2502\r\n        \u2502                  \u2502                                     \u2502\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510              \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Backend 1 \u2502              \u2514\u2500\u2500\u25ba\u2502 Backend 2 \u2502                 \u2502 Backend 3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nPlease forgive the one-way direction of flow in the diagram above.  It should be two way and I could not figure out how to do that in asciiflow.\r\n\r\n### Use Case 1; Subproblem 1 - AKE via TCP LB Session Persistence\r\n\r\nHigh-Level: The client will communicate with only one backend for the lifetime of the session.  The LB facilitates the routing between client and the backend.  AKE is done between one backend and client.\r\n\r\nIs the server_info/client_info useful here?\r\n\r\nAn example of how might `server_identity` and `server_info` might be used is:\r\n  1. `server_identity`: agnostic value (i.e. it is the same value) across all backend servers\r\n  1. `server_info`: information that would be specific to the backend communicating with the client.\r\n\r\nAnother sub-subproblem of this is to assume (1) all backend servers accept the client's prior registration flow and (2) that neither backend server hosts the same application.\r\n\r\nIs the server_info/client_info useful here?\r\n\r\n### Use Case 1; Subproblem 2 - AKE with HTTP LB \r\n\r\nHigh-Level: The client will communicates with HTTP LB.  AKE is done between HTTP LB and Client.  The HTTP LB also routes information to one of the backend servers.\r\n\r\n\r\nIs the server_info/client_info useful here?\r\n\r\n\r\n## To wrap up this post\r\n\r\nAt this moment, I could potentially see how `server_info` might be useful; I haven't exactly thought about `client_info` in great depth.  I am also aware and totally understanding that this information during AKE might open doors to problems and usage that would be detrimental.  ",
          "createdAt": "2021-04-27T06:40:05Z",
          "updatedAt": "2021-04-27T06:40:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@afbase could routing information (like the specific backend being used) not be conveyed _outside_ of the OPAQUE messages? Does it need to be authenticated by the handshake?",
          "createdAt": "2021-04-27T12:49:07Z",
          "updatedAt": "2021-04-27T12:49:07Z"
        },
        {
          "author": "afbase",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n\r\n> @afbase could routing information (like the specific backend being used) not be conveyed _outside_ of the OPAQUE messages? Does it need to be authenticated by the handshake?\r\n\r\n\r\n\r\n@chris-wood \r\nwith respect to the use cases above and after some thought about this, the simple answer is no; it is not necessary to be authenticated in the handshake and application (and routing) information can be done after the handshake.  \r\n\r\n>I will follow up with prior art examples of where extra server information is provided in other authentication schemes in another comment (either Tuesday or Wednesday evening Pacific time)\r\n\r\nWell I've been asking a lot of myself here!  I have given some thought about other prior art in key exchanges and authentication schemes this evening but i haven't quite written much just yet.  Hope to have something tomorrow (wedenesday evening pacific time)\r\n\r\n\r\n",
          "createdAt": "2021-04-28T05:58:58Z",
          "updatedAt": "2021-04-28T05:59:12Z"
        },
        {
          "author": "afbase",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">and to remark the relevance of having these fields vs not having them at all.\r\n\r\nI am leaning heavily to opine to not having them at all.  I would really like to do a survey of prior KE's and authentication schemes to justify such an opinion but I just don't have the time to really dive deep into various prior art, identify and provide comment on analogous constructions.  \r\n\r\nAre there any existing survey papers that might touch this particular issue on (A)KEs?  \r\n\r\n",
          "createdAt": "2021-04-30T06:08:22Z",
          "updatedAt": "2021-04-30T06:08:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to take a step back and ask whether we can simply remove these two fields altogether, as @armfazh's initial comment seems to suggest. There's a couple reasons for this:\r\n\r\n1. Server info must be user-agnostic, i.e., of the same size and generated in the same amount of time for all users, otherwise it  can be a potential side channel breaking user enumeration mitigations. (This is very similar to the challenge we face in [TLS ECH](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html), and so far we've been punting on that in the technical specification.) Any information that is not user-specific seems like it can therefore either be transported outside of the OPAQUE handshake but in the server's first flight, or after the handshake is complete. \r\n2. We have no existing use cases for these fields. (I don't view sending the username in client info as a valid use case, for what it's worth.) Moreover, no existing deployed PAKEs have these fields, and no planned use cases for OPAQUE require, to my knowledge, use of these fields, which leads me to conclude that they're really not needed in practice.\r\n3. [RFC8125](https://tools.ietf.org/html/rfc8125) does not require the PAKE to support this type of \"early\" data, nor does it touch on extensibility. \r\n\r\nThis issue seems sharply focused on how extensible we view the protocol. If we want it totally extensible, then keeping these fields make sense, even if we don't have an existing use case. If we want to keep this protocol rigid yet admit future extensibility, we can remove them and say that future versions can reintroduce them as needed.\r\n\r\nAs an aside, I'll note that the current way in which the server info is encrypted is really... bespoke. If we are to keep these fields, I think we should strongly consider transitioning to something a bit more like TLS/QUIC, which has separate record and message layers, and encryption happens at the record layer. \r\n\r\ncc @hugokraw ",
          "createdAt": "2021-05-03T20:00:28Z",
          "updatedAt": "2021-05-04T13:35:55Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": " I understand the desire to simplify the specification as much as possible and reduce options but I also think that we are producing a spec that is supposed to serve a large (and unknown) variety of applications and not accommodating the transmission of server-to-client information in the protocol seems overly restrictive. I do appreciate the simplification this brings to the user enumeration defense (which as noted earlier, would require the length of this message to be user-independent). Overall, there seems to be strong support for removing the encrypted server_info message and since this is a functional decision and not a cryptographic one I will defer to the engineering judgment (*).  I wonder if there should be some  extensibility mechanism for the protocol messages even if it does not include the mechanics of how to encrypt such extensions.  \r\n\r\n(*) For general clients, such as browsers, that may not be fully configured for a particular application, the server may need to provide OPAQUE-specific information, e.g. hardening parameters, One could fit this information in the envelope but we are not doing that so we must be assuming that this type of information is transmitted \"out of band\" (i.e., through some application wrapper) and unauthenticated (except if the whole thing goes inside a TLS tunnel or the like).\r\n\r\nFinally, regarding client_info, @chris-wood says that \"I don't view sending the username in client info as a valid use case\". I guess that this assumes that user information is always transported outside OPAQUE. I am not sure this is a good universal assumption, and since this message does not have the complexities of server_info (it does not require  encryption and does not interfere with user enumeration), I would be inclined to keep it. But I will not go into hunger strike if you think otherwise.",
          "createdAt": "2021-05-05T02:30:59Z",
          "updatedAt": "2021-05-05T02:30:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay in following up on this! Please see below.\r\n\r\n> Overall, there seems to be strong support for removing the encrypted server_info message and since this is a functional decision and not a cryptographic one I will defer to the engineering judgment (*). I wonder if there should be some extensibility mechanism for the protocol messages even if it does not include the mechanics of how to encrypt such extensions.\r\n\r\nIndeed. I think we can safely remove this piece of information. What remains, then, is the client info. (The hardening parameters are part of the configuration information, so they would be exchanged alongside the config.)\r\n\r\nI did a (albeit quick) survey of PAKE uses top of mind, as well as other asymmetric and symmetric PAKE protocols, with respect to their support for \"early\" client data. The results are below. (Please attribute errors or inaccuracies to me!)\r\n\r\nPAKE use cases:\r\n- [Magic Wormhole](https://github.com/magic-wormhole/magic-wormhole): no application data\r\n- [CHIP](https://github.com/project-chip/connectedhomeip): no application data\r\n- [WPA-2 authentication](https://papers.mathyvanhoef.com/ccs2017.pdf): no application data\r\n\r\nSymmetric:\r\n- [J-PAKE](https://datatracker.ietf.org/doc/html/rfc8236#section-2.2): no application data\r\n- [SPAKE2](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-spake2-18): no application data\r\n- [SPEKE](https://eprint.iacr.org/2014/585.pdf): no application data, but identities are transferred\r\n- [CPace](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-cpace-01#section-3.2): no application data\r\n\r\nAsymmetric:\r\n- [SPAKE2+](https://datatracker.ietf.org/doc/html/draft-bar-cfrg-spake2plus-02): no application data\r\n- OPAQUE: application data!\r\n- [AuCPace](https://eprint.iacr.org/2018/286.pdf): no application data, but identities are transferred\r\n- [SRP](http://srp.stanford.edu/): unclear\r\n- BSPAKE: unclear\r\n\r\nIn general, it seems this is not a useful or sought-after feature, else we would see it more widely used or supported in existing protocols. Given this, as well as possible privacy concerns about sending application-specific information in client info, I'm inclined to drop both application data fields from the handshake. If circumstances change and this prohibits some future application from using OPAQUE, we can always rev the protocol version.",
          "createdAt": "2021-05-24T20:28:22Z",
          "updatedAt": "2021-05-25T12:39:33Z"
        },
        {
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "body": "From the use cases I'm familiar with, early data has never really been something that we felt we really needed. \r\n\r\nThat said, SPAKE2+ does provide a mechanism to pass authenticated data into the confirmation messages, which is very useful for preventing downgrade attacks on protocol versions and ensure that both parties have agreed on a list of supported versions or anything else that would benefit from being authenticated.",
          "createdAt": "2021-05-25T12:20:46Z",
          "updatedAt": "2021-05-25T12:20:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare, @kevinlewi: the SPAKE2+ approach referenced by @FredericJacobs seems like the right thing here. Namely, allow both parties to input a _shared_ context string that's prepended to the transcript. This can include anything external to the protocol or was otherwise used to configure the protocol, e.g., version information, MHF parameters, etc. Importantly, unlike client_info and server_info, this information is _not_ part of the OPAQUE wire image. ",
          "createdAt": "2021-05-25T15:02:46Z",
          "updatedAt": "2021-05-25T15:02:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #211. @armfazh, please reopen if you disagree!",
          "createdAt": "2021-05-26T19:50:54Z",
          "updatedAt": "2021-05-26T19:50:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am replying here since this issue is closed and I don't know how to reply\ndirectly from github in this case (it is ok if you laugh at me, just not\nloud enough that I could hear it :-).\n\nI am glad you agree to adding this way of authenticating information\npassed/agreed between client and server. What's not clear to me is what is\nmeant by \"prepended to the transcript\"? When/how is it prepended and how is\nauthentication applied to it? Is it via the MAC on the wire or via KDF? Or\nsome other form?\n\nUnrelated question: Chris references other a/PAKE protocols. Do any of them\nhave a detailed *full* specification like the one we are developing here?\nOr a working implementation?  (Anything less detailed than that will not\ncare about specifying if implementation data needs or does not need to be\ncommunicated as part of the protocol.)\n\nOn Tue, May 25, 2021 at 11:11 AM Christopher Wood ***@***.***>\nwrote:\n\n> @bytemare <https://github.com/bytemare>, @kevinlewi\n> <https://github.com/kevinlewi>: the SPAKE2+ approach referenced by\n> @FredericJacobs <https://github.com/FredericJacobs> seems like the right\n> thing here. Namely, allow both parties to input a *shared* context string\n> that's prepended to the transcript. This can include anything external to\n> the protocol or was otherwise used to configure the protocol, e.g., version\n> information, MHF parameters, etc. Importantly, unlike client_info and\n> server_info, this information is *not* part of the OPAQUE wire image.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/169#issuecomment-847945665>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXQK4QMCJOH66AMVCI3TPO423ANCNFSM42HUZY7A>\n> .\n>\n",
          "createdAt": "2021-05-26T21:51:36Z",
          "updatedAt": "2021-05-26T21:51:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am replying here since this issue is closed and I don't know how to reply directly from github in this case (it is ok if you laugh at me, just not loud enough that I could hear it :-).\r\n\r\nNo problem =)\r\n\r\n> I am glad you agree to adding this way of authenticating information passed/agreed between client and server. What's not clear to me is what is meant by \"prepended to the transcript\"? When/how is it prepended and how is authentication applied to it? Is it via the MAC on the wire or via KDF? Or some other form?\r\n\r\nBy \"prepend to the transcript,\" we mean that the transcript used to derive keys includes: (1) the shared context string, and (2) then all handshake messages sent on the wire. (For comparison, client_info was also authenticated by including it in the transcript. The difference here is that client_info was sent on the wire in the handshake message, whereas the shared context string _need not_ be sent on the wire.) \r\n\r\n> Unrelated question: Chris references other a/PAKE protocols. Do any of them have a detailed *full* specification like the one we are developing here? Or a working implementation?\r\n\r\nI'm not sure what you mean by \"full\" specification here. CPace and SPAKE2+, for example, are \"full\". OPAQUE just happens to cover more wire format details, leaving less to implementers to figure out. ",
          "createdAt": "2021-05-26T22:00:15Z",
          "updatedAt": "2021-05-26T22:00:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation. I assumed it was via the KDF indeed. I have a\ngeneral preference for authenticating things via the authentication\nmechanism in the AKE rather than via the KDF (it meshes better with the\nlogic of the protocol). Note that you could add this out-of-band value to\nthe information being MACed instead of under the KDF. But it is ok to do it\nvia the KDF too.\n\nWhile at it, what was your motivation to include the full transcript  into\nthe KDF? Did you have a specific reason for it or was it based on \"best\npractice\" and/or consistency with TLS 1.3 approach?\n\nOn Wed, May 26, 2021 at 6:00 PM Christopher Wood ***@***.***>\nwrote:\n\n> I am replying here since this issue is closed and I don't know how to\n> reply directly from github in this case (it is ok if you laugh at me, just\n> not loud enough that I could hear it :-).\n>\n> No problem =)\n>\n> I am glad you agree to adding this way of authenticating information\n> passed/agreed between client and server. What's not clear to me is what is\n> meant by \"prepended to the transcript\"? When/how is it prepended and how is\n> authentication applied to it? Is it via the MAC on the wire or via KDF? Or\n> some other form?\n>\n> By \"prepend to the transcript,\" we mean that the transcript used to derive\n> keys includes: (1) the shared context string, and (2) then all handshake\n> messages sent on the wire. (For comparison, client_info was also\n> authenticated by including it in the transcript. The difference here is\n> that client_info was sent on the wire in the handshake message, whereas the\n> shared context string *need not* be sent on the wire.)\n>\n> Unrelated question: Chris references other a/PAKE protocols. Do any of\n> them have a detailed *full* specification like the one we are developing\n> here? Or a working implementation?\n>\n> I'm not sure what you mean by \"full\" specification here. CPace and\n> SPAKE2+, for example, are \"full\". OPAQUE just happens to cover more wire\n> format details, leaving less to implementers to figure out.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/169#issuecomment-849149138>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXTNR3T5ZGAAREKN6OTTPVVP5ANCNFSM42HUZY7A>\n> .\n>\n",
          "createdAt": "2021-05-26T22:27:37Z",
          "updatedAt": "2021-05-26T22:27:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> While at it, what was your motivation to include the full transcript  into the KDF? Did you have a specific reason for it or was it based on \"best practice\" and/or consistency with TLS 1.3 approach?\r\n\r\nIt seems to be best practice and overall easier to implement. Clients and servers can just fold their entire handshake messages into the running hash, rather than pick out specific fields to include. That is, the logic for the server is basically: \r\n\r\n1. Update hash with context\r\n2. Read message from wire\r\n3. Update hash with message\r\n4. ... do rest of the protocol",
          "createdAt": "2021-05-26T22:41:02Z",
          "updatedAt": "2021-05-26T22:41:02Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks.\n\nOn Wed, May 26, 2021 at 6:41 PM Christopher Wood ***@***.***>\nwrote:\n\n> While at it, what was your motivation to include the full transcript into\n> the KDF? Did you have a specific reason for it or was it based on \"best\n> practice\" and/or consistency with TLS 1.3 approach?\n>\n> It seems to be best practice and overall easier to implement. Clients and\n> servers can just fold their entire handshake messages into the running\n> hash, rather than pick out specific fields to include. That is, the logic\n> for the server is basically:\n>\n>    1. Update hash with context\n>    2. Read message from wire\n>    3. Update hash with message\n>    4. ... do rest of the protocol\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/169#issuecomment-849167493>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXQ6C2CXMHRM2VO56F3TPV2IXANCNFSM42HUZY7A>\n> .\n>\n",
          "createdAt": "2021-05-27T00:57:00Z",
          "updatedAt": "2021-05-27T00:57:00Z"
        },
        {
          "author": "afbase",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">I did a (albeit quick) survey of PAKE uses top of mind, as well as other asymmetric and symmetric PAKE protocols, with respect to their support for \"early\" client data. The results are below. (Please attribute errors or inaccuracies to me!)\r\n\r\n@chris-wood thank you for taking the time to write this up!",
          "createdAt": "2021-05-28T02:12:55Z",
          "updatedAt": "2021-05-28T02:12:55Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU4NTM0NjI4MzM=",
      "title": "List DST used in expanding and hashing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/171",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the list of HashTo* DST's used are:\r\n\r\n| Designation | Value  | Used in | Defined in|\r\n| ------------- | ------------- | ------------- | ------------- |\r\n| skc h2s | \"OPAQUE-HashToScalar\" | DeriveAkeKeyPair() | OPAQUE  |\r\n| password h2c | ? | VOPRF/Blind() | [VOPRF](https://github.com/cfrg/draft-irtf-cfrg-voprf) |\r\n| masking key h2s | ? | VOPRF/DeriveKeyPair()| [VOPRF](https://github.com/cfrg/draft-irtf-cfrg-voprf) |\r\n| oprf finalize | ? | VOPRF/Finalize() | [VOPRF](https://github.com/cfrg/draft-irtf-cfrg-voprf) |\r\n\r\nExpand DST defined in OPAQUE used in the core mechanism\r\n| Designation | Value  | Used in |\r\n| ------------- | ------------- | ------------- |\r\n| external pad | \"Pad\" | BuildInnerEnvelope() |\r\n| env mac key | \"AuthKey\" | CreateEnvelope(), RecoverEnvelope()  |\r\n| export key | \"ExportKey\" | CreateEnvelope() , RecoverEnvelope() |\r\n| masking key | \"MaskingKey\" | CreateEnvelope(), RecoverEnvelope() |\r\n| inner skc seed | \"PrivateKey\" | BuildInnerEnvelope(), RecoverKeys() |\r\n| ku seed | \"OprfKey\" | CreateRegistrationResponse(), RecoverCredentials() |\r\n| masking encryption | \"CredentialResponsePad\" | CreateCredentialResponse(), RecoverCredentials() |\r\n\r\nExpand DST defined in OPAQUE used in 3DH\r\n| Designation | Value  | Used in |\r\n| ------------- | ------------- | ------------- |\r\n| ake label prefix | \"OPAQUE \" | CustomLabel |\r\n| handshake secret | \"handshake secret\" | Derive-Secret() |\r\n| session secret | \"session secret\" | Derive-Secret() |\r\n| 3DH prefix | \"3DH\" | Derive-Secret() preamble |\r\n| ake server auth | \"server mac\" | Key Schedule |\r\n| ake client auth | \"client mac\" | Key Schedule |\r\n| handshake encryption | \"handshake enc\" | Key Schedule |\r\n| server info encryption | \"encryption pad\" | Key Schedule |\r\n\r\nIt could be useful to have them listed in a section of the document and refer to them by constants in the functions where they are used. (This issue is a slight duplicate and must be in line and updated with the format consistency discussion in #157 )",
      "createdAt": "2021-04-08T13:15:47Z",
      "updatedAt": "2021-04-14T13:44:02Z",
      "closedAt": "2021-04-13T23:46:23Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @kevinlewi \r\n\r\nAlso, I put the VOPRF DST values to \"?\" for now as they are still being discussed in [#236](https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/236) and [#244](https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/244).",
          "createdAt": "2021-04-08T13:19:42Z",
          "updatedAt": "2021-04-14T13:44:02Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as it's actually a duplicate of the other one",
          "createdAt": "2021-04-13T23:46:59Z",
          "updatedAt": "2021-04-13T23:46:59Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWU4NTgyMTMwMjY=",
      "title": "Add application consideration section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/173",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "editorial"
      ],
      "body": "We currently have _a lot_ of knobs for applications and wrapper protocols choosing to implement OPAQUE. We should add text which discusses the different knobs, how they might be controlled, and how higher-level APIs might be presented to applications.",
      "createdAt": "2021-04-14T19:49:23Z",
      "updatedAt": "2021-06-02T19:19:09Z",
      "closedAt": "2021-06-02T19:19:09Z",
      "comments": []
    },
    {
      "number": 176,
      "id": "MDU6SXNzdWU4NjA4MzM5NjY=",
      "title": "Test vectors: client_public_key should be an intermediate value",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/176",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In all of the test vectors, client_public_key is under \"Input Values\", but it should be an \"Intermediate Value\" instead.\r\n\r\ncc: @chris-wood ",
      "createdAt": "2021-04-19T02:07:41Z",
      "updatedAt": "2021-04-20T14:30:47Z",
      "closedAt": "2021-04-20T14:30:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is only true in internal mode. It's an input otherwise. Can you please send a PR to fix?",
          "createdAt": "2021-04-19T02:09:58Z",
          "updatedAt": "2021-04-19T02:09:58Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, I thought this would be true of external mode, given the following current text:\r\n\r\n\r\n> External Key mode {#external-mode}\r\n> This mode allows applications to import custom keys for the client. This specification only imports the client's private key and > internally recovers the corresponding public key. Implementations are free to import both and thus spare a scalar multiplication at registration. In this case, the functions FinalizeRequest(), CreateEnvelope(), and BuildInnerEnvelope() must be adapted accordingly.\r\n\r\nPerhaps we should also update that to make it more clear that both client_private_key and client_public_key are inputs in external mode?",
          "createdAt": "2021-04-19T02:49:06Z",
          "updatedAt": "2021-04-19T02:49:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The private key is all that's necessary, I think. That text says that APIs can let clients import the public key, too. That's totally up to the implementation. I'm not sure off hand what further clarification is needed, so can you send a PR? ",
          "createdAt": "2021-04-19T02:54:25Z",
          "updatedAt": "2021-04-19T02:54:25Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, just want to clarify the change exactly since I think I am slightly confused by the above statements:\r\n\r\n> This is only true in internal mode. It's an input otherwise.\r\n\r\nThis seems to indicate that client_public_key for external mode *should* remain as an input for the test vectors section\r\n\r\n> The private key is all that's necessary, I think. ... I'm not sure off hand what further clarification is needed,\r\n\r\nThis seems to indicate that client_public_key for external mode *should not* remain as an input for the test vectors section\r\n\r\nWhich should it be?",
          "createdAt": "2021-04-19T04:26:20Z",
          "updatedAt": "2021-04-19T04:26:20Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the pubkey _can_ be checked as an intermediate value. For the external mode, even if it's given it will eventually pop back up and can be tested the same way as for the internal mode.\n\nIn the internal mode, it will **always** be an intermediate value, and **sometimes** in the external mode.",
          "createdAt": "2021-04-19T08:10:58Z",
          "updatedAt": "2021-04-19T08:10:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the internal mode, it will always be an intermediate value, and sometimes in the external mode.\r\n\r\nThis. :-)",
          "createdAt": "2021-04-19T13:33:41Z",
          "updatedAt": "2021-04-19T13:33:41Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWU4NjA4NDQwOTE=",
      "title": "Serialization of envelope: swap ordering of inner_env and auth_tag?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/177",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Currently, the serialization of the envelope is defined as follows:\r\n```\r\nstruct {\r\n EnvelopeMode mode;\r\n opaque nonce[Nn];\r\n opaque auth_tag[Nm];\r\n InnerEnvelope inner_env;\r\n} Envelope;\r\n```\r\n\r\nAny reason why auth_tag is not at the end of this struct? Would it suffice to put it at the end, after the inner_env parameter?\r\n\r\ncc: @bytemare , @chris-wood ",
      "createdAt": "2021-04-19T02:37:04Z",
      "updatedAt": "2021-04-20T21:19:50Z",
      "closedAt": "2021-04-20T21:19:50Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe I should have specified this somewhere, as you're not the first asking this :) ( someone else asked this somewhere in the comments of the PR)\n\nThe reason the authentication tag is at this place is that it will always be exactly there, regardless of the envelope mode (and thus the inner_envelope length), since `mode`, `nonce`, and `auth_tag` will always have the same length. I believe this makes deserialization a bit easier and might avoid deserialization errors in implementations.\n\nWhat do you think?",
          "createdAt": "2021-04-19T07:12:51Z",
          "updatedAt": "2021-04-19T07:12:51Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussions offline, and with regard to #180 , the application should provide and specify the envelope mode, and thus know about the inner envelope's length. The auth tag is therefore not required anymore to be in a fixed position and can safely be put back at the end of the envelope.",
          "createdAt": "2021-04-19T23:39:41Z",
          "updatedAt": "2021-04-19T23:39:41Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "MDU6SXNzdWU4NjIxMDMzODU=",
      "title": "Align serialized OPRF group element in messages with other representations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/179",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Currently, OPRF elements have a non-specified fixed length and format in messages, but public keys have an indicated size.\r\n\r\ne.g.\r\n\r\n```\r\nstruct {\r\n    SerializedElement data;\r\n    opaque server_public_key[Npk];\r\n} RegistrationResponse;\r\n```\r\n\r\nI suggest we go for the `opaque name[Npk]` format for OPRF elements as well",
      "createdAt": "2021-04-19T23:28:10Z",
      "updatedAt": "2021-04-20T14:32:47Z",
      "closedAt": "2021-04-20T14:32:47Z",
      "comments": []
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWU4NjIxMTE1Nzk=",
      "title": "Fix mode to application instanciation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/180",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Different envelope modes yield different inner-envelope lengths. This difference leaks when an application changes modes, and breaks a privacy property of the user enumeration mitigation.\r\n\r\nHence, if an application implements the client enumeration mitigation, it must stick to a single mode. This means it's part of the instance configuration and makes its specification inside the envelope redundant and unnecessary.",
      "createdAt": "2021-04-19T23:34:33Z",
      "updatedAt": "2021-04-20T23:51:54Z",
      "closedAt": "2021-04-20T23:51:54Z",
      "comments": []
    },
    {
      "number": 181,
      "id": "MDU6SXNzdWU4NjIxNjQ3NzI=",
      "title": "Specify that the export key is client-only",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/181",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Reading the current text in the draft, one could believe that the `export_key` is produced by both client and server. This should be fixed to makes it clear it's only available to the client.",
      "createdAt": "2021-04-20T00:18:03Z",
      "updatedAt": "2021-04-20T14:30:17Z",
      "closedAt": "2021-04-20T14:30:17Z",
      "comments": []
    },
    {
      "number": 184,
      "id": "MDU6SXNzdWU4NjIyMTI0MjA=",
      "title": "Specify envelope length in message structures",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/184",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Currently, the envelope has not specified any length in the message specifications, and I believe that's because it's a newly available value. For consistency, we should add its serialized size `Ne`.",
      "createdAt": "2021-04-20T00:55:53Z",
      "updatedAt": "2021-04-20T13:57:52Z",
      "closedAt": "2021-04-20T13:57:52Z",
      "comments": []
    },
    {
      "number": 195,
      "id": "MDU6SXNzdWU4NjQzMjY4MDg=",
      "title": "Convert all instances of \"opaque\" to \"uint8\" in struct definitions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/195",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-21T21:42:10Z",
      "updatedAt": "2021-04-22T00:08:49Z",
      "closedAt": "2021-04-22T00:08:49Z",
      "comments": []
    },
    {
      "number": 200,
      "id": "MDU6SXNzdWU4NzEyNjMxNDA=",
      "title": "Add implementation considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/200",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "This should probably include, among other things, how to implement each routine in constant time (in the user secret parameters), and why that's important. ",
      "createdAt": "2021-04-29T17:21:48Z",
      "updatedAt": "2021-06-22T08:52:07Z",
      "closedAt": "2021-06-22T08:52:07Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Two more items to consider adding:\r\n1) Ensuring that all secrets are zero'd/cleared upon deallocation, both on the client and server side,\r\n2) Timing attacks for the \"faked credential response\", an implementation needs to be very cautious when branching on whether or not a registered password file for the user exists",
          "createdAt": "2021-06-02T19:20:31Z",
          "updatedAt": "2021-06-02T19:20:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi would you be able to prep a PR for this?",
          "createdAt": "2021-06-02T19:21:12Z",
          "updatedAt": "2021-06-02T19:21:12Z"
        }
      ]
    },
    {
      "number": 204,
      "id": "MDU6SXNzdWU4ODc5MTE2NTM=",
      "title": "Add deployment considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/204",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Like #173 but for deployments, as there are specificities to OPAQUE that implementations can't always cover and that users of the protocol should or must consider.\r\n\r\nAn incomplete list would include:\r\n\r\n- Given the client-enumeration mitigation constraints\r\n  - applications must use the same configuration during their lifecycle (including the client records)\r\n- The OPRF seed is not just a global salt and must be given particular care regarding its secrecy and longevity\r\n- credential_identifiers and client_identifiers MUST be unique amongst all clients of the app",
      "createdAt": "2021-05-11T17:08:37Z",
      "updatedAt": "2021-06-02T22:07:18Z",
      "closedAt": "2021-06-02T22:07:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare can you please take this and prepare a PR?",
          "createdAt": "2021-05-26T19:51:52Z",
          "updatedAt": "2021-05-26T19:51:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(oops)",
          "createdAt": "2021-06-02T19:22:30Z",
          "updatedAt": "2021-06-02T19:22:30Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Nah, I think we can close it. It's more or less the same the other issue :)",
          "createdAt": "2021-06-02T22:06:56Z",
          "updatedAt": "2021-06-02T22:06:56Z"
        }
      ]
    },
    {
      "number": 210,
      "id": "MDU6SXNzdWU4OTk5OTE5OTQ=",
      "title": "Revisiting user enumeration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/210",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Currently, OPAQUE has support [1] for preventing user enumeration during online _authentication_. It does not, however, prevent an attacker from using the offline _registration_ flow. (This was somewhat touched in #22.) \r\n\r\nThis raises an important question: is the complexity of the enumeration attack prevention and mitigation useful given that the registration flow may already be exploited to learn this same information? \r\n\r\n@kevinlewi points out that the registration flow may have different restrictions in terms of who can trigger it. For example:\r\n\r\n- Registration may be done once during some offline \u201cbootstrap\u201d or configuration step, thereby removing any registration oracle entirely. \r\n- Registration flows may be rate limited or otherwise restricted to attackers, in contrast to the authentication flow which may not have such restrictions. \r\n\r\nIn general, this seems to boil down the use case. I don\u2019t have enough experience with asymmetric PAKE applications to know how registration typically works. I hope we can use this issue to track the question above. \r\n\r\n[1] Assuming that servers construct fake CredentialResponse values without obvious side channels when a user does not exist.",
      "createdAt": "2021-05-24T20:43:19Z",
      "updatedAt": "2021-07-01T19:05:42Z",
      "closedAt": "2021-07-01T19:05:42Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's the current set of known enumeration attacks. We should fix (1) and document the rest (for now). Further mitigations against this problem do not seem like a net improvement given additional complexity induced.\r\n\r\n1) For a non-specified client_id (attacker sends a credential_request and no client_id), if the server wishes to engage in the protocol, it must decide on a credential_identifier. If it chooses a random value, the attacker can detect a change between two requests, and know the user does not exist. It the server uses a fixed value, and the attacker probes twice with client_ids that do not exist, the attacker can detect that too. The only mitigation is to not engage in the protocol when the request does not specify the client_id.\r\n\r\n2) If credential_identifier = client_id = email or username, and the user wants to change their email or username, the OPRF key would change. An attacker with probes before and after the change will detect that activity.\r\n\r\n3) If credential_identifier = random or hash(client_id), and a registered user wants to update their client_id, then the new client_id must be available and be mapped to the credential_identifier. The 'old' one needs to remain unavailable and mapped to the same credential_identifier, or an attacker could detect that change. Also, if an attacker probes for a non-existing client_id, the server must maintain some kind of state in the client_id<>credential_identifier mapping, either by maintaining a table (undesired) or using a hash function (better).\r\n\r\n4) credential_identifier = hash(client_id):\r\na. attacker tries \"user123\" -> server doesn't know \"user123\" -> uses hash(\"user123\") as credential_identifier -> attacker fingerprints it\r\nb. a legitimate user registers under \"user456\" -> server registers hash(\"user456\") as cred_id\r\nc. user wants to change id \"user456\" for \"user123\", which is not registered. The server needs to map the client_id \"user123\" to the credential_identifier hash(\"user456\"), if we don't want to leak activity about \"user456\". But that now leaks activity about \"user123\".\r\nd. a motivated attacker indexed a billion of client_ids, and can detect if an update matches a known result and see activity\r\n\r\ncc @hugokraw ",
          "createdAt": "2021-07-01T12:49:24Z",
          "updatedAt": "2021-07-01T12:49:24Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'm not sure i followed all the details, but is this not all moot, since creating an account will always leak if a user id exists?",
          "createdAt": "2021-07-01T12:54:19Z",
          "updatedAt": "2021-07-01T12:54:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> i'm not sure i followed all the details, but is this not all moot, since creating an account will always leak if a user id exists?\r\n\r\nYep -- I think that's the key takeaway here. We shouldn't do anything to hide stuff that leaks naturally as a result of registration. ",
          "createdAt": "2021-07-01T12:55:49Z",
          "updatedAt": "2021-07-01T12:56:20Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Some of these attacks would be addressed by running re-registration with\nanyone requesting a change of user-id.\n\nThe  case of a user trying to open an account with an existing\nuserid should be dealt with in the same way one opens a new account, e.g.,\nsending email to the requested email address. The attacker will not be able\nto respond and will not learn if the account existed or it did not. (Of\ncourse, this is an administrative issue, not something related to OPAQUE.)\n\nIn general, running user enumeration by registering userid's is not\ndifferent than in today's password-over-TLS practice (is it?) so it should\nbe dealt with in the same way. Am I missing something?\n\n\n\nOn Thu, Jul 1, 2021 at 8:56 AM Christopher Wood ***@***.***>\nwrote:\n\n> i'm not sure i followed all the details, but is this not all moot, since\n> creating an account will always leak if a user id exists?\n>\n> Yep -- I think that's the key takeaway here. We shouldn't do anything to\n> hide stuff that leaks naturally during registration.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/210#issuecomment-872222686>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXX3TUGRWXUUKA4NQIDTVRQWHANCNFSM45N5DENQ>\n> .\n>\n",
          "createdAt": "2021-07-01T15:20:53Z",
          "updatedAt": "2021-07-01T15:20:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In general, running user enumeration by registering userid's is not different than in today's password-over-TLS practice (is it?) so it should be dealt with in the same way. Am I missing something?\r\n\r\nThat matches my mental model for this. That means (2), (3), and (4) are all mitigated by the application, using whatever mechanism is done today. (1) is an authentication problem that can be baked into the protocol. I'll send a PR today to clarify this and close out this issue. ",
          "createdAt": "2021-07-01T15:29:33Z",
          "updatedAt": "2021-07-01T15:29:33Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "MDU6SXNzdWU5MTI4NTUzNjY=",
      "title": "User enumeration exploiting the OPRF key consistency for a given client",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/215",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The very nature of the OPRF needs the server's input to be constant so that the client can deterministically derive their key material. With a fixed, global oprf_seed, used for all clients, the credential_identifier must then be static for a given client. This is also important in the context of the client enumeration mitigation.\r\n\r\nThis opens the current mechanism to the following attacks.\r\n\r\n___\r\n\r\n**1. Default behavior for non-existing clients**\r\n\r\nFor a non-registered client_id an incoming request demands the credentials for, the server must be able to use the same credential_identifier as when a legitimate client is registered for the requested client_id. If not, an attacker could fingerprint the OPRF key used in the evaluation using the same password, and detect an update on that client record.\r\n\r\n**Attack**\r\nThe attacker sends a credential_request without a client_id. If the server chooses to respond with a fake credential_response using a default credential_identifier, the attacker can register the evaluation for their OPRF input.\r\n\r\nThe attacker then sends credential_requests with the same OPRF input but with a (or multiple) client_id. If the client_id is not recognized by the server and it decides to respond with a fake credential_response using a default credential_identifier, it will yield the same evaluation then before, and the attacker knows the client_id is not registered. If the server recognizes it, and thus uses a different credential_identifier, then the evaluation is different, and the attacker then learns that something happened (either the client_id has been registered, or the default value has changed).\r\n\r\n**Solution**\r\n> Fortunately, trivial mitigation to this is that the server MUST NOT engage in the protocol if it can't determine a unique client_id<>credential_identifier mapping, which also seems a very natural to go.\r\n\r\n___\r\n\r\n**2. Update of existing client_id**\r\n\r\nIf credential_identifier = client_id = email or username, and the user wants to change their email or username, the OPRF key would change.\r\n\r\n**Attack**\r\nAn attacker who possesses two probes with different evaluations detects an update has happened, i.e. user activity.\r\n\r\n**Solution**\r\n> None, yet. Open to suggestions.\r\n",
      "createdAt": "2021-06-06T14:59:27Z",
      "updatedAt": "2021-06-17T17:19:37Z",
      "closedAt": "2021-06-17T17:19:37Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding: 2. Update of existing client_id\r\n\r\nWhy can't the server just begin by setting credential_identifier = Hash(client_id = email or username) *initially* (let's say this hash output is 0x67af32), and then when the user wants to change their email or username, they can do so, but the credential_identifier would stay the same, by having the server store a mapping between 0x67af32 and the new username?\r\n\r\nDoesn't this seem to resolve all issues?",
          "createdAt": "2021-06-07T17:58:53Z",
          "updatedAt": "2021-06-07T17:58:53Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm thinking about the following scenario\r\n\r\n1. Attacker tries \"user123\" -> server doesn't know \"user123\" -> uses hash(\"user123\") as credential_identifier -> attacker fingerprints it\r\n2. A legitimate user registers under \"user456\" -> server registers hash(\"user456\") as cred_id\r\n3. User wants to change id \"user456\" for \"user123\", which is not registered. The server needs to map the client_id \"user123\" to the credential_identifier hash(\"user456\"), if we don't want to leak activity about \"user456\". But that now leaks activity about \"user123\".\r\n4. A motivated attacker indexed a billion of client_ids, and can detect if an update matches a known result and see activity",
          "createdAt": "2021-06-08T00:40:28Z",
          "updatedAt": "2021-06-08T00:40:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, thanks for highlighting this.\r\n\r\nOverall, I have the feeling that we don't have a good way of completely eliminating all side-channel attacks when it comes to trying to obfuscate the leakage surrounding registration / password change / username change for OPAQUE.\r\n\r\nThe OPRF trick with the fake credential response does come close, but still leads open the possibilities for other kinds of client enumeration attacks. And I am a bit hesitant to keep introducing more and more patches to address these kinds of attacks if they do not completely solve the issue, since they come at the cost of increased spec complexity.\r\n\r\n@hugokraw : Any thoughts on if the above attack can be addressed? Or perhaps we can just resign to asserting that we cannot fully protect against client enumeration side channels with OPAQUE?",
          "createdAt": "2021-06-08T02:46:04Z",
          "updatedAt": "2021-06-08T02:46:04Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i don't think changing usernames is a thing anywhere. and even if someone wants to change their username it is a matter of registering a new user.",
          "createdAt": "2021-06-08T11:38:19Z",
          "updatedAt": "2021-06-08T11:38:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Stef, this _looks_ as a corner case and it can be addressed as if it was a new user registration.  The fact that the defenses against user enumerations do not cover corner cases is not a reason to deny this protection in much more damaging cases. ",
          "createdAt": "2021-06-08T16:52:15Z",
          "updatedAt": "2021-06-08T16:52:15Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw , @stef : Thanks for the comments. It sounds like we should opt to keep the existing mitigations for the \"fake CredentialResponse\" (using a separate OPRF) in place, while not focusing too hard on the attacks that @bytemare described above.",
          "createdAt": "2021-06-09T22:19:40Z",
          "updatedAt": "2021-06-09T22:19:40Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing and moving the general discussion to #210.",
          "createdAt": "2021-06-17T17:19:37Z",
          "updatedAt": "2021-06-17T17:19:37Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "MDU6SXNzdWU5MTM5NjYxMzg=",
      "title": "Should `G` or `MacError` be clarified?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/217",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "As far as I see, `MacError` is not properly defined. While I understand what it refers to, it might be good to define it for someone that might get confused.\r\n\r\nOn line 679, also, on the `DeriveAuthKeyPair`:\r\n\r\n```\r\n2. public_key = private_key * G\r\n```\r\nthe value `G` is not defined elsewhere, which might be confusing for a casual reader.. should it be better defined?\r\n",
      "createdAt": "2021-06-07T21:24:19Z",
      "updatedAt": "2021-06-07T22:32:02Z",
      "closedAt": "2021-06-07T22:32:02Z",
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc./ @chris-wood ",
          "createdAt": "2021-06-07T21:24:28Z",
          "updatedAt": "2021-06-07T21:24:28Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "MDU6SXNzdWU5MTQwNTc1MzE=",
      "title": "Give constant-time trick in current user enumeration mitigation scheme",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/219",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [],
      "body": "To ensure a constant time \"fake\" response by the server, two solutions are suggested\r\n\r\n- the server decides on a seed at setup, and deterministically generates a public key at each fake response to use in a fake client record. The server remembers the seed.\r\n- the server generates a public key that it will use in each fake response. The server remembers that public key.",
      "createdAt": "2021-06-07T23:47:11Z",
      "updatedAt": "2021-06-29T01:41:46Z",
      "closedAt": "2021-06-29T01:41:46Z",
      "comments": []
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWU5MjA3MTUwMzI=",
      "title": "Questions around `oprf_key` and `oprf_seed`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/220",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "Apologies if this has already been asked or discussed somewhere else ;)\r\n\r\nAround `oprf_key`:\r\n\r\nIn the `CreateRegistrationResponse` function, an `oprf_key` is derived and presumably stored (even though what is noted is that the `oprf_seed` is the one stored, as the `oprf_key` is derived from it with other params per client). If it is not stored in the server per client, what is the purpose of it being an output of the `CreateRegistrationResponse` if it will be generated each time that is needed? If it should be stored in the server per client, perhaps this needs to be noted in the document. \r\n\r\nAround `oprf_seed`:\r\n\r\nThe `oprf_seed` is defined as:\r\n\r\n`oprf_seed, the server-side seed of Nh bytes used to generate an oprf_key.`\r\n\r\nThis might be read as if there is a client-side seed and a server-side one. Maybe it should only be noted that this is the randomly generated seed used by the server?",
      "createdAt": "2021-06-14T19:36:29Z",
      "updatedAt": "2021-06-25T15:16:07Z",
      "closedAt": "2021-06-25T15:16:07Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Totally accurate, well spotted!\nI believe this is something that survived the rewrites. One could argue that returning that value could be used for debugging, but I'm totally in favor of dropping it in the model of key derivation from a seed.",
          "createdAt": "2021-06-15T06:18:07Z",
          "updatedAt": "2021-06-15T06:18:07Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bytemare I think it could be also argued that the server can store the `oprf_key` to not perform this computation each time that is needed. Maybe the best is to give the option to store or not..",
          "createdAt": "2021-06-15T12:42:09Z",
          "updatedAt": "2021-06-15T12:42:09Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "MDU6SXNzdWU5MjA3MTcyMzU=",
      "title": "Comment around encrypted credentials text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/221",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The description of OPAQUE reads:\r\n\r\n```\r\nOPAQUE consists of two stages: registration and authenticated key exchange. In the first stage, a client registers its password with the server and stores its encrypted credentials on the server.\r\n```\r\n\r\nI really like this description but it might not be completely accurate as, as far as I understand, in the Internal mode, no encrypted credentials are stored, as the the client's private and public keys are deterministically derived from the OPRF output. Might be good to note that if what I'm saying is indeed correct ;)\r\n\r\n ",
      "createdAt": "2021-06-14T19:39:50Z",
      "updatedAt": "2021-07-01T19:05:33Z",
      "closedAt": "2021-07-01T19:05:33Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No encrypted private key is stored, but the user's envelope is still stored, so this seems accurate as-is.",
          "createdAt": "2021-06-14T22:03:05Z",
          "updatedAt": "2021-06-14T22:03:05Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I understand that the word \"encrypted\" seems not relevant in the context of the internal mode. Do you have a suggestion for the wording @claucece ?",
          "createdAt": "2021-06-15T06:14:04Z",
          "updatedAt": "2021-06-15T06:14:04Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood yes. The only thing that is stored from the client, I guess, in the end, is the `client_identity`; which is really nice as one can argue that in the internal OPAQUE mode the server only has the id of the client and nothing beyond that.\r\n\r\n@bytemare I can try to create a PR for it. Maybe after IETF? Don't want to push this with the meeting so soon...",
          "createdAt": "2021-06-15T12:40:05Z",
          "updatedAt": "2021-06-15T12:40:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood yes. The only thing that is stored from the client, I guess, in the end, is the client_identity; which is really nice as one can argue that in the internal OPAQUE mode the server only has the id of the client and nothing beyond that.\r\n\r\nWell, the server stores an entire `RegistrationUpload` struct.\r\n\r\nIf we really think a change is warranted here, we could say something like, \"... stores its credentials on the server in such a way that knowledge of the secret password is required to access them,\" or whatever. \ud83e\udd37 ",
          "createdAt": "2021-06-15T12:50:11Z",
          "updatedAt": "2021-06-15T12:50:11Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "MDU6SXNzdWU5MzA0NjgyNjY=",
      "title": "Clarify that struct notation comes from RFC8446, Section 3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/226",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should clarify that all struct notation is derived from RFC8446 (can be just one sentence)",
      "createdAt": "2021-06-25T20:03:15Z",
      "updatedAt": "2021-06-29T01:42:09Z",
      "closedAt": "2021-06-29T01:42:09Z",
      "comments": []
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWU5MzQ4MDM4MjI=",
      "title": "Shared secret concatenation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/229",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The shared secret is currently computed as follows:\r\n\r\n```\r\n1. dh1 = sk1 * pk1\r\n2. dh2 = sk2 * pk2\r\n3. dh3 = sk3 * pk3\r\n4. Output concat(dh1, dh2, dh3)\r\n```\r\n\r\nWe should probably serialize the three DH values before concatenating them. Right now, it's sort of ambiguous as to how these are represented in memory and then concatenated. (This would be a no-op for groups like ristretto255, where elements are always of a fixed-length. So this is mostly editorial.)",
      "createdAt": "2021-07-01T12:42:56Z",
      "updatedAt": "2021-07-01T18:45:52Z",
      "closedAt": "2021-07-01T18:45:52Z",
      "comments": []
    },
    {
      "number": 230,
      "id": "MDU6SXNzdWU5MzQ4MDQ4NTE=",
      "title": "Order of (password, client_identity)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/230",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The order of (password, client_identity) inputs to ClientInit and ClientFinish is inconsistent. Let's make them consistent.",
      "createdAt": "2021-07-01T12:44:11Z",
      "updatedAt": "2021-07-01T18:46:00Z",
      "closedAt": "2021-07-01T18:46:00Z",
      "comments": []
    },
    {
      "number": 234,
      "id": "MDU6SXNzdWU5NDAwNDE2MDk=",
      "title": "Replace OPRF key derivation ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/234",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, we set ku as\n`(oprf_key, _) = DeriveKeyPair(ikm)` ( and ` (kU, _) = DeriveKeyPair(self.config.oprf_suite, ikm)` in the POC ). We always discard the public key, and it's therefore unclear why we to the reader why we import that function from VOPRF (also, \nthere's an unnecessary scalar multiplication).\n\nI suggest we drop the `DeriveKeyPair` import from VOPRF (as it's not used anywhere else) and replace its call for the OPRF key with `hash_to_scalar`. This could be either with the DST inherited from VOPRF, because ku is tied to the OPRF, or with a custom DST we define in OPAQUE.",
      "createdAt": "2021-07-08T16:43:17Z",
      "updatedAt": "2021-07-19T18:45:02Z",
      "closedAt": "2021-07-19T18:45:02Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "HashToScalar is not part of the VOPRF API, so I don't think we can do this without breaking the VOPRF abstraction.",
          "createdAt": "2021-07-08T22:00:40Z",
          "updatedAt": "2021-07-08T22:00:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved based on offline chat. Please feel free to reopen if needed.",
          "createdAt": "2021-07-19T18:45:02Z",
          "updatedAt": "2021-07-19T18:45:02Z"
        }
      ]
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWU5NTE5NDA1MDM=",
      "title": "Curve25519 support",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/238",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "help wanted",
        "optional"
      ],
      "body": "We have a use case where a HSM is used to store the server private key. Currently almost all HSMs use the PKCS#11 standard, which doesn't have support for ristretto255 + DH. It is my understanding that OPAQUE had official support for X25519 in the past but dropped it in favor of ristretto255.\r\n\r\nIs it possible to elaborate on the reasons for that decision? Is it still in scope to re-introduce it and provide test vectors?\r\n\r\nI believe that OPAQUE already does support using any algorithm as long as it does fulfill the stated security requirements, but official support would still be very favorable.\r\n\r\nIt should be noted that HSMs can use P256 instead, which is already officially supported by OPAQUE, but many, including us, would like to use Curve25519 when possible.",
      "createdAt": "2021-07-23T22:53:03Z",
      "updatedAt": "2023-05-22T19:52:38Z",
      "closedAt": "2023-05-22T19:52:38Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "you need a modulo inverse function to implement opaque, no x25519 implementation i know of supports this. As the the co-author of the pkcs#11 v3.0 i'm sure we did not add neither ristretto, nor support for modulo inverse to it.",
          "createdAt": "2021-07-23T22:58:39Z",
          "updatedAt": "2021-07-23T23:02:16Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this post explains why curve25519 cannot be used: https://moderncrypto.org/mail-archive/curves/2017/000906.html\r\n",
          "createdAt": "2021-07-23T23:31:26Z",
          "updatedAt": "2021-07-23T23:31:26Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm a bit confused, maybe there is a misunderstanding here. It is my understanding that the inverse function is only needed on the client for unblinding, the only thing the HSM protects is the server private key, nothing else, PKCS#11 support isn't needed.\r\n\r\n~~I'm no cryptographer, so please forgive my naivety here, I was simply using scalars for OPRF, I didn't realize that using X25519 has any connection to the OPRF part and therefore requires the use of field elements.~~\r\n\r\nEDIT: Apparently I didn't properly understand what OPRF is, now that I looked at it closer, I believe what I have done was some kind of hybrid approach, where I was using ristretto255 for OPRF, but X25519 for the DH key exchange. I can understand if something like this might not be in scope for official support by OPAQUE, if that is the case, this can be closed.",
          "createdAt": "2021-07-24T08:53:49Z",
          "updatedAt": "2021-07-24T09:00:18Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "FTR, OPRF in a nutshell:\n- the client hashes an input to a curve using hash-to-curve > point _p_ on the curve\n- the client _blinds_ that point with an ephemeral scalar _b_ using scalar multiplication > _p^b_\n- the servers uses a (possibly) long term secret scalar _k_ to _evaluate_ that, using scalar multiplication > _p^(b . k)_\n- the client _unblinds_ that using scalar multiplication with the modular inverse (it's noted 1/b) > _p^(b . k . 1/b)_ = _p^k_\n\nEven though the modular inverse operation is only needed for the OPRF client, the whole operation needs to happen in the same group. That's why you also need it on the server.\n\nThat said, using the external mode, allowing the OPRF and AKE to have different algorithms, you can still use the HSM to store the server's AKE private key. This spec, though, defines OPAQUE-3DH, which uses the same group in both.",
          "createdAt": "2021-07-24T10:28:06Z",
          "updatedAt": "2021-07-24T10:28:06Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Even though the modular inverse operation is only needed for the OPRF client, the whole operation needs to happen in the same group. That's why you also need it on the server.\r\n\r\nI am assuming the reason why it has to happen in the same group is because the spec says so, I can't see where the connection is otherwise. But, why does \"the whole operation needs to happen in the same group\" imply that the modular inverse operation is needed on the server? The only operation I can see the server needs is the evaluation, but the secret scalar used here isn't the private key, as far as I understand. Did I misunderstand something?\r\n\r\n> That said, using the external mode, allowing the OPRF and AKE to have different algorithms, you can still use the HSM to store the server's AKE private key. This spec, though, defines OPAQUE-3DH, which uses the same group in both.\r\n\r\nI'm still confused about how the OPRF and AKE in internal mode don't allow different algorithms, I still can't see any connection. I guess, if what I'm proposing turns out to be possible in the first place, my proposal would include using different algorithms for OPRF and AKE to be supported in internal mode.\r\n\r\nMy understanding of all this is very surface-level, I might be missing something very obvious here, thank you for all the explanations.",
          "createdAt": "2021-07-24T11:11:25Z",
          "updatedAt": "2021-07-24T11:11:39Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "> But, why does \"the whole operation needs to happen in the same group\" imply that the modular inverse operation is needed on the server?\r\n\r\nThe modular inverse is not needed on the server. Regarding \"the whole operation needs to happen in the same group\", I was a bit hasty: do you think you can use Ristretto255 on the client, and Curve25519 on the server? Or run the whole on the prime order subgroup of Curve25519?\r\n\r\n> The only operation I can see the server needs is the evaluation, but the secret scalar used here isn't the private key, as far as I understand.\r\n\r\nWe call the OPRF server key a \"private key\" as well (but it's not the same as the one of the AKE). That's the one you'd like to use within the HSM, correct?\r\n\r\n> I'm still confused about how the OPRF and AKE in internal mode don't allow different algorithms, I still can't see any connection. I guess, if what I'm proposing turns out to be possible in the first place, my proposal would include using different algorithms for OPRF and AKE to be supported in internal mode.\r\n\r\nI don't know why I thought _it had to_. The spec says _it should_, and recommends using the VOPRF suites. Of course, you are free to use any curve for the AKE, regardless of what the OPRF uses. You are right, my apologies \ud83d\ude4f\r\n\r\n> My understanding of all this is very surface-level, I might be missing something very obvious here, thank you for all the explanations.\r\n\r\nYour questions and observations are totally valid and interesting :) please continue!\r\nWe have tunnel vision, so external input is very helpful!",
          "createdAt": "2021-07-24T16:18:02Z",
          "updatedAt": "2021-07-24T16:18:02Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> do you think you can use Ristretto255 on the client, and Curve25519 on the server? Or run the whole on the prime order subgroup of Curve25519?\r\n\r\nWhat I am proposing is to run the AKE with X25519 on both sides and the OPRF with ristretto255 on both sides, at least after your input :smile:.\r\n\r\n> We call the OPRF server key a \"private key\" as well (but it's not the same as the one of the AKE). That's the one you'd like to use within the HSM, correct?\r\n\r\nI believe this is the source of all misunderstandings here, I didn't realize that the OPRF server key may also be called \"private key\", this explains @stef's answer. I was actually planning to store the AKE key on the HSM, not the OPRF key, but that's only because it seems impossible to use OPRF with HSMs right now, otherwise I would store both.\r\n\r\n> Your questions and observations are totally valid and interesting :) please continue!\r\n\r\nI appreciate it, very encouraging :smiley:.\r\n\r\n---\r\n\r\nI'm drawing a lot of conclusions here that might be incorrect, so I would like to elaborate on the goal of what I am trying to do here instead of possibly focusing on the wrong solution.\r\n\r\nThe final goal is to secure OPAQUE with the help of an HSM and Curve25519. Currently HSMs don't support ristretto255, for both DH or scalar multiplication for OPRF. This leads me to my first assumption:\r\n- Storing the AKE private key on an HSM does provide **additional** security to OPAQUE, even though the OPRF secret key isn't secured through the HSM\r\n- X25519 can be used for AKE\r\n- (?) X25519 can still be used with 3DH\r\n- ristretto255 can still be used for OPRF\r\n\r\nAs far as I understand now, this isn't something the OPAQUE spec disallows:\r\n> The spec says *it should*, and recommends using the VOPRF suites. Of course, you are free to use any curve for the AKE, regardless of what the OPRF uses.\r\n\r\nWhat this issue is about is to confirm my assumptions and to ask for official support in the OPAQUE spec.",
          "createdAt": "2021-07-24T17:16:02Z",
          "updatedAt": "2021-07-24T17:16:02Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  - Storing the AKE private key on an HSM does provide additional security to OPAQUE, even though the OPRF secret key isn't secured through the HSM\r\n>  - X25519 can be used for AKE\r\n>  - (?) X25519 can still be used with 3DH\r\n>  - ristretto255 can still be used for OPRF\r\n\r\nyes to all. actually i did add 3dh to pkcs#11 back in v3.0 (and also the double ratchet). i'm not a member of the pkcs#11 wg anymore, but i can ping them to consider adding ristretto255 to a next revision (but that might take some time...)",
          "createdAt": "2021-07-24T18:03:39Z",
          "updatedAt": "2021-07-24T18:04:27Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "btw even i was confused back then when i first read one of the early drafts about this - to me - strange terminology of the oprf having a keypair: https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/54 - turns out this is a thing for **v**oprfs.",
          "createdAt": "2021-07-24T18:08:15Z",
          "updatedAt": "2021-07-24T18:08:30Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> i'm not a member of the pkcs#11 wg anymore, but i can ping them to consider adding ristretto255 to a next revision (but that might take some time...)\r\n\r\nThat would be great nonetheless! Even though it is unlikely that HSMs will implement it, even if it is in the PKCS#11 spec, unless ristretto255 becomes more popular.",
          "createdAt": "2021-07-24T20:19:29Z",
          "updatedAt": "2021-07-24T20:19:29Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Ha ! I understand the confusion better now :)\r\n\r\nIndeed: the \"server's OPRF private key\" is the secret part of the VOPRF keypair, and is totally unrelated to the server's AKE key pair.\r\n\r\n> I was actually planning to store the AKE key on the HSM, not the OPRF key, but that's only because it seems impossible to use OPRF with HSMs right now, otherwise, I would store both.\r\n\r\nA different OPRF key is used for every client. Currently, the spec derives these individual keys using a stored secret seed, common to all, and the user id, thrown into hash-to-scalar. I don't know how nicely HSM play with lots of keys to store to support a very large user pool.\r\n\r\n> I appreciate it, very encouraging \ud83d\ude03.\r\n\r\n\ud83d\ude4c \r\n\r\n> Storing the AKE private key on an HSM does provide additional security to OPAQUE, even though the OPRF secret key isn't secured through the HSM\r\nX25519 can be used for AKE\r\n(?) X25519 can still be used with 3DH\r\nristretto255 can still be used for OPRF\r\n\r\nYes to all, as well :)\r\n\r\n> What this issue is about is to confirm my assumptions and to ask for official support in the OPAQUE spec.\r\n\r\nIt's not because curves are not in the list that they are not supported. No spec says that they are not supported. Re-reading the specs, though, I understand that they might be misleading, and could indeed need some text to make it clearer. Any idea for wording that would make that more clear?\r\n\r\n> i'm not a member of the pkcs#11 wg anymore, but i can ping them to consider adding ristretto255 to a next revision (but that might take some time...)\r\n\r\nOh, that would be sweet! Given the growing popularity of r255 and d448, this is definitely a nice thing to consider for the next version :) ",
          "createdAt": "2021-07-24T22:25:26Z",
          "updatedAt": "2021-07-24T22:25:50Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A different OPRF key is used for every client. Currently, the spec derives these individual keys using a stored secret seed, common to all, and the user id, thrown into hash-to-scalar. I don't know how nicely HSM play with lots of keys to store to support a very large user pool.\r\n\r\nThey don't, I was actually talking about storing the secret seed. Another misuse of terms from my side here. In any case, I don't believe that HSMs will support VOPRF key deriviation from a stored seed anytime soon and I don't even know if that actually increases security when the AKE private key is already stored.\r\n\r\n> It's not because curves are not in the list that they are not supported. No spec says that they are not supported. Re-reading the specs, though, I understand that they might be misleading, and could indeed need some text to make it clearer. Any idea for wording that would make that more clear?\r\n\r\nTo me it was actually clear enough, I just got a bit unsure through the misunderstandings in this issue. It would be great of course if OPAQUE specifically mentions the use-case of HSMs:\r\n- > The Group mode identifies the group used in the OPAQUE-3DH AKE. This SHOULD match that of the OPRF. For example, if the OPRF is OPRF(ristretto255, SHA-512), then Group SHOULD be ristretto255.\r\n\r\n  This may need some sort of exception.\r\n- Test vectors for X25519 AKE + ristretto255 OPRF would be nice\r\n- Mention in \"Configuration\" and \"Security Considerations\" would be great\r\n\r\nI understand if this isn't really in scope for OPAQUE. I'm willing to go into more detail about wording of course if it is in scope.",
          "createdAt": "2021-07-25T06:35:12Z",
          "updatedAt": "2021-07-25T06:35:12Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "> It would be great of course if OPAQUE specifically mentions the use-case of HSMs\r\n\r\nWhat would you like to see in the spec? It's intentionally high-level enough so implementors use the keys however they want.\r\n\r\n>> The Group mode identifies the group used in the OPAQUE-3DH AKE. This SHOULD match that of the OPRF. For example, if the OPRF is OPRF(ristretto255, SHA-512), then Group SHOULD be ristretto255.\r\n\r\n> This may need some sort of exception.\r\n\r\n_SHOULD_ is not a mandatory statement. Strictly speaking, an _exception_ is relative to a _rule_, but there's no rule imposed here. Implementors are free to compose their cipher suite :) \r\n\r\n___\r\n\r\n> Test vectors for X25519 AKE + ristretto255 OPRF would be nice\r\n\r\n@chris-wood @kevinlewi: here's a request to have Test vectors for X25519 AKE + ristretto255 OPRF. What do you think?\r\n\r\n> I understand if this isn't really in scope for OPAQUE. I'm willing to go into more detail about wording of course if it is in scope.\r\n\r\nAny ideas are welcome :) ",
          "createdAt": "2021-07-26T10:05:37Z",
          "updatedAt": "2021-07-26T10:05:37Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > It would be great of course if OPAQUE specifically mentions the use-case of HSMs\r\n> \r\n> What would you like to see in the spec? It's intentionally high-level enough so implementors use the keys however they want.\r\n\r\nThe spec already recommends specific [configurations](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-06.html#name-configurations), it would be helpful if the use-case for HSMs is covered in the spec. Adding an additional recommended configuration in the case of HSMs would help people like me find a correct approach and encourage implementors to cover this use-case.\r\n\r\nIf a recommendation under [\"Configuration\"](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-06.html#name-configurations) seems to much, I believe a mention in [\"Security Considerations\"](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-06.html#name-security-considerations) seems appropriate.\r\n\r\nI'm gonna attempt to write down some wording I have in mind, I'm willing of course to make a PR, keep in mind I'm very new to this, IETF and cryptography in general, and english is my second language.\r\n```markdown\r\n# AKE Private Key Storage\r\n\r\nThe AKE private key can be securely stored in a HSM or similar. Upon compromise of the OPRF seed and client\r\nenvelopes, this would prevent an attacker from using this data to mount a server spoofing attack (someone more\r\nknowledgeable can insert actual security benefits here). The following configurations are RECOMMENDED for a\r\nscenario like this:\r\n- OPRF(ristretto255, SHA-512), HKDF-SHA-512, HMAC-SHA-512, SHA-512, Scrypt(32768,8,1), internal, X25519\r\n- OPRF(P-256, SHA-256), HKDF-SHA-256, HMAC-SHA-256, SHA-256, Scrypt(32768,8,1), internal, P-256\r\n\r\nSupporting implementations need to consider allowing separate AKE and OPRF algorithms and not requiring access\r\nto the AKE private key bytes, only support for generating shared keys for 3DH is necessary.\r\n```",
          "createdAt": "2021-07-26T10:53:29Z",
          "updatedAt": "2021-07-26T10:53:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for chiming in late here! Test vectors with a configuration where the OPRF and AKE groups are different would be great. I'm happy to add this. Shall we use this issue to track adding that, along with some discussion around the AKE-key-in-HSM use case?",
          "createdAt": "2021-07-29T00:06:17Z",
          "updatedAt": "2021-07-29T00:06:17Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's separate tracking the HSM thing in a separate issue",
          "createdAt": "2021-08-24T23:14:45Z",
          "updatedAt": "2021-08-24T23:14:45Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@daxpedda #279 adds your suggestion, I reworded it a bit. I'd be glad to have your feedback :)",
          "createdAt": "2021-10-04T10:27:50Z",
          "updatedAt": "2021-10-04T10:27:50Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just saw it, thank you!",
          "createdAt": "2021-10-04T10:28:53Z",
          "updatedAt": "2021-10-04T10:28:53Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@daxpedda for clarification: is X25519 desired solely as a group within 3DH, or as a different AKE?",
          "createdAt": "2022-01-07T15:19:52Z",
          "updatedAt": "2022-01-07T15:19:52Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't the AKE the group used within 3DH?",
          "createdAt": "2022-01-07T15:21:28Z",
          "updatedAt": "2022-01-07T15:21:28Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Specifically the point is to protect the `server_private_key`, which as far as I know is used in 3DH.\r\nThe one mentioned here:\r\nhttps://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5-1",
          "createdAt": "2022-01-07T15:24:20Z",
          "updatedAt": "2022-01-07T15:25:45Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "The AKE is the authenticated key exchange protocol in OPAQUE (chich is OPRF + AKE). Different protocols can be used as AKE, such as HMQV, 3DH, and SIGMA, as long as they are compatible with the protocol flow (3-messages, client-initiated, etc.).\r\n\r\nThis spec focuses on 3DH as an AKE.\r\n\r\nYou can use a bunch of different elliptic curve groups for 3DH (like ristretto255, p-256, etc.).\r\n\r\nX25519 is an ECDH key exchange atop Curve25519. I just want to make sure we're talking about the same thing, as I see that you and Kevin used that group within 3DH, and not an authenticated version of it in place of 3DH.",
          "createdAt": "2022-01-07T16:49:47Z",
          "updatedAt": "2022-01-07T16:50:27Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah! I see the confusion, forgive me, I'm not that good with all the terminology.\r\nI didn't mean X25519 in the sense of the ECDH key exchange, I just meant Curve25519!\r\n\r\n> @daxpedda for clarification: is X25519 desired solely as a group within 3DH, or as a different AKE?\r\n\r\nDesired solely as the group within 3DH!",
          "createdAt": "2022-01-07T16:53:26Z",
          "updatedAt": "2022-01-07T16:53:26Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarification :)\r\n\r\nOn a side note, do you suggest we should make the document clearer regarding the terminology?",
          "createdAt": "2022-01-07T16:56:24Z",
          "updatedAt": "2022-01-07T16:56:24Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe so, I think the document can be clearer in some places which group is actually meant, the AKE or OPRF, even if it can be derived.\r\n\r\nI can spend some time later on and find some places where it wasn't perfectly clear to me.",
          "createdAt": "2022-01-07T16:58:48Z",
          "updatedAt": "2022-01-07T16:58:48Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "That would be great, thanks!",
          "createdAt": "2022-01-07T17:00:20Z",
          "updatedAt": "2022-01-07T17:00:20Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tried to re-read the spec a bit and be as skeptical as possible. I'm already much more comfortable with it then in the past, so it's hard to judge what I remember was confusing.\r\nThe thing I remember was that every time I read `private_key` or `public_key` somewhere I wasn't sure which group it was talking about. For example:\r\nhttps://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.1-3\r\nLooking at the vicinity of that part of the text, there is no mention of AKE, so I think for newcomers it might take extra effort to keep track of all of it.\r\n\r\nhttps://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-4-8\r\nIs a good example, it says everywhere what key it means.\r\nhttps://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-6.1 6.2 & 6.3 also are missing direct descriptions.",
          "createdAt": "2022-01-08T00:26:21Z",
          "updatedAt": "2022-01-08T00:26:21Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One central question is whether we can instantiate a 3DH AKE using either directly X25519 DH, or **safely using** the x-only arithmetic of Curve25519?\r\n\r\nAs a side note, the 3DH with P-256 can use only the x-coord of points.\r\n\r\nAlso, it seems that instantiating an OPRF with Curve25519 is possible too.",
          "createdAt": "2022-07-07T02:51:24Z",
          "updatedAt": "2022-07-07T02:51:24Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey all, just to check back in here. Had an offline discussion with @chris-wood, and we are thinking of closing this issue without addressing it (without adding X25519 test vector support), unless there is still interest in keeping this in scope of the spec.\r\n\r\nCurious to hear what your thoughts are @daxpedda !",
          "createdAt": "2023-03-20T18:47:50Z",
          "updatedAt": "2023-03-20T18:47:50Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not much has changed on the HSM side of things since then: Ristretto255 support does not exist.\r\n\r\nSo I think there are two use-cases for adding test-vectors for Curve25519:\r\n- Clear up the question that @armfazh posed here: https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/238#issuecomment-1176985747. In `opaque-ke` I believe we are only using the x-coord.\r\n- Add at least one set of test vector that uses different groups for OPRF and AKE. @bytemare https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/238#issuecomment-888699518 mentioned this here.\r\n\r\nIf it's decided that adding Curve25519 is still not in scope, I think adding at least a test vector mixing a NIST curve with Ristretto would at least cover the second point.\r\n\r\n(I stopped using \"X25519\" to avoid any confusion about the key-exchange algorithm, which is not the topic here. Also changed the title.)",
          "createdAt": "2023-03-21T11:45:42Z",
          "updatedAt": "2023-03-21T11:45:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@daxpedda just to clarify, do you still have a use case for this? The original issue was filed with the statement that there did exist a use case to drive this. If that's still the case, we'll get this done.",
          "createdAt": "2023-03-21T12:20:32Z",
          "updatedAt": "2023-03-21T12:20:32Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh yes, absolutely. When OPAQUE is accepted by the IETF it is still our intention to use this with HSMs. We have a lot of clients who prefer Curve25519/448 over the NIST prime ones.\r\n\r\nEDIT: just for clarification, HSMs are perfectly usable with P-256/384/521.",
          "createdAt": "2023-03-21T12:29:18Z",
          "updatedAt": "2023-03-21T12:29:58Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi folks, I wanted to bring up this issue again after some more consideration. If we do decide to include test vectors for this, then another related question is, should we add the ristretto255+x25519 setting to the list of \"recommended\" configurations for OPAQUE?\r\n\r\nI think it is too niche to be considered on the list of recommended configurations. But if we don't recommend it, then it seems odd to me that we would have a set of test vectors for it.\r\n\r\nTherefore, I think it would be cleaner if we just omitted the test vectors for this, and we closed this issue + associated PR.\r\n\r\nSeparately, @daxpedda, we can certainly still support the x25519 implementation in the opaque-ke library, and will continue with the PR on that repo. I originally felt that we should not include it because it would not be part of the spec, but I've come around to and changed my mind on that, since I see the value in supporting more configurations beyond what the spec recommends. But do let me know what your thoughts are on this, as I think it would be a relief for me at least to not have to support the x25519 test vectors in the spec.\r\n\r\nThanks!",
          "createdAt": "2023-05-19T00:42:11Z",
          "updatedAt": "2023-05-19T00:42:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think it is too niche to be considered on the list of recommended configurations. But if we don't recommend it, then it seems odd to me that we would have a set of test vectors for it.\r\n\r\nI don't agree with this. It's fine to include test vectors for things that aren't recommended. \r\n\r\n> Therefore, I think it would be cleaner if we just omitted the test vectors for this, and we closed this issue + associated PR.\r\n\r\nI don't think this is the best outcome. Work on this issue revealed what I consider to be an editorial bug in the spec, in that we define 3DH -- literally three Diffie Hellman operations -- using prime-order groups, rather than Diffie Hellman operations! I think it would be much cleaner if, for example, we were to replace the prime-order group-based AKE description with one that's based on DH. X25519 would then fit naturally right in, as would ristretto255 and all the other prime-order groups.",
          "createdAt": "2023-05-19T11:53:19Z",
          "updatedAt": "2023-05-19T11:53:19Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As an implementor, I appreciate any help the specification can provide, test vectors are one of those things. Though I completely understand that the specifications job is not to cover everything an implementor might want. So this is an issue of scope, which I will squarely leave in your very capable hands.\r\n\r\n> I think it is too niche to be considered on the list of recommended configurations.\r\n\r\nAs far as I'm aware, the only use-case for this configuration is using an HSM with a non-NIST curve. Using HSMs in general is already pretty niche I would say.",
          "createdAt": "2023-05-19T11:58:42Z",
          "updatedAt": "2023-05-19T11:58:42Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for chiming in @daxpedda and @chris-wood with your comments -- I've updated #404 with a couple of changes which should be compatible with the opaque-ke implementation. Should be ready for review!",
          "createdAt": "2023-05-21T09:18:57Z",
          "updatedAt": "2023-05-21T09:18:57Z"
        }
      ]
    },
    {
      "number": 239,
      "id": "MDU6SXNzdWU5NjI5ODUxNzQ=",
      "title": "Discuss client-side versus server-side password hardening",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/239",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "The specification currently requires that password hardening happen on the client-side, specifically on the OPRF output, whereas other low-entropy authentication protocols permit this hardening to happen on the server-side. This property means that implementations must make tradeoffs with respect to client-side support and risk of server compromise. This is mostly out of scope, but we can probably touch on this in the Security Considerations.\r\n\r\ncc @kevinlewi ",
      "createdAt": "2021-08-06T19:16:16Z",
      "updatedAt": "2021-08-26T22:48:59Z",
      "closedAt": "2021-08-26T22:48:59Z",
      "comments": []
    },
    {
      "number": 240,
      "id": "MDU6SXNzdWU5NjMwNTIwMzk=",
      "title": "Protect the client record with a KEM on registration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/240",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [],
      "body": "Currently, the client sends a masking key during registration for the server to obfuscate login messages and protect against client enumeration. This relatively sensitive and secret piece of data requires the full registration to be \"secure\" with integrity, authenticity, and confidentiality, as offered by TLS for example.\r\n\r\nIntegrity and authenticity cannot be subverted once the session is over and past. Confidentiality, however, is not ensured if encryption keys are backed up, shared, or leaked, and allows decryption after the session (e.g. proxy re-encryption, logging, legal compliance, etc.). The masking key is at risk of being revealed to a passive (even non-malicious) attacker after registration has happened.\r\n\r\nThis risk can be avoided by using a KEM to protect the last registration message from the client to the server. Implementations could leverage the fact the client gets the server public key in the registration response and use symmetric encryption using a basic KEM. We could either build it into OPAQUE (not that expensive, as it happens only once) or add it to the security considerations.",
      "createdAt": "2021-08-06T21:18:50Z",
      "updatedAt": "2022-04-05T21:25:36Z",
      "closedAt": "2022-04-05T21:25:36Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I was thinking that using the HPKE-like base mode could be sufficient here, and use the registration transcript, identities, and configuration as context/aad. I don't think it's too complex to add here unless another dependency is problematic (though that spec is rather mature). What do you think?",
          "createdAt": "2021-10-04T13:23:50Z",
          "updatedAt": "2021-10-04T13:23:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we should make anything specific here, as it's a consideration external to the protocol. I'd just say that clients can encrypt their records for servers using HPKE, full stop. ",
          "createdAt": "2021-10-05T12:51:08Z",
          "updatedAt": "2021-10-05T12:51:08Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Alright \ud83d\udc4d ",
          "createdAt": "2021-10-05T13:12:01Z",
          "updatedAt": "2021-10-05T13:12:01Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's fold this into #310 ",
          "createdAt": "2022-04-05T21:25:35Z",
          "updatedAt": "2022-04-05T21:25:35Z"
        }
      ]
    },
    {
      "number": 241,
      "id": "MDU6SXNzdWU5NjUyMjEyMTg=",
      "title": "Tighten up the OPRF abstraction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/241",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The OPRF abstraction currently (and intentionally) leaks some underlying implementation details. In particular, it leaks the fact that it requires a prime-order group. Should we want to augment OPAQUE to make it PQ-friendly, PQ-friendly OPRFs, or even threshold variants, should ideally work here. We should try to improve this abstraction so as to accommodate other types of primitives. ",
      "createdAt": "2021-08-10T18:14:11Z",
      "updatedAt": "2022-02-04T15:18:54Z",
      "closedAt": "2022-02-04T15:18:54Z",
      "comments": []
    },
    {
      "number": 242,
      "id": "MDU6SXNzdWU5NjUyMjM2MzA=",
      "title": "Promote AKE shape to the dependency section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/242",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The shape of the AKE protocol, including the messages exchanged and its properties, is currently in the 3DH AKE section. We might consider promoting this to the dependency section so as to better accommodate future AKEs, such as SIGMA. ",
      "createdAt": "2021-08-10T18:16:28Z",
      "updatedAt": "2021-10-04T14:21:25Z",
      "closedAt": "2021-10-04T14:21:25Z",
      "comments": []
    },
    {
      "number": 243,
      "id": "MDU6SXNzdWU5NjUyMjQ2NjM=",
      "title": "Improve envelope mode use cases",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/243",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This can be unclear to some readers. Let's improve the motivation for these separate modes, and additionally consider whether or not we want to accommodate future modes. ",
      "createdAt": "2021-08-10T18:17:35Z",
      "updatedAt": "2021-08-18T18:35:04Z",
      "closedAt": "2021-08-18T18:35:04Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #251.",
          "createdAt": "2021-08-18T18:35:04Z",
          "updatedAt": "2021-08-18T18:35:04Z"
        }
      ]
    },
    {
      "number": 244,
      "id": "MDU6SXNzdWU5NjUyMjY1NzE=",
      "title": "Revisit pseudocode descriptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/244",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "next-version"
      ],
      "body": "Perhaps alignment with HPKE would improve things? One downside is that HPKE does not make parameter types clear, which is currently done in the OPAQUE pseudocode. While we're in here, we should unify capitalization for the parameters. Inconsistent examples include:\r\n\r\n```\r\n- envelope, the client's `Envelope` structure\r\n...\r\n- server_identity, The optional encoded server identity.\r\n```\r\n\r\nAs an aside, this is probably a larger question for CFRG: how do we want to express pseudocode for implementers? ",
      "createdAt": "2021-08-10T18:19:32Z",
      "updatedAt": "2022-02-02T17:31:12Z",
      "closedAt": "2022-02-02T17:31:12Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll do this after @bytemare's abstraction changes land.",
          "createdAt": "2021-09-22T22:30:35Z",
          "updatedAt": "2021-09-22T22:30:35Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://www.ietf.org/about/groups/iesg/statements/formal-languages-use/\r\n\r\n```\r\n1. ikm = TripleDHIKM(state.client_secret, ke2.server_keyshare,\r\n    state.client_secret, server_public_key, client_private_key, ke2.server_keyshare)\r\n2. preamble = Preamble(client_identity, state.ke1, server_identity, ke2)\r\n3. Km2, Km3, session_key = DeriveKeys(ikm, preamble)\r\n4. expected_server_mac = MAC(Km2, Hash(preamble))\r\n5. If !ct_equal(ke2.server_mac, expected_server_mac),\r\n     raise HandshakeError\r\n6. client_mac = MAC(Km3, Hash(concat(preamble, expected_server_mac))\r\n7. Create KE3 ke3 with client_mac\r\n8. Output (ke3, session_key)\r\n```\r\nsome indentation can be done in order to make the code more legible.\r\n\r\n```\r\n1.   ikm = TripleDHIKM(\r\n                  state.client_secret, ke2.server_keyshare,\r\n                  state.client_secret, server_public_key, \r\n                  client_private_key, ke2.server_keyshare)\r\n2.   preamble = Preamble(\r\n                  client_identity, state.ke1, \r\n                  server_identity, ke2)\r\n3.   Km2, Km3, session_key = DeriveKeys(ikm, preamble)\r\n4.   expected_server_mac = MAC(Km2, Hash(preamble))\r\n5.   If !ct_equal(ke2.server_mac, expected_server_mac),\r\n5.1     raise HandshakeError\r\n6.   client_mac = MAC(Km3, Hash(\r\n                  concat(preamble, expected_server_mac))\r\n7.   Create KE3 ke3 with client_mac\r\n8.   Output (ke3, session_key)\r\n```\r\n\r\nAlternatively, the small scripts can be moved to a single section. In the main body, it defines only inputs and outputs.\r\n",
          "createdAt": "2021-11-18T23:31:50Z",
          "updatedAt": "2021-11-18T23:31:50Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWU5NjUyMjg2OTU=",
      "title": "MHF usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/245",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "OPAQUE currently assumes that the MHF output is pseudorandom, as it's currently used as the IKM input to the KDF:\r\n\r\n```\r\nrandomized_pwd = Extract(\"\", Harden(y, params))\r\n```\r\n\r\nWe could fix this by requiring the MHF to output something that's pseudorandom, or by changing how we invoke Extract, e.g.:\r\n\r\n```\r\nrandomized_pwd = Extract(Harden(y, params), y))\r\n```\r\n\r\ncc @cjpatton, @hugokraw \r\n",
      "createdAt": "2021-08-10T18:21:52Z",
      "updatedAt": "2021-09-23T12:02:28Z",
      "closedAt": "2021-09-23T12:02:28Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Extractors output pseudorandom values by definition. The implicit assumption here is that the MHF does not reduce the computational entropy of y, a reasonable assumption for a MHF (one can add a remark on this in the security considerations section). We can keep the current specification (*). Moreover, the second option violates a principle of extractors that the salt should be independent of the IKM. \r\n(*) I prefer the convention that when there is no salt, HKDF is called with salt=0 not salt=\"\". Can you change that (also in other cases where \"\" is used as salt)?",
          "createdAt": "2021-08-10T18:42:34Z",
          "updatedAt": "2021-08-10T18:42:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Extractors output pseudorandom values by definition. The implicit assumption here is that the MHF does not reduce the computational entropy of y, a reasonable assumption for a MHF (one can add a remark on this in the security considerations section). We can keep the current specification (). Moreover, the second option violates a principle of extractors that the salt should be independent of the IKM.\r\n\r\nWell, imagine the following Harden variant:\r\n\r\n```\r\nHarden(x, params) = 0^31 || SHA256(x)[0] // LSB of the hash\r\n```\r\n\r\nAs written in the spec, this would satisfy the definition of Harden, but clearly is not great. Do we need to be more specific about what Harden outputs here, with respect to its inputs? (We can also clarify that Extract does not reduce the entropy of its inputs, but that seems separate to me.)\r\n\r\n> () I prefer the convention that when there is no salt, HKDF is called with salt=0 not salt=\"\". Can you change that (also in other cases where \"\" is used as salt)?\r\n\r\nsalt=\"\" is convention adopted by RFC8446 and other documents, so I think we should keep it as-is. ",
          "createdAt": "2021-08-10T18:49:07Z",
          "updatedAt": "2021-08-10T18:49:07Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "We can either require that Harden(x, params) does not reduce entropy of x, or (to be on the safe side) define \r\n\r\nrandomized_pwd = Extract(\"\", y || Harden(y, params)))\r\nwhere || stands for concatenation\r\n\r\nas for salt=\"\", I was confused by TLS 1.3 that uses the symbol 0 to denote \"\".\r\nHow does \"\" look as a string of bits when input into the HMAC key?",
          "createdAt": "2021-08-10T19:10:11Z",
          "updatedAt": "2021-08-10T19:10:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Augmenting the call to Extract seems simpler to me, so let's go with that \ud83d\udc4d \r\n\r\n> How does \"\" look as a string of bits when input into the HMAC key?\r\n\r\nThis is the same as 0 (or NULL or the empty string).",
          "createdAt": "2021-08-10T21:02:10Z",
          "updatedAt": "2021-08-10T21:02:42Z"
        }
      ]
    },
    {
      "number": 246,
      "id": "MDU6SXNzdWU5NjUyMjk4ODk=",
      "title": "Configuration agreement",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/246",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The configurations section is the first place where client/server agreement on configurations is noted. We should promote this to an earlier part of the draft, and make clear that configuration negotiation is _not_ part of the protocol. (That would be done by any wrapper protocol, for example.)",
      "createdAt": "2021-08-10T18:23:07Z",
      "updatedAt": "2021-09-23T12:02:10Z",
      "closedAt": "2021-09-23T12:02:10Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Should it be negotiated, though ?\n\nWe also state that the configuration should strictly be the same throughout the application lifecycle.",
          "createdAt": "2021-08-11T10:52:28Z",
          "updatedAt": "2021-08-11T10:52:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should it be negotiated, though\r\n\r\nI don't believe so. That would add a tremendous amount of complexity to the protocol. ",
          "createdAt": "2021-08-11T12:37:08Z",
          "updatedAt": "2021-08-11T12:37:08Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed :)",
          "createdAt": "2021-08-11T13:14:40Z",
          "updatedAt": "2021-08-11T13:14:40Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I missed the \"_not_\" part on my first read \ud83e\udd26\u200d\u2642\ufe0f\n\nBut yes, we can emphasize earlier in the document that even a wrapper protocol should not implement negotiation on login.",
          "createdAt": "2021-08-11T13:17:44Z",
          "updatedAt": "2021-08-11T13:17:44Z"
        }
      ]
    },
    {
      "number": 247,
      "id": "MDU6SXNzdWU5NjUyMzA1MTc=",
      "title": "Confusion between \"credential identifier\" and \"client identifier\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/247",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "These are so very similar. We need to better describe their differences. \r\n\r\ncc @kevinlewi ",
      "createdAt": "2021-08-10T18:23:44Z",
      "updatedAt": "2021-08-26T22:48:13Z",
      "closedAt": "2021-08-26T22:48:13Z",
      "comments": []
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWU5NjUyMzE1ODY=",
      "title": "Client public key leakage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/248",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should the client public key leak to the server (on the wire) during the AKE protocol? Should we allow this to happen, or should it not be permissible with any AKE? \r\n\r\ncc @hugokraw ",
      "createdAt": "2021-08-10T18:24:48Z",
      "updatedAt": "2021-08-25T00:31:24Z",
      "closedAt": "2021-08-25T00:31:24Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am confused. Doesn't the server store the client's public key? Why would this be a \"leak\"? Anyway, the client's public key does not require secrecy protection at all (from the server or anyone else), except for privacy considerations. But I am probably misinterpreting your question",
          "createdAt": "2021-08-10T18:30:24Z",
          "updatedAt": "2021-08-10T18:30:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Doesn't the server store the client's public key? \r\n\r\nIndeed! However, consider the case where an attacker is masquerading as the server during authentication. (The attacker doesn't have the public key -- only the envelope, which it can get directly from the real server.) Would it be a problem if the AKE forced the either client or server to send, over the wire, the public key? Can the adversary use this in any way to confirm a password guess? \r\n\r\nAs an example, if the OPRF would be honestly evaluated by the real server and client, and the client revealed its public key, would this allow faster dictionary attacks by the adversary? I don't immediately see how, but it seems an interesting edge case?",
          "createdAt": "2021-08-10T18:44:46Z",
          "updatedAt": "2021-08-10T18:44:46Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not a problem. Remember that OPAQUE is the composition of an OPRF and *any* (secure) AKE. So if the AKE is secure when the public key is completely public, then OPAQUE is secure also when the public key is disclosed to anyone. This is the case for all AKEs we are dealing with: 3DH, HMQV, SIGMA and any \"public key AKE\" where a public key is... well... public.",
          "createdAt": "2021-08-10T18:53:40Z",
          "updatedAt": "2021-08-10T18:53:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "ACK -- closing!",
          "createdAt": "2021-08-25T00:31:24Z",
          "updatedAt": "2021-08-25T00:31:24Z"
        }
      ]
    },
    {
      "number": 249,
      "id": "MDU6SXNzdWU5NjkzODI1NTc=",
      "title": "Internal mode private key seed length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/249",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The seed used to derive the private key in internal mode is currently `Nsk`:\r\n\r\n```\r\nseed = Expand(randomized_pwd, concat(nonce, \"PrivateKey\"), Nsk)\r\n```\r\n\r\nIf `Nsk` is large for the AKE, then this seed may be quite large, too. We probably don't need anything beyond 32 bytes of randomness here, regardless of the AKE protocol. Perhaps we drop `Nsk` here and just use a constant? Or introduce another constant instead?\r\n\r\nThe same question might also be asked of the `ikm` derivation:\r\n\r\n```\r\nikm = Expand(oprf_seed, concat(credential_identifier, \"OprfKey\"), Nok)\r\n```\r\n\r\ncc @hugokraw ",
      "createdAt": "2021-08-12T18:59:19Z",
      "updatedAt": "2021-09-23T12:02:18Z",
      "closedAt": "2021-09-23T12:02:18Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't there a hash-to-curve requirement for this input length ?",
          "createdAt": "2021-08-12T19:31:51Z",
          "updatedAt": "2021-08-12T19:31:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "These are both hashing to scalars (currently), but even if that were the case, it's possible for other AKEs to _not_ use hash-to-curve stuff. ",
          "createdAt": "2021-08-12T20:16:10Z",
          "updatedAt": "2021-08-12T20:16:10Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "You can define the seed to always be 256 bits which has sufficient entropy for any cryptographic use. The DeriveAuthKeyPair function will need to deal with the fact that the length is \"only\" 256 bits. In particular, if the procedure requires more bits than that, it will first stretch the seed to a longer string using some PRG or PRF. (Does that answer the question?)",
          "createdAt": "2021-08-12T20:53:36Z",
          "updatedAt": "2021-08-12T20:53:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that matches my suggestion in the issue description. I'd be fine with just pinning 32B here. @kevinlewi, thoughts?",
          "createdAt": "2021-08-12T21:17:05Z",
          "updatedAt": "2021-08-12T21:17:05Z"
        }
      ]
    },
    {
      "number": 251,
      "id": "MDU6SXNzdWU5NzMxMzgxNTg=",
      "title": "Consider dropping external mode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/251",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In #250, the rationale of external mode was called into question. Here's a list of the tradeoffs currently identified.\r\n\r\nPros:\r\n- Allows external key generation e.g. for compliance reasons // is this an actual use case we care about?\r\n- Punts deterministic key generation specification to application\r\n- Faster private key recovery (XOR-based decryption instead of hash-to-scalar)\r\n\r\nCons:\r\n- Larger API surface (possibility for misuse or abuse, harder to test, etc)\r\n- Higher bandwidth for RegistrationRecords (more data encrypted)\r\n- Allows for the possibility of applications to re-use private keys across protocols\r\n- Possibly requires domain separation across modes (not currently in the spec, but might be a consideration)\r\n\r\nIt would seem that removing external mode is best. The added complexity does not seem to be justified by the expected use case.",
      "createdAt": "2021-08-17T23:30:33Z",
      "updatedAt": "2021-08-25T19:14:57Z",
      "closedAt": "2021-08-25T19:14:57Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I have one consideration that you should probably ignore but it is very useful when writing about OPAQUE in general (it is not a completely stupid consideration because being able to convey the idea behind the protocol in a simple way is a good property of a protocol). It is very easy and appealing to describe the protocol as choosing keys for the particular AKE and inserting them (user's private key and server's public key) in an \"envelope protect with the password\". It is more intuitive and compact than sending the server's public in an authenticated envelope and deriving the user's key from the output of the OPRF computed on the password. Or maybe it is just how it seats in my mind. As said, feel free to ignore...",
          "createdAt": "2021-08-18T19:50:34Z",
          "updatedAt": "2021-08-18T19:50:34Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "PS: Maybe it is not so much about the easiness to explain but about the \"elegance\" of the design/description (where elegance is a highly subjective notion)\r\n",
          "createdAt": "2021-08-18T19:51:31Z",
          "updatedAt": "2021-08-18T19:51:31Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, it is indeed elegant, and also very _smart_ as it is very simple. This and the usefulness of this mechanism is undoubted, even in the light of an alternative mode with quasi opposite pros and cons.\n\nMay I suggest a _slightly_ different definition of OPAQUE (_vs._ how we currently describe it):\nLet OPAQUE be a compilation of any OPRF -> Key Recovery Mechanism -> AKE.\n\nTechnically, saying that OPAQUE = OPRF + AKE is not completely true, as the OPRF output is not directly used in the AKE. The _key_ to make them work together is that proxy, that transforms the OPRF output into an AKE input. This more formal definition allows different implementations with their own pros/cons.\n\nJust like setting for 3DH in _this_ specification, setting for the _internal mode_ here doesn't ditch other key recovery mechanisms to be defined in other, _future_, specifications, if desired.\n\nFrom a more practical point of view, I believe that users of OPAQUE (i.e. developers that will integrate it into their product, services, etc.) will probably look for a more hassle free approach and might be willing to accept that new keys are used (key rotation _vs._ the need to import _old_ keys).\nAnother argument is: if the service provider already has the private key of their user(s), it undermines the very point of the PAKE (the secret never leaves the client). If the client already has that secret private key then they might not even need a PAKE (the client only knows a password), and would just use the AKE directly.",
          "createdAt": "2021-08-18T22:22:14Z",
          "updatedAt": "2021-08-18T22:22:14Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "In other words: upgrading an existing system to OPAQUE seems to make sense only if it's password-based and there are no existing keys. OPAQUE is a system to authenticate through the recovery of asymmetric keys a user doesn't have, using only a password the user has. If users already have their keys then they don't need to recover them, and thus don't need OPAQUE.\r\n\r\nAny thoughts? Please let me know if I'm missing something :)",
          "createdAt": "2021-08-21T01:12:35Z",
          "updatedAt": "2021-08-21T01:13:06Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Daniel's comment, in particular that OPAQUE is not just OPRF+AKE but has the key recovery (now modeled through the envelope), and the latter can have different instantiations. The OPRF+AKE is used as a more intuitive description but definitely inaccurate. \r\n\r\n> If users already have their keys then they don't need to recover them, and thus don't need OPAQUE.\r\n\r\nThis is true although I can see a \"hybrid\" situation where the user has a private key stored in one device but wants to be able to login from a different, less secure one in which the key is not stored.\r\n",
          "createdAt": "2021-08-21T16:14:24Z",
          "updatedAt": "2021-08-21T16:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Dropped, but noted as a future extension point in the appendix as part of #255.",
          "createdAt": "2021-08-25T19:14:57Z",
          "updatedAt": "2021-08-25T19:14:57Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "MDU6SXNzdWU5NzM5NDkzODE=",
      "title": "Masking key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/252",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Can the server derive this, rather than having the client upload it in RegistrationUpload?",
      "createdAt": "2021-08-18T18:34:25Z",
      "updatedAt": "2021-08-18T18:35:33Z",
      "closedAt": "2021-08-18T18:35:33Z",
      "comments": []
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWU5NzM5NTE4NjI=",
      "title": "Promote discussion of client enumeration attacks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/253",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "next-version"
      ],
      "body": "We don't discuss this until we get to CreateCredentialResponse, so it comes out of nowhere. Let's see if we can bubble this up to the intro or protocol overview.",
      "createdAt": "2021-08-18T18:38:06Z",
      "updatedAt": "2022-02-03T17:17:02Z",
      "closedAt": "2022-02-03T17:17:02Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I might have remarked on this already but the definition for the masking key as  \"A key used by the server to preserve confidentiality of the envelope during login.\" may create confusion as it seems to imply that this is necessary for the security of the protocol. It is, as the name says, a masking technique applicable only to counter enumeration attacks and independent of the security of the protocol. This needs to be clarified and the definition should reflect this. (Otherwise, I will confront years of confusion and explanations in IETF lists and others :-)\r\n\r\nRelated to user enumeration and how critical it is for applications: There is an obvious opportunity for enumeration via \"forgot password\" in current practice and I see that it is common not to defend against it - this is an this example from Macy's:   \"The email address you entered doesn't match any account. Check the spelling or try a different email.\"  Are people taking enumeration seriously enough? Note that defending in this case require the protection against timing attacks, etc. that are not easy in this case either. See https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html.  \r\nYou may want to comment when talking about measure to avoid timing attacks that this is similar to what happens in today's systems at least when dealing with password resets. \r\n\r\nIn Section 6.1.2.2 where it says:\r\n   It is RECOMMENDED that a fake client record is created once (e.g. as\r\n   the first user record of the application) ...\r\nI wasn't sure at first if this recommendation is per fake user or one record used with all fake users. Of course you mean the latter but I would make the text more clear about this.\r\n\r\nAlso, it would be good if there was a way to highlight the condition \"if client enumeration prevention is desired,\" in the text (boldface?).\r\n\r\nIn 10.8, it says \"OPAQUE prevents these [enumeration] attacks during the authentication flow.\"  OPAQUE does not prevent them. It is up to the server to do so by following the explanations in 10.8. The only thing OPAQUE does is to mask the envelope as an anti-enumeration measure. The rest are optional server implementation measures. \r\n\r\nAre there any other specifications that are only needed to protect against enumeration attacks?",
          "createdAt": "2021-09-07T13:42:55Z",
          "updatedAt": "2021-09-07T13:42:55Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding \"Forgot password\" measures, it's bad practice to throw an error back to the client saying the account doesn't exist. An easy way to avoid this problem is, in every case, returning \"An email to reset the password was sent to abc@mail if an account for it exists\", and then only send a mail if the e-mail address has been registered.\n\nNote that websites that heavily rely on the security of the users's email provider might as well completely bypass passwords and use magic links instead. I think Medium does it.",
          "createdAt": "2021-09-07T16:04:37Z",
          "updatedAt": "2021-09-07T16:04:37Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that what you suggest is the right way to address this issue. I was wondering if the fact that they don't do it means that they don't care too much about the attack. Also, as the link I included explains, you have to be careful about timing attacks in that solution too.",
          "createdAt": "2021-09-07T16:27:51Z",
          "updatedAt": "2021-09-07T16:27:51Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "The impact of user enumeration varies greatly from one service to another. I suppose every online service estimates their threat model as they seem fit, and always according to their knowledge and capabilities. I wouldn't know whether this particular one does.\n\nI think few online service do everything perfectly according to best practices. As usual it boils down to perceived need, security culture, and willingness to invest.\n\nAs of the timing attack, it may be interesting to mention this, indeed. And it makes me wonder: how much security considerations should we add to the document ? Could we outsource it and add a link to your document instead ?\n\nWhere the barrier between what security should be addressed in the spec and what is application security outside of OPAQUE is an interesting one.",
          "createdAt": "2021-09-07T16:58:29Z",
          "updatedAt": "2021-09-07T16:58:29Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft mentions timing attacks in  section 10.8. I believe that the spec needs to address enumeration attacks and describe the defenses against it. My only question is whether it has to build-in these defenses as part of the default protocol or as an  optional extension also defined in the current document. The current spec takes the former approach defining the masking_key and the mechanism to xor the envelope with a one-time pad derived from masking_key. My preferred approach would be to define the derivation of masking_key as part of the mandatory spec but leave its use as optional (as we do with the export_key). Then, specify, as an *optional* mechanism, how to use masking_key  to address enumeration attacks (namely, the    derivation of credential_response_pad and  the generation of masked_response). The reason for this separation into mandatory and optional is to avoid the extra *conceptual* complexity of credential_response_pad derivation and response masking for those that do not need it. Also, to make it clear that masking of the envelope does not have a security function other than protecting against enumeration attacks.\r\nBut I do not see these issues as essential and whatever you guys decide is fine with me. But in either case, we need to say clearly that masking_key and its use is only needed against enumeration attacks, and not to refer to this masking as \"encryption\" or \"confidentiality\" as we do now in some of the text.\r\n",
          "createdAt": "2021-09-07T22:12:54Z",
          "updatedAt": "2021-09-07T22:12:54Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a great idea and totally agree we should take this approach!",
          "createdAt": "2021-09-08T12:42:30Z",
          "updatedAt": "2021-09-08T12:42:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think think the use of masking_key should be optional. The protocol is already complicated enough as-is, and forcing another (non-essential) decision onto implementers seems like it'll yield undesirable outcomes. Making it mandatory, as is the case now, removes that decision point and allows for safer server-side implementations.\r\n\r\n>  we need to say clearly that masking_key and its use is only needed against enumeration attacks, and not to refer to this masking as \"encryption\" or \"confidentiality\" as we do now in some of the text.\r\n\r\nYeah, this is a fine change to make. I'll cover that in the PR which addresses this issue.",
          "createdAt": "2021-09-23T12:24:05Z",
          "updatedAt": "2021-09-23T12:24:50Z"
        }
      ]
    },
    {
      "number": 254,
      "id": "MDU6SXNzdWU5NzU5NzY3ODI=",
      "title": "Abstract the login messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/254",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Currently, login messages look like that\r\n```\r\nKEx {\r\n  struct Credential_Something;\r\n  ake_thing_a;\r\n  ake_thing_b;\r\n  etc.\r\n}\r\n```\r\n\r\nFor the sake of abstraction and modularity, I suggest we define these without AKE specificities. Like this:\r\n\r\n```\r\nKEx {\r\n  struct Credential_Something;\r\n  struct AKE_things;\r\n}\r\n```\r\n\r\nFrom an editorial point of view, we can therefore define all the external OPAQUE components outside any specification (OPRF + internal/external mode + AKE in this case)",
      "createdAt": "2021-08-20T23:20:19Z",
      "updatedAt": "2021-09-23T00:18:00Z",
      "closedAt": "2021-09-23T00:18:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare can we close this?",
          "createdAt": "2021-09-22T22:29:11Z",
          "updatedAt": "2021-09-22T22:29:11Z"
        }
      ]
    },
    {
      "number": 256,
      "id": "MDU6SXNzdWU5NzYxOTUzMDc=",
      "title": "Document possible errors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/256",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood",
        "bytemare"
      ],
      "labels": [],
      "body": "It would be very useful for implementers if we provide a minimal set of known errors that can happen during protocol execution, and what the suggested reaction to each error should be.",
      "createdAt": "2021-08-21T18:32:57Z",
      "updatedAt": "2022-02-07T15:30:57Z",
      "closedAt": "2022-02-07T15:30:57Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's a list of errors I return in my current implementation that can happen when messages are received (I left out app specific errors like \"input private key is invalid\" or \"invalid OPRF seed length\" etc.)\r\n\r\n**Message deserialization errors**\r\n| Name | Party | Messages | Reason |\r\n| --------------- | --------------- | --------------- | --------------- |\r\n| errInvalidMessageLength | All | All | The message length is invalid for the configuration. |\r\n| errInvalidBlindedData | Server | RegistrationRequest, Ke1 | Blinded data is an invalid point |\r\n| errInvalidEvaluatedData | Client | RegistrationResponse, Ke2 | Invalid OPRF evaluation point |\r\n| errInvalidServerPK | Client | RegistrationResponse | Invalid server public key |\r\n| errInvalidClientPK | Server | Record | Invalid client public key |\r\n| errInvalidClientEPK | Server | Ke1 | Invalid ephemeral client public key |\r\n| errInvalidServerEPK | Client | Ke2 | Invalid ephemeral server public key |\r\n\r\nn.b. each message has a fixed and predetermined size depending on the configuration. So this includes the envelope length check in the final registration message.\r\n\r\n**Client errors**\r\n| Name | Stage | Reason |\r\n| --------------- | --------------- | --------------- |\r\n| errInvalidMaskedLength | ClientFinish | The length of the masked response is not = point length + envelope size |\r\n| errInvalidPKS| ClientFinish | Invalid server public key in unmasked response |\r\n| errEnvelopeInvalidMac | ClientFinish | Invalid envelope authentication tag |\r\n| errAkeInvalidServerMac | ClientFinish | AKE : invalid server MAC |\r\n\r\n**Server errors**\r\n| Name | Stage | Reason |\r\n| --------------- | --------------- | --------------- |\r\n| ErrAkeInvalidClientMac | ServerFinish | AKE : invalid client MAC |\r\n",
          "createdAt": "2022-01-09T23:38:44Z",
          "updatedAt": "2022-01-09T23:38:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent start. Can you please take this issue and turn this list of errors into a PR? [HPKE](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-12#section-8.2) has a good example for what this looks like. I think certain errors like \"invalid message length\" don't need to be generated inline, as they can be handled before functions are invoked, whereas other errors like \"invalid MAC\" must necessarily be generated inline (where the MAC check fails).",
          "createdAt": "2022-01-10T14:57:57Z",
          "updatedAt": "2022-01-10T14:57:57Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @chris-wood! Would you like the same syntax as in HPKE, or can we have a \"tabled\" approach, like here?",
          "createdAt": "2022-01-15T23:38:45Z",
          "updatedAt": "2022-01-15T23:38:45Z"
        }
      ]
    },
    {
      "number": 257,
      "id": "MDU6SXNzdWU5Nzg1NTQ1Njc=",
      "title": "Discussion around having AKE keys in an HSM",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/257",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial"
      ],
      "body": "#238 mentioned a use case of using X25519 AKE server private keys in an HSM.\r\n\r\nWe could mention this in the Security Considerations section.",
      "createdAt": "2021-08-24T23:13:57Z",
      "updatedAt": "2021-10-05T13:23:56Z",
      "closedAt": "2021-10-05T13:23:56Z",
      "comments": []
    },
    {
      "number": 258,
      "id": "MDU6SXNzdWU5ODAzOTI1OTk=",
      "title": "ASCII Flowcharts",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/258",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial",
        "optional"
      ],
      "body": "The protocol's complexity has reached a point where it gets easy to be confused. Flowcharts of components and the complete protocol could help the new reader with a quick overview and better understanding.\r\n\r\n- [x] Registration - Client side\r\n- [x] Registration - Server side\r\n- [x] Login - Client side\r\n- [x] Login - Server",
      "createdAt": "2021-08-26T15:43:40Z",
      "updatedAt": "2023-03-20T23:22:11Z",
      "closedAt": "2023-03-20T23:22:11Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't know if specific flows for the subparts are necessary, the storage and recovery functions. They are described above and could benefit from a visual representation.",
          "createdAt": "2021-10-04T10:11:30Z",
          "updatedAt": "2021-10-04T10:11:30Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "This is my proposal for the flowcharts\r\n\r\n## Registration client\r\n\r\n```\r\n                         | ID  | Password\r\n                         |     |\r\n                         |     v\r\n                         |   +---------+\r\n                         |   | OPRF    |\r\n                         |   | Blind() |\r\n                         |   +-------+-+\r\n                         v       OPRF-1|  \r\nSend Request to server +---------+ <---+\r\n                  <--- + Request |        \r\n                       +---------+\r\n\r\nReceive Response from server\r\n        +----------+     \r\n   ---> + Response |--+--------+\r\n        +----------+  |        | OPRF-2\r\n                      |        v\r\n                      |     +-----------+\r\n                      |     | OPRF      |\r\n                      |     | Unblind() |\r\n                      |     +----+------+\r\n                      |         |\r\n                      |         | OPRF\r\n                      |         v Output\r\n                      |     +----------+\r\n                      |     | Harden() |\r\n                      |     +---+------+\r\n                      |       |\r\n                      |       | randomized_pwd\r\n                      |       v\r\n                      | pks  +---------+\r\n                      +----> | Store() |\r\n                             ++-------++\r\n                              |       |\r\n                          pkc |       |\r\n                     envelope |       |\r\n                  masking_key |       |\r\n                              |       |\r\nSend Record to server         v       |\r\n                        +--------+    |\r\n                  <---- + Record |    |\r\n                        +--------+    |\r\n                                      v\r\n                                 Export Key\r\n```\r\n\r\n## Registration server\r\n\r\n```                            \r\n| Server Public Key       Receive Request from client\r\n|                                 +-----+     \r\n|        +------------------------+ KE1 | <---\r\n|        |                    |   +-----+\r\n|        | ID                 | OPRF-1     \r\n|        v                    |          \r\n|  +-------------+            |          \r\n|  | User Lookup |            |          \r\n|  +-+-----------+            |\r\n|    |                        |\r\n|    | oprf_seed              |\r\n|    | credential_identifier  |\r\n|    |                        v\r\n|    |                  +-----------+    \r\n|    +----------------> | OPRF      |    \r\n|                       | Evaluate()|    \r\n|                       +-----+-----+\r\n|                             |\r\n|                             | OPRF-2  \r\n|                             v          \r\n|                     +----------+ Send Response to client\r\n+-------------------> | Response + ---> \r\n                      +----------+\r\n\r\n             Receive and store Record from client\r\n                      +--------+     \r\n                      + Record | <---\r\n                      +--------+\r\n```\r\n\r\n## Login client\r\n\r\n```\r\n                     | ID     | Password\r\n                     |        |\r\n                     |        v\r\n                     |   +---------+ +---------+\r\n                     |   | OPRF    | | AKE     |\r\n                     |   | Blind() | | Start() |\r\n                     |   +-------+-+ +----+----+\r\n                     v       OPRF-1|        |\r\nSend KE1 to server   +-----+ <-----+        |\r\n              <----- + KE1 |         AKE-1  |\r\n                     +-----+ <--------------+\r\n\r\nReceive KE2 from server\r\n          +-----+     \r\n     ---> + KE2 |---+---+-----------------+\r\n          +-----+   |   |                 | OPRF-2\r\n                    |   |                 v\r\n                    |   |            +-----------+\r\n                    |   |            | OPRF      |\r\n                    |   |            | Unblind() |\r\n                    |   | Masking    +----+------+\r\n                    |   | - nonce         |\r\n                    |   | - response      | OPRF output\r\n                    |   |                 v \r\n                    |   |             +----------+\r\n                    |   |             | Harden() |\r\n                    |   v             +---+------+\r\n                    | +--------+        |\r\n                    | | Unmask | <------+ randomized_pwd\r\n                    | +-+------+        |\r\n                    |   |               |\r\n                    |   | pks           |\r\n                    |   | Envelope      v\r\n                    |   +------------> +----------+\r\n                    |                  | Key      |\r\n                    | AKE-2            | Recovery |\r\n                    +--------------->  ++--------++\r\n                                         |        |\r\n                                         | skc    |\r\n                                         | pkc    |\r\n                                         v        |\r\nSend KE1 to server  +-----+   AKE-3  +----------+ |\r\n              <---- + KE3 | <--------+ AKE      | |\r\n                    +-----+          | Finish() | |\r\n                                     +-+--------+ |\r\n                                       |          |\r\n                                       v          v\r\n                                Session Key  Export Key\r\n```\r\n\r\n## Login server\r\n\r\n```                            \r\n| Private and Public Keys       Receive KE1 from client\r\n|                                             +-----+     \r\n| +----------+-----------------------+------- + KE1 | <---\r\n| |          |                       |        +-----+\r\n| | AKE-1    | ID                    | OPRF-1     \r\n| |          v                       |          \r\n| |   +-------------+                |          \r\n| |   | User Lookup |                |          \r\n| |   ++-+-+--------+                |\r\n| |    | | |                         v\r\n| |    | | | oprf_seed              +-----------+    \r\n| |    | | | credential_identifier  | OPRF      |    \r\n| |    | | +----------------------> | Evaluate()|    \r\n| |    | |                          ++----------+\r\n| |    | |                           |\r\n| |    | |                           | OPRF-2  \r\n| |    | |                           v          \r\n| |    | | Envelope         +------------+  \r\n| |    | +----------------> | Credential |  \r\n| |    |                    | Response   |  \r\n| |    | pkc                +--------+---+  \r\n| |    v                        |     \r\n| |   +------------+            v    \r\n| +-> | AKE        | AKE-2   +-----+ Send KE2 to client\r\n|     | Response() +-------> | KE2 + --->\r\n+---> +------------+         +-----+  \r\n                                    \r\n                                Receive KE3 from client\r\n           +---------+      +-----+     \r\n           | AKE     | <--- + KE3 | <---\r\n           | Finish()|      +-----+\r\n           +----+----+              \r\n                |                   \r\n                v                   \r\n         Session Key\r\n```\r\n\r\n",
          "createdAt": "2021-10-13T16:54:39Z",
          "updatedAt": "2021-10-13T16:54:39Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed with @kevinlewi, we should probably add these at a later stage when we feel we reached something stable, so as to not have to update these graphs if components evolve.",
          "createdAt": "2022-04-05T21:31:19Z",
          "updatedAt": "2022-04-05T21:31:19Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion, we decided to not add the flowcharts.",
          "createdAt": "2023-03-20T23:22:11Z",
          "updatedAt": "2023-03-20T23:22:11Z"
        }
      ]
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWU5ODMwNzc4ODY=",
      "title": "Add note on security consideration on server-side online guessing attacks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/264",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "We should add a remark about the fact that online guessing attacks (against any Asymmetric PAKE) can be done from the client side and from the server side.",
      "createdAt": "2021-08-30T18:27:27Z",
      "updatedAt": "2021-09-30T22:44:38Z",
      "closedAt": "2021-09-30T22:44:38Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, we could consider adding as a deployment consideration the ability to incorporate the client identity alongside the password to be input to the OPRF. This provides client-side entropy, which in the event that a client is interacting with a malicious server, could be beneficial.",
          "createdAt": "2021-08-31T17:43:47Z",
          "updatedAt": "2021-08-31T17:43:47Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Integrating the ID with the password as input results in having to re-register if the ID changes. This can be done programmatically though, and I don't think it's a big problem.",
          "createdAt": "2021-09-08T23:09:41Z",
          "updatedAt": "2021-09-08T23:09:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi can you please send a PR for this?",
          "createdAt": "2021-09-22T22:30:08Z",
          "updatedAt": "2021-09-22T22:30:08Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWU5OTExMTU0OTA=",
      "title": "Security Recommendation: dual CSPRNG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/266",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The TLS 1.3 RFC ([appendix C.1](https://datatracker.ietf.org/doc/html/rfc8446#appendix-C.1)) suggests using separate CSPRNGs to generate public and private values.\r\n\r\nIt could be interesting to add a similar recommendation.\r\n\r\nIn OPAQUE, I think the only public values are nonces (public keys are derived from private keys, so they don't count). Is there anything else?",
      "createdAt": "2021-09-08T13:03:17Z",
      "updatedAt": "2021-10-06T08:43:07Z",
      "closedAt": "2021-10-06T08:43:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare will you have time for this? If not, I can do it.",
          "createdAt": "2021-09-22T22:29:35Z",
          "updatedAt": "2021-09-22T22:29:35Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Not immediately. If you'd like to do it, go for it :) ",
          "createdAt": "2021-09-23T01:23:38Z",
          "updatedAt": "2021-09-23T01:23:38Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "We already require the CSPRNG to be good, and it doesn't seem necessary to add this complexity to the spec and implementations if the main CSPRNG is not reliable.",
          "createdAt": "2021-10-06T08:43:06Z",
          "updatedAt": "2021-10-06T08:43:06Z"
        }
      ]
    },
    {
      "number": 267,
      "id": "MDU6SXNzdWU5OTExMTkzNzQ=",
      "title": "Forward secrecy in KE3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/267",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In `# Online Authenticated Key Exchange {#online-phase}` we say\r\n\r\n> , and ke3 provides explicit client authentication and\r\n> full forward security (without it, forward secrecy is only achieved against eavesdroppers,\r\n> which is insufficient for OPAQUE security).\r\n\r\nhow is the ke3 client mac contributing to forward secrecy? Or is this not relevant anymore?\r\n\r\ncc @hugokraw ",
      "createdAt": "2021-09-08T13:07:20Z",
      "updatedAt": "2021-09-08T23:05:10Z",
      "closedAt": "2021-09-08T23:05:10Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "It is relevant. Without client authentication in KE3, the attacker can choose a value x and send in the first message, the value g^x. Assume the server, sends ke2 and starts using the session_key to encrypt confidential information targeted to the client. If in the future, the attacker learns the server's private key or the password, then it learns the session key. This breaks forward secrecy. Note that the protocol with ke1 and ke2 provides forward secrecy against passive attackers (eavesdroppers) but the above shows that it does not provide FS against an active attacker. Does this make sense?",
          "createdAt": "2021-09-08T21:05:22Z",
          "updatedAt": "2021-09-08T21:05:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Very clear! I haven't thought about this scenario and was stuck with passive attacks. Thank you very much for your explanation \ud83d\ude03 ",
          "createdAt": "2021-09-08T23:05:10Z",
          "updatedAt": "2021-09-08T23:05:10Z"
        }
      ]
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWU5OTE1OTY4OTc=",
      "title": "Update spec to include Argon2 RFC",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/268",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Argon2 has now its RFC: https://www.rfc-editor.org/rfc/rfc9106.txt\r\n\r\nThe spec should be updated accordingly",
      "createdAt": "2021-09-08T23:02:00Z",
      "updatedAt": "2021-09-23T12:02:00Z",
      "closedAt": "2021-09-23T12:02:00Z",
      "comments": []
    },
    {
      "number": 281,
      "id": "I_kwDOD79ejs48ltWt",
      "title": "Update OPRF to adapt to POPRF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/281",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [],
      "body": "The (V)OPRF spec has been updated to include the POPRF findings. We should integrate these changes since this spec depends on it.\r\n\r\n_Update: POPRF merged with #282, but some questions remain_\r\n\r\n- _Does it make sense to have client-side domain separation in both POPRF (info field) and the AKE (context string)?_\r\n- _If not, what are the arguments to have it on one part or the other?_",
      "createdAt": "2021-10-05T16:14:57Z",
      "updatedAt": "2022-02-02T14:25:47Z",
      "closedAt": "2022-02-02T14:25:47Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm thinking of context binding using `info = configuration || client_id || server_id`, because that's all that's public and accessible to the client. But this needs to define a serialization of the configuration that we don't have at the moment",
          "createdAt": "2021-10-06T09:51:04Z",
          "updatedAt": "2021-10-06T09:51:04Z"
        },
        {
          "author": "gtank",
          "authorAssociation": "NONE",
          "body": "This adds an important security property for our (@celo-org's) OPAQUE use case. We can't strongly identify or authorize the users of our OPRF endpoint because it's part of an account recovery flow, so we rely on rate limiting client identities to prevent brute force attempts. As current specified OPAQUE seems to allow the following attack (which @nategraf and I spotted here and also in our current design with a different OPRF construction - it's a fundamental issue):\r\n\r\n1. Attacker submits a fraudulent request for the credential file of a target identity. They receive the encrypted blob but fail to decrypt it. This preserves the main security guarantees, since it prevents attacker access to the stored credential or a valid session key, but it still gives them a guess at the password's OPRF evaluation. We assume rate limiting stops giving OPRF outputs in response to their password guesses at some point, but the attacker can retain the encrypted credential file of the target account.\r\n\r\n2. Attacker then creates a sequence of new accounts and requests their own credential files, but continues guessing the target's password and applying the OPRF outputs to decryption attempts on the target file.\r\n\r\nBasically, since the OPRF evaluation isn't domain-separated by identity, then the target's masking key can be derived from a successful guess by anyone. You could use different keys for different users (which is how some POPRFs work anyway) but a single-key POPRF would allow us to bind the client ID to the OPRF evaluation and enforce rate limits on a per-client basis without the complexity of additional keys.",
          "createdAt": "2021-10-07T02:11:26Z",
          "updatedAt": "2021-10-07T02:11:26Z"
        },
        {
          "author": "nategraf",
          "authorAssociation": "NONE",
          "body": "As additional context, here is a spec for a POPRF API with domain separators @celo-org is currently implementing. https://github.com/celo-org/celo-proposals/blob/master/CIPs/cip-0040.md",
          "createdAt": "2021-10-08T00:43:18Z",
          "updatedAt": "2021-10-08T00:43:18Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@gtank I don't know if you saw it, but currently (without POPRF) the OPRF key is derived from a mix of a \"record_identifier\" that's unique to a client_identity, and a seed. This way, every client has its OPRF evaluated with a different key. It's not proper domain separation but still ensures keys are unique. ",
          "createdAt": "2021-10-08T16:33:25Z",
          "updatedAt": "2021-10-11T06:33:43Z"
        },
        {
          "author": "nategraf",
          "authorAssociation": "NONE",
          "body": "@bytemare Speaking for myself, I did not notice that before. It does seem to address the primary concern, of an attacker being able to use sybil accounts to make additional online guessing attempts outside any client-specific rate limit. As a tradeoff, this seems to prevent verification of OPRF evaluation against any pre-shared (e.g. in the client binary or through PKI) server public key. It also prevents threshold implementations that rely on algebraically related keys (e.g. BLS signatures). If I understand the standard correctly, these are both trade-offs that are accepted here.\r\n\r\nOn partially related note, I noticed that the public portion of the OPRF key is not shared with the client in this standard. If I understand correctly, this means that none of the OPRF evaluations can be verified, even if the OPRF protocol supports it. This is as opposed to sharing it with the client as part of the OPRF evaluation response, and possibly including it in the message over which the envelope auth tag is computed to enable pinning of the OPRF key after registration. Is my understand correct, and is this intentional?",
          "createdAt": "2021-10-11T00:24:24Z",
          "updatedAt": "2021-10-12T02:59:05Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nategraf Yes that is a correct understanding and it is intentional. The original reason being that if we used a VOPRF, then the client needs to have on-hand their password as well as the VOPRF verification key to complete the key exchange phase, whereas if we just use an OPRF (as we do today), the client only needs their password to complete the key exchange phase. I see that in your application, you might be able to pre-share the VOPRF verification key in the client binary...\r\n\r\nEdit: And as @bytemare pointed out in an offline conversation with me, note that these VOPRF verification keys are user-specific (different for each user, not quite like a single global server public key). Would it still make sense in your application to pre-share these per-client VOPRF verification keys that get established only after each client's own registration? Presumably this precludes it from being embedded in the client binary...\r\n\r\n@bytemare I think we should consider altering the context binding for the POPRF to use a fixed string, or at least not include the client_identity, since the convention we have right now is that if no client_identity is supplied, then the client's public key is used. But this needs to be established before the server registration's evaluate function, whereas the client chooses their public key one step later.",
          "createdAt": "2021-10-13T05:06:55Z",
          "updatedAt": "2021-10-13T09:57:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points by @kevinlewi and @bytemare  -- I forgot that the OPRF key is already domain separated by the (unique per user) credential identifier, so we shouldn't need to additionally include client_identifier in the POPRF metadata. \r\n\r\nThis brings us back to the drawing board. What, if anything, should go in the POPRF info string? We already have a slot for arbitrary application data (the AKE `context` string), so we shouldn't have another slot for arbitrary application data. (That seems super confusing to me.)",
          "createdAt": "2021-10-13T16:19:33Z",
          "updatedAt": "2021-10-13T16:19:33Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-reading @nategraf's comment, I think the suggestion is to ship the VOPRF public key with KE2 (e.g. under the masked response). That would mean that the client derives a bunch of things in order to recover the plaintext, to then do the VOPRF verification.\r\n\r\nIs my understanding of your suggestion correct?",
          "createdAt": "2021-10-13T23:58:48Z",
          "updatedAt": "2021-10-13T23:58:48Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest we keep this issue open to track discussions around context and domain separations strings in POPRF and AKE. \r\n\r\n- Does it make sense to have client-side domain separation in both POPRF (`info` field) and the AKE (`context` string)?\r\n- If not, what are the arguments to have it on one part or the other?\r\n\r\nLet's discuss the actual value of the POPRF info in #283.",
          "createdAt": "2021-10-14T00:18:28Z",
          "updatedAt": "2021-10-14T00:19:20Z"
        },
        {
          "author": "nategraf",
          "authorAssociation": "NONE",
          "body": "> Re-reading @nategraf's comment, I think the suggestion is to ship the VOPRF public key with KE2 (e.g. under the masked response). That would mean that the client derives a bunch of things in order to recover the plaintext, to then do the VOPRF verification.\r\n\r\nRight, that is what I was thinking of: Shipping the OPRF public key to the user with KE2 and and including it in the data over which the auth tag is calculated to ensure it remains consistent after registration. Although I can see an issue with this now in that the auth tag is only available after unmasking the record in the response. Client behavior would only be different (e.g. surfacing a \"verification error\" instead of \"incorrect password\") in a few narrow cases:\r\n1. If the OPRF response is manipulated such that it no longer verifies against the public key added to KE2, the client will detect this instead of simply failing to derive the masking key. But an attacker would also have access to modify the included public key, so its unclear why they would bother doing this.\r\n2. If the OPRF public key is malleable, then an attacker may include a public key that would consistent with the evaluation, allowing the client to unmask the response and check the auth tag, at which point they would see a failure. Again its unclear what value this is to an attacker.\r\n\r\nIn particular, if the attacker replaces the evaluation and public key in KE2 with a distinct public key and associated evaluation, the client would simply fail to derive the masking key and be unable to detect that the public key is inconsistent. As a result, this is not so valuable.\r\n\r\nAnyway. this is off topic for this issue. \ud83d\ude05 ",
          "createdAt": "2021-10-17T15:56:38Z",
          "updatedAt": "2021-10-17T15:56:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by #324.",
          "createdAt": "2022-02-02T14:25:46Z",
          "updatedAt": "2022-02-02T14:25:46Z"
        }
      ]
    },
    {
      "number": 283,
      "id": "I_kwDOD79ejs49JIF8",
      "title": "POPRF info value",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/283",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, domain separation on OPRF evaluation is done using the client's record identifier and a global seed to derive a user-specific evaluation key.\r\n\r\n(V)OPRF introduces POPRF with metadata that integrates domain separation in the API. This API allows for an `info` value for the server's evaluation function and an `info` value for the client's finalization function. These two values _can_ be different from one another and the protocol will still execute correctly, but these values must be constant across sessions to yield the same result. This last condition requires the client to possess client-specific discriminating public information that would allow proper domain separation. The `client_identity` is not currently not required to exist for the client, and can therefore be empty, which makes it a non-reliable candidate for the protocol.\r\n\r\nWhat should these values be?",
      "createdAt": "2021-10-14T00:17:03Z",
      "updatedAt": "2022-02-02T14:26:01Z",
      "closedAt": "2022-02-02T14:26:01Z",
      "comments": [
        {
          "author": "nategraf",
          "authorAssociation": "NONE",
          "body": "If I understand correctly, the public input is only needed by the server during POPRF evaluation and the client during verification. Because, as specified, the client does not have access to the (P)OPRF verification key, the client can't verify the output and so doesn't actually need the public input. Is that a fair claim? (I don't fully understand how, from a client perspective, using a POPRF without verification is different than using an OPRF with domain separated keys, as the current draft does, so I imagine I am missing something)",
          "createdAt": "2021-10-17T17:07:11Z",
          "updatedAt": "2021-10-17T17:07:11Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @nategraf,\nYes indeed, we don't use a verifiable OPRF, as we have use the envelope MAC to verify that the output is correct.\n\nPOPRF, compared to the earlier OPRF, allows public metadata to be used for domain separation, which is a desirable feature when serving multiple different clients. Until now, we did domain separation by mixing the `oprf_seed` with the `credential_identifier` to derive the client specific OPRF evaluation key `ku`. If this is something that does not come clear in the document, I'd be very interested in your feedback :)",
          "createdAt": "2021-10-18T23:04:47Z",
          "updatedAt": "2021-10-18T23:09:43Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @hugokraw,\nwith @kevinlewi, we are wondering whether the current domain separation ( i.e. `ku = hash-to-scalar(HKDF-Expand(oprf_seed, credential_identifier))`) has different security properties than the domain-separation offered by the new POPRF (i.e. use the `info` field for domain separation input), and if there would be any benefit in switching to the later. Do you have an opinion on that ?",
          "createdAt": "2021-10-18T23:19:09Z",
          "updatedAt": "2021-10-18T23:19:09Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like we agree to set the POPRF's `info` field to an app independent fixed string",
          "createdAt": "2021-10-19T10:33:04Z",
          "updatedAt": "2021-10-19T10:33:04Z"
        },
        {
          "author": "nategraf",
          "authorAssociation": "NONE",
          "body": "@bytemare my feedback is just that it is unclear why this specification, with the introduction of a POPRF, prefers to implement domain separation by deriving a domain-specific key rather than using a fixed key and implementing domain separation using the `info` field of the POPRF.\r\n\r\nConcretely, this disallows an implementation of OPAQUE from using an MPC POPRF construction built on algebraically related keys (e.g. constructions based on threshold BLS signatures).\r\n\r\n(It also disallows any extension to support verification via pre-shared public keys, although you've made it clear that this proposal has decided this is a non-goal)",
          "createdAt": "2021-10-19T23:18:30Z",
          "updatedAt": "2021-10-19T23:18:30Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nategraf The introduction of the deterministic derivation of the key from the `oprf_seed` parameter was not primarily for domain separation, but to address the \"client enumeration attacks\", where information is leaked during user re-registration. See #210, #215, for some older discussion on how we arrived to the current state today, as well as the section here (https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#client-enumeration-preventing-client-enumeration).\r\n\r\nMoving the `credential_identifier` parameter into the `info` field of the POPRF would achieve domain separation, but I don't believe it would be sufficient to address the client enumeration attacks, since that seems to require deterministic key derivation from `oprf_seed`.\r\n\r\nUnfortunately, as you pointed out, this tradeoff does preclude constructing the individual user OPRF keys in an algebraic manner.",
          "createdAt": "2021-10-20T18:15:15Z",
          "updatedAt": "2021-10-20T18:15:15Z"
        },
        {
          "author": "nategraf",
          "authorAssociation": "NONE",
          "body": "@kevinlewi reading into those issues and digging around a bit I found your PR (https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/156) where you changed the protocol to use the current deterministic key generation method in replacement of generating the keys randomly at registration or password change and persisting the generated key. Reading the previous draft, my understanding is the client enumeration risk was associated with A) changing from the default OPRF key to a fresh randomly generated one upon registration and B) changing the OPRF key when the client changes their password.\r\n\r\nIn general, the output of the OPRF depended on the blinded input (`request.data`) and a randomly generated OPRF key (`oprf_key`), which could change depending on the actions of the honest client (e.g. on registration). With the introduction of the deterministic method the output depends on the blinded input (`request.data`), `client_identifier`, and `oprf_seed`, none of which depend on the actions of the honest client. Is my understanding correct?\r\n\r\nIf my understanding is correct, I think setting the `info` field to `client_identifier` and using a fixed POPRF key (`oprf_seed`) would have the same properties. In particular, the output would depend upon the blinded input (`request.data`), `client_identifier` and `oprf_seed`. Do you think this is accurate?\r\n\r\n> Unfortunately, as you pointed out, this tradeoff does preclude constructing the individual user OPRF keys in an algebraic manner.\r\n\r\nSorry, I wasn't very clear before. I was actually referring to threshold (MPC) based solutions such as the OPRFs derived from BLS threshold signatures which use a Shamir-like DKG process to establish their keys. (Pythia's POPRF construction also may be amenable to thesholdization using the same DKG process, and that is what our team is working on now). Essentially, because this generates the (P)OPRF keys dynamically, it prevents the use of protocols since they require a (D)KG process to be run ahead-of-time. IIUC, generating the keys using a KDF applied to the `client_identifer` and `oprf_seed` as is done now also disables the use of the construction from \"[Threshold Partially-Oblivious PRFs with Applications to Key Management](https://eprint.iacr.org/2018/733)\" which also requires an ahead-of-time key setup process. Obliviously @hugokraw would be the authority on that though.\r\n\r\nThanks for taking the time to answer all my comments so far. I've definitly found it interesting and hopefully some of these comments turn out to be useful.",
          "createdAt": "2021-10-21T17:10:59Z",
          "updatedAt": "2021-10-21T17:10:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> In general, the output of the OPRF depended on the blinded input (request.data) and a randomly generated OPRF key (oprf_key), which could change depending on the actions of the honest client (e.g. on registration). With the introduction of the deterministic method the output depends on the blinded input (request.data), client_identifier, and oprf_seed, none of which depend on the actions of the honest client. Is my understanding correct?\r\n\r\nThat's correct.\r\n\r\n> If my understanding is correct, I think setting the info field to client_identifier and using a fixed POPRF key (oprf_seed) would have the same properties. In particular, the output would depend upon the blinded input (request.data), client_identifier and oprf_seed. Do you think this is accurate?\r\n\r\nGood point! After some more thought on this, I believe you are correct. In some senses it might be \"cleaner\" to incorporate `credential_identifier` in the way that you are suggesting. (Btw it is `credential_identifier` and not `client_identity` that is set this way, I am assuming that that's what you meant by `client_identifier`). I think we should double-check with @hugokraw on the security of this, but I would be in favor of making this change if it retains the same security guarantees. cc: @bytemare , @chris-wood \r\n\r\n> Sorry, I wasn't very clear before. I was actually referring to threshold (MPC) based solutions such as the OPRFs derived from BLS threshold signatures which use a Shamir-like DKG process to establish their keys. (Pythia's POPRF construction also may be amenable to thesholdization using the same DKG process, and that is what our team is working on now). Essentially, because this generates the (P)OPRF keys dynamically, it prevents the use of protocols since they require a (D)KG process to be run ahead-of-time. IIUC, generating the keys using a KDF applied to the client_identifer and oprf_seed as is done now also disables the use of the construction from \"Threshold Partially-Oblivious PRFs with Applications to Key Management\" which also requires an ahead-of-time key setup process. Obliviously @hugokraw would be the authority on that though.\r\n\r\nI see, thanks for the clarification.",
          "createdAt": "2021-10-22T21:22:47Z",
          "updatedAt": "2021-10-22T21:22:47Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not happy with the move to POPRF (or should I say that I am against it?). POPRF does not have a proof that it satisfies the UC OPRF functionality which is the basis for the proof of OPAQUE in the UC. I am not saying POPRF cannot be proven secure in that sense (I did not try) but these things are never trivial. So at this point the claim of provability of OPAQUE would be unresolved. Even if someone would adjust the proof to work with the current security definition of POPRF, it would not be in the UC which was one of the \"selling points\" in the CFRG process. (By the way, does the proof in the POPRF paper includes the non-verifiable version?). In addition, the assumptions for this POPRF are stronger and less standard than for 2HashDH.\r\nIn general, the latter is also conceptually simpler which is also an advantage (though not a decisive point). POPRF is also problematic regarding key rotation (as pointed out by the POPRF paper itself), something that applies to the use in OPAQUE.  Finally, regarding  threshold implementation, 2HashDH has a trivial implementation,  non-interactive and proactivizable. The latter element is lost when deriving individual user keys via a PRF but this is not a must in general and even in this case one gets very efficient threshold schemes when the number of servers is not very large (as in most practical cases).\r\nI hope we can revert the decision.\r\nI see that a new VOPRF draft posted today _only_ defines this POPRF. I am surprised at that decision, particularly that no such discussion took place in the WG. This would seem to *force* OPAQUE to use POPRF which, as said, I do not recommend.",
          "createdAt": "2021-10-26T18:18:23Z",
          "updatedAt": "2021-10-26T18:34:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not happy with the move to POPRF (or should I say that I am against it?). \r\n\r\nI think the latter =) This is a fine position to take, though I don't think it's a concern for the OPAQUE specification specifically because the protocol can accommodate any OPRF. I'll reply to specific points below. \r\n\r\n> POPRF does not have a proof that it satisfies the UC OPRF functionality which is the basis for the proof of OPAQUE in the UC. I am not saying POPRF cannot be proven secure in that sense (I did not try) but these things are never trivial. So at this point the claim of provability of OPAQUE would be unresolved. Even if someone would adjust the proof to work with the current security definition of POPRF, it would not be in the UC which was one of the \"selling points\" in the CFRG process. \r\n\r\nIt's true that there's no proof that the POPRF satisfies the UC OPRF functionality, but as you say, this is something that can be done. I think we (CFRG) should do that work. We're doing similar analyses for other CFRG drafts, so this is not unprecedented.\r\n\r\n> (By the way, does the proof in the POPRF paper includes the non-verifiable version?)\r\n\r\nIndeed!\r\n\r\n> In addition, the assumptions for this POPRF are stronger and less standard than for 2HashDH. In general, the latter is also conceptually simpler which is also an advantage (though not a decisive point).\r\n\r\nThis is true, though the authors have confidence in the assumptions and the reduction to ECDL. Though it's a new assumption, so our mileage may vary.\r\n\r\n> POPRF is also problematic regarding key rotation (as pointed out by the POPRF paper itself), something that applies to the use in OPAQUE. \r\n\r\nI think this may be a misunderstanding. Key management is identical in the OPRF and POPRF protocols.\r\n\r\n> Finally, regarding threshold implementation, 2HashDH has a trivial implementation, non-interactive and proactivizable. The latter element is lost when deriving individual user keys via a PRF but this is not a must in general and even in this case one gets very efficient threshold schemes when the number of servers is not very large (as in most practical cases).\r\n\r\nThis seems to be the most notable regression. However, I don't consider it to be a problem, for two reasons:\r\n\r\n1) Threshold variants of the OPRF are out of scope for the draft-irtf-cfrg-voprf, so although we don't have an easy way to threshold the POPRF, I don't think we've lost any functionality.\r\n2) OPAQUE can be configured to use any OPRF, including ones that are amenable to threshold implementations. \r\n\r\nIt's certainly possible that we could _add_ back the original 2HashDH to draft-irtf-cfrg-voprf, but that's a question for that document and less so for OPAQUE. \r\n\r\n> I see that a new VOPRF draft posted today only defines this POPRF. I am surprised at that decision, particularly that no such discussion took place in the WG. This would seem to force OPAQUE to use POPRF which, as said, I do not recommend.\r\n\r\nThis proposal was [presented](https://datatracker.ietf.org/meeting/111/materials/slides-111-cfrg-ietf111-cfrg-voprf-00.pdf) without objection during the last IETF meeting.\r\n",
          "createdAt": "2021-10-29T17:26:52Z",
          "updatedAt": "2021-10-29T17:26:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The bottom line is this: If POPRF does not have an advantage for the OPAQUE protocol (does it?), then we should keep 2HashDH as the default one. It is simpler and threshold friendly (and while POPRF has some advantage regarding verifiability, this is not needed in OPRF).  As for the general VOPRF draft, I strongly recommend it includes a full specification of 2HashDH. Not only for OPAQUE but for many other applications for which 2HashDH is a better option (simplicity, threshold, assumptions).  I also recommend that the VOPRF document includes POPRF for applications that require support for metadata values and cannot afford a per-value public verification key. I hope you can agree with this...\r\n\r\nBtw, even if threshold is out of scope for the voprf draft, it is a basis for more advanced constructions, and threshold is an important extension so supporting 2HashDH for that is important.\r\n\r\nThe one thing I am fully opposed to is to outsource the definition of the OPRF in OPAQUE to the VOPRF document and then only have POPRF in that document. ",
          "createdAt": "2021-10-29T23:06:41Z",
          "updatedAt": "2021-10-29T23:06:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The bottom line is this: If POPRF does not have an advantage for the OPAQUE protocol (does it?), then we should keep 2HashDH as the default one.\r\n\r\nI'm not sure I agree with this, because...\r\n\r\n> The one thing I am fully opposed to is to outsource the definition of the OPRF in OPAQUE to the VOPRF document and then only have POPRF in that document.\r\n\r\nOPAQUE depends on the VOPRF specification. We shouldn't be defining an OPRF _just_ for the purposes of OPAQUE. The purpose of draft-irtf-cfrg-opaque is to be maximally useful for all use cases, of which OPAQUE is one. So that means maybe adding the 2HashDH OPRF back to that document, all for the purposes of aiding threshold deployments. Right now, that doesn't seem like sufficient justification to have two constructions with fundamentally different properties under the same abstraction. We _could_ add back 2HashDH under a different abstraction in draft-irtf-cfrg-voprf. That would just widen the scope of that document, though, which isn't harmful.\r\n\r\nAll that said, I think the simplest and most pragmatic thing to do is just keep the POPRF. But I think a reasonable compromise is to support both OPRF and POPRF in draft-irtf-cfrg-voprf, under _separate_ abstractions. We can discuss this during IETF 112.\r\n\r\n> Btw, even if threshold is out of scope for the voprf draft, it is a basis for more advanced constructions, and threshold is an important extension so supporting 2HashDH for that is important.\r\n\r\nNo disagreement there! I'm simply noting that threshold implementations were not in scope for that specification. We can always change that though. =)",
          "createdAt": "2021-10-29T23:19:43Z",
          "updatedAt": "2021-10-29T23:19:43Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd say that if you end up driving people to implement OPAQUE with POPRF (*) you would have made a disservice to these implementers. It has no benefit over 2HashDH for the practice of OPAQUE and a serious barrier for threshold implementations (\"not in scope\" now, but I hope we will see more of them in the future).\r\n\r\n(*) This is exactly what you would be doing if  you defined the VOPRF with POPRF only, and define OPAQUE only with hooks to VOPRF.\r\n",
          "createdAt": "2021-10-29T23:55:05Z",
          "updatedAt": "2021-10-29T23:55:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we've written the OPAQUE spec such that any OPRF can be used, so there is no restriction to POPRF. For example, if someone wants to use a future PQ OPRF, they can do so with no substantial OPAQUE changes.",
          "createdAt": "2021-10-30T00:57:02Z",
          "updatedAt": "2021-10-30T00:57:56Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that in the future people can choose to use other OPRFs, but right now, if you define the OPRF with VOPRF-draft hooks they will use whatever is defined there. And if  what is defines there is only POPRF, that's what they will use. I do not recommend it.",
          "createdAt": "2021-10-30T03:49:45Z",
          "updatedAt": "2021-10-30T03:49:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree that in the future people can choose to use other OPRFs, but right now, if you define the OPRF with VOPRF-draft hooks they will use whatever is defined there.\n\nThe OPRF dependency isn't defined this way -- it's meant to accommodate any suitable OPRF, specifically so one can choose to use an OPRF that suits their needs. ",
          "createdAt": "2021-10-30T12:06:56Z",
          "updatedAt": "2021-10-30T12:06:56Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Where are implementers supposed to get the specification of 2HashDH if they wanted to use it given its benefits if it is not part of the VOPRF spec? ",
          "createdAt": "2021-10-30T15:42:28Z",
          "updatedAt": "2021-10-30T15:42:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Where are implementers supposed to get the specification of 2HashDH if they wanted to use it given its benefits if it is not part of the VOPRF spec? \n\nProbably in the same spec which describes how to thresholdize 2HashDH (which doesn't exist). We could write one, though, or add it to the existing doc. ",
          "createdAt": "2021-10-30T17:48:50Z",
          "updatedAt": "2021-10-30T17:48:50Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I vote for the latter: Add it to the existing doc, namely, the voprf draft. Writing a new one would postpone it unnecessarily and, frankly, in my opinion, it makes no sense to only have POPRF in a basic OPRF document.  Btw, threshold is a dimension where 2HashDH is better than POPRF but I do not see why one would use POPRF in any setting where 2HashDH suffices.\r\n\r\nBtw, one can interpret my insistence as pushing \"my own stuff\". I hope you understand this is a sincere opinion based on technical stuff, particularly as this is NOT my own stuff. It was invented by Chaum 30 years ago. Also, I think the POPRF work is excellent and I am happy to have a partial OPRF which is non-pairing based, and happy that the voprf draft will define it for those that need a partial OPRF. I just don't think that POPRF needs to be the one size that fits all, in prticular, not the best fit with OPRF.",
          "createdAt": "2021-10-31T15:19:48Z",
          "updatedAt": "2021-10-31T15:19:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "A POPRF with a fixed info string is functionally an OPRF (ignoring threshold implementations), so it is redundant to add both to the same doc. The question I think we're asking here is whether we need to specify a standard version of a threshold OPRF. (As of now, I don't think the benefits of a threshold variant warrant inclusion in the existing doc.)",
          "createdAt": "2021-10-31T18:10:06Z",
          "updatedAt": "2021-10-31T18:26:36Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Functionally speaking, at least in its basic form, POPRF is functionally equivalent to 2HashDH, but formally speaking, we do not have a proof of OPAQUE under the security definition behind POPRF as this proof relies on a UC object - which is also how the very notion of aPAKE is formalized in the analysis of OPAQUE in JKX18. If draft-voprf will have the hooks needed to implement 2HashDH then I see absolutely no reason not to include that instantiation in the document (while I see significant reason to include it).",
          "createdAt": "2021-11-01T14:28:25Z",
          "updatedAt": "2021-11-01T14:28:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> but formally speaking, we do not have a proof of OPAQUE under the security definition behind POPRF as this proof relies on a UC object \r\n\r\nRight, and this is a gap I think we can overcome, as we're doing similar analyses for other CFRG documents.\r\n\r\n> If draft-voprf will have the hooks needed to implement 2HashDH then I see absolutely no reason not to include that instantiation in the document (while I see significant reason to include it).\r\n\r\nI think it complicates the implementation story to have both in the same document, under the same API (or syntax). 2HashDH doesn't support metadata, so would one use the same syntax to describe 2HashDH as one would to describe 3HashSDHI?\r\n\r\nIt would seem reasonable to me to instead keep these syntaxes separate, and then have instantiations for both in draft-irtf-cfrg-voprf. One syntax for POPRFs implemented based on 3HashSDHI, and another for OPRFs implemented with 2HashDH. ",
          "createdAt": "2021-11-01T14:40:02Z",
          "updatedAt": "2021-11-01T14:40:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by #324.",
          "createdAt": "2022-02-02T14:26:01Z",
          "updatedAt": "2022-02-02T14:26:01Z"
        }
      ]
    },
    {
      "number": 289,
      "id": "I_kwDOD79ejs4_CuJM",
      "title": "Add a section called Setup",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/289",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just like any other protocol, there is some preparation steps that must be done (off--line) before to run a protocol.\r\n\r\nI suggest including a section called Setup, enumerating all the steps and premises required by this phase.\r\n\r\nThis was already suggested: \r\n\r\n> I feel a lack of a section called Setup, like any other protocols has.\r\n\r\n_Originally posted by @armfazh in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/286#discussion_r751954650_",
      "createdAt": "2021-11-18T18:38:57Z",
      "updatedAt": "2021-12-30T18:33:17Z",
      "closedAt": "2021-12-30T18:33:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This content is already included in the text, so what specifically is the request here?",
          "createdAt": "2021-11-18T18:54:09Z",
          "updatedAt": "2021-11-18T18:54:09Z"
        }
      ]
    },
    {
      "number": 290,
      "id": "I_kwDOD79ejs4_Cv44",
      "title": "Agree on the name of the second phase of the protocol",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/290",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The protocol has two phases Registration and Online Authentication.\r\n\r\nThe main piece of the Online Authentication phase is an Authenticated Key Exchange (AKE). but it is not the only piece.\r\n\r\nThe current title for the section explaining Online Authentication is  \"Online Authentication Key exchange\". However, I suggest the name should be \"Online Authentication\" as this section is in charge to describe not only the AKE but also how the AKE is invoked and how the state is managed. \r\n\r\n\r\n--\r\nSee more discussion at: \r\n\r\n_Originally posted by @armfazh in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/286#discussion_r751957364_",
      "createdAt": "2021-11-18T18:47:16Z",
      "updatedAt": "2022-01-10T14:06:50Z",
      "closedAt": "2022-01-10T14:06:50Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The output of the protocol is (1) a session key for both client and server, and (2) an export key for the client. I think renaming this to \"Online Authentication\" misses (1). I'm not sure of a phrase that encompasses both (1) and (2), but I agree that something more clear would be useful. ",
          "createdAt": "2021-11-18T19:10:20Z",
          "updatedAt": "2021-11-18T19:10:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may work to move Section 10.4 (https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#name-export-key-usage) right after the `Online Authenticated Key Exchange.` \r\n\r\nSo the message that the document must convey is that the output of the protocol is a session key and a secondary key that can be used by the client. Document might hint use cases for this secondary key.\r\n",
          "createdAt": "2021-11-19T00:10:23Z",
          "updatedAt": "2021-11-19T00:10:23Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "The section you're mentioning already hints at a use case for the export key. Are you saying there should be more or a different example?\r\n\r\nAlso, this section is referenced at the beginning of the Online Authenticated Key Exchange section. Does that fit with your suggestion?",
          "createdAt": "2022-01-10T00:08:31Z",
          "updatedAt": "2022-01-10T00:08:31Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The section you're mentioning already hints at a use case for the export key. Are you saying there should be more or a different example?\r\n\r\nthe example is good, but I consider it appears too late in the document.\r\n\r\n \r\n> Also, this section is referenced at the beginning of the Online Authenticated Key Exchange section. Does that fit with your suggestion?\r\n\r\nRather than making a reference, what about moving Sec 10.4 to the place where it is referenced? \r\n\r\n",
          "createdAt": "2022-01-10T06:44:21Z",
          "updatedAt": "2022-01-10T06:44:21Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, on a second thought the title seems correct.",
          "createdAt": "2022-01-10T06:44:48Z",
          "updatedAt": "2022-01-10T06:44:48Z"
        }
      ]
    },
    {
      "number": 291,
      "id": "I_kwDOD79ejs4_CwnB",
      "title": "Determine the content of client/server states during online authentication",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/291",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [
        "next-version"
      ],
      "body": "Currently the state is vaguely specified. Specification must be clearer in what is the content of the state. \r\n(this may need some minor fixes, but still needs to be addressed).\r\n\r\nRaised after:\r\n\r\n_Originally posted by @chris-wood in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/286#discussion_r751669794_",
      "createdAt": "2021-11-18T18:50:33Z",
      "updatedAt": "2022-06-05T07:47:36Z",
      "closedAt": "2022-06-05T07:47:36Z",
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, either formally specifying what the state contains, or removing at all the state structure are both good alternatives. Currently, it is specified something in between.",
          "createdAt": "2021-11-19T00:13:44Z",
          "updatedAt": "2021-11-19T00:13:44Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest we define a generic structure in the first part of the spec\r\n```\r\nstruct {\r\n  OPRFState oprf;\r\n  AKEState ake;\r\n} ClientState;\r\n```\r\n\r\nThen, for whatever is chosen for the OPRF or AKE, it must define its own `OPRFState` and `AKEState`. In a later section, where ze specify each part, we can define\r\n```\r\nstruct {\r\n  string password;\r\n  uint8 data[Nsk];\r\n} OPRFState ;\r\n```\r\n\r\nand\r\n```\r\nstruct {\r\n  uint8 client_secret[Nsk];\r\n  KE1 ke1;\r\n} AKEState ;\r\n```",
          "createdAt": "2021-11-21T01:33:59Z",
          "updatedAt": "2021-11-21T01:33:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We only need to specify the structure of protocol messages, not implementation specific structures and related state. Using standard OO (dot style) notation for this state seems most clear.",
          "createdAt": "2021-12-01T00:07:00Z",
          "updatedAt": "2021-12-01T00:07:00Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I would be in favor of removing the mentioning of these states altogether, and to just push the modification of these states into the inputs and outputs for each function. That way, each function can be seen as stateless.",
          "createdAt": "2022-04-05T21:41:24Z",
          "updatedAt": "2022-04-05T21:41:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi I think we'll find that the parameter list for these functions will grow to an unreadably large size, but it's worth removing all mentions of state to at least see how it looks!",
          "createdAt": "2022-04-05T23:07:08Z",
          "updatedAt": "2022-04-05T23:07:08Z"
        }
      ]
    },
    {
      "number": 294,
      "id": "I_kwDOD79ejs5ALio6",
      "title": "Update algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/294",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Re-hashing is sometimes practiced with traditional password hashing mechanisms. The main concern here is that when a user doesn't log-in for years, it prevents the server from updating the algorithm used to hash the password, which can only be done when the user logs in again.\r\n\r\nThe solution is usually to re-hash hashes, basically wrap hashes in another hash, on client authentication both hash's have to be performed, afterwards the hash can be updated.\r\n\r\nObviously that isn't really possible with OPAQUE, as we don't actually store a hash. The `RegistrationUpload` is secured by the `server_private_key` instead.\r\n\r\nI also noticed, that the only recommendation what to do in the event of server compromise in the draft, is to also resample the `oprf_seed`.\r\n\r\nSo I was thinking that we can kill two birds with one stone, if we can specify a mechanism to update the `RegistrationUpload` by using a new (and stronger) `server_private_key`, we have provided a mechanism to allow upgrading `RegistrationUpload` to newer algorithms and also provide a (hopefully) good response tactic if the `server_private_key` is compromised.\r\n\r\nWarning: I'm no cryptographer and only have a surface-level understanding of everything I'm talking about here!",
      "createdAt": "2021-12-10T11:54:17Z",
      "updatedAt": "2022-06-10T20:27:45Z",
      "closedAt": "2022-04-05T21:49:44Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @daxpedda, do you have a suggestion to do that?",
          "createdAt": "2021-12-18T18:48:37Z",
          "updatedAt": "2021-12-18T18:48:37Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't, but I plan to look into it.\r\n\r\nThinking about this more, we may want to open a separate issue addressing what is actually compromised and what attack vectors this would open up if the `server_private_key` or `oprf_seed` or both are compromised.",
          "createdAt": "2021-12-19T13:48:23Z",
          "updatedAt": "2021-12-19T13:48:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @hugokraw for his thoughts",
          "createdAt": "2022-01-07T13:54:01Z",
          "updatedAt": "2022-01-07T13:54:01Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this feature would be nice to have, but is almost certainly not supported by OPAQUE, since it is not as simple as \"password onion hashing\" (tacking on stronger hashing algorithms). Instead, implementers should consider a migration from an old `server_private_key` or `oprf_seed` to a newer one upon future client login, by re-running the registration protocol with the new key material.\r\n\r\nAt any rate, I believe this is outside of the scope of the specification.",
          "createdAt": "2022-04-05T21:49:44Z",
          "updatedAt": "2022-04-05T21:49:44Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't seen this before (if you ask for my feedback and I don't respond it is good to ping me...). I think that the solution in all these cases is to let the user login with the old parameters, then reset the password and re-run registration with the new keys and/or mechanisms. If the old parameters are not available or compromised one can reset the password without a login.  Measures against user enumeration may be required for this process too.",
          "createdAt": "2022-04-06T16:19:03Z",
          "updatedAt": "2022-04-06T16:19:03Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Measures against user enumeration may be required for this process too.\r\n\r\nThis is the main reason I was asking this, because I don't know how that would be done.\r\n\r\nThe only thing that comes to mind is to have every user on login run the process through all possible ciphersuites at the same time, so if they have old credentials they can still authenticate and then update the ciphersuite, while still preventing user enumeration.\r\n\r\nSorry for the delay btw, I was sick.",
          "createdAt": "2022-06-10T20:27:29Z",
          "updatedAt": "2022-06-10T20:27:45Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "I_kwDOD79ejs5AuQOz",
      "title": "Shared Secret Derivation: `SerializePublicKey`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/295",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "While reviewing a P-256 implementation of OPAQUE-3DH I noticed that there is a difference between it and \"common\" ECDH. When using ECDH usually only the x-coordinate is used to derive the secret. That isn't the case in OPAQUE-3DH apparently.\r\n\r\nLooking over the spec I discovered the function `SerializePublicKey`, which is used on top of DH. I couldn't find any reference to it otherwise, what is it supposed to do?\r\n\r\nI'm no cryptographer, forgive me if this question seems naive.",
      "createdAt": "2021-12-21T14:03:24Z",
      "updatedAt": "2022-01-18T16:55:20Z",
      "closedAt": "2022-01-18T16:55:20Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@daxpedda for reference, can you please point to the implementation you're referencing? It's true that we somehow dropped the definition of `SerializePublicKey`. Let's use this issue to track adding that back. \r\n\r\n@kevinlewi, can you please take this?",
          "createdAt": "2022-01-07T14:04:32Z",
          "updatedAt": "2022-01-07T14:04:32Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reference: https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-6.4.3.2-2.",
          "createdAt": "2022-01-07T14:06:01Z",
          "updatedAt": "2022-01-07T14:06:01Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "The commit that deleted the definition is [this one](https://github.com/cfrg/draft-irtf-cfrg-opaque/commit/deae8d8d3a72ccde19ae9b553da1c77b35f1d8d3). The definition was deleted as the function wasn't used.\r\n\r\nGood catch! We should definitely bring that back. ",
          "createdAt": "2022-01-07T15:46:56Z",
          "updatedAt": "2022-01-07T15:46:56Z"
        }
      ]
    },
    {
      "number": 296,
      "id": "I_kwDOD79ejs5A7mf1",
      "title": "Update ```oprf_seed``` length in vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/296",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [],
      "body": "The draft states\r\n\r\n> Unless said otherwise, all random nonces and key derivatio seeds used in these dependencies and the rest of the OPAQUE protocol are of length Nn and Nseed bytes, respectively, where Nn = Nseed = 32.\r\n\r\nBut the ```oprf_seed``` in the test vectors is derived using the hash functions output length\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/blob/2f95f12c5f438cf582108b15d5fb5e60631c6dbf/poc/test_opaque_ake.sage#L43\r\n\r\nThis ought to be corrected.",
      "createdAt": "2021-12-27T17:07:53Z",
      "updatedAt": "2021-12-27T18:47:06Z",
      "closedAt": "2021-12-27T18:47:06Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "My bad, I got confused and read that wrong. For the record, the `oprf_seed` is Nh bytes long.",
          "createdAt": "2021-12-27T18:47:06Z",
          "updatedAt": "2021-12-27T18:47:06Z"
        }
      ]
    },
    {
      "number": 298,
      "id": "I_kwDOD79ejs5BK6rV",
      "title": "`DeriveAuthKeyPair` can fail",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/298",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`DeriveAuthKeyPair` is supposed to take a randomly generated seed and return a private and public key. As far as I understand `HashToScalar` doesn't guarantee to return a non-zero scalar, yielding an invalid private key.\r\n\r\nI'm no cryptographer, so here are the assumptions that I made:\r\n- `HashToScalar` returns a non-zero scalar.\r\n- A zero scalar is an invalid private key for the key exchange mechanism.\r\n\r\nIf this is correct, how should failure be handled? Considering this is happening on the client, I believe constant-time isn't an issue and it could just try again with a different seed?",
      "createdAt": "2022-01-04T13:57:03Z",
      "updatedAt": "2022-02-07T15:32:28Z",
      "closedAt": "2022-02-07T15:32:28Z",
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've recently seen an implementation that does reduces by MODULUS - 1, and then adds one. In any case, thinking about it more I'm not sure if this should be addressed here or in VOPRF.",
          "createdAt": "2022-01-06T19:54:14Z",
          "updatedAt": "2022-01-06T19:54:14Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "According to VOPRF, their `DeriveKeyPair` is also supposed to produce a non-zero scalar. Again, it relies on `HashToScalar` to do that, which as far as I can tell it doesn't.\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-08#section-2.1\r\n> Two functions can be used for generating a (V)OPRF key pair (skS,\r\npkS) **where skS is a non-zero integer** less than p and pkS =\r\nScalarBaseMult(skS): GenerateKeyPair and DeriveKeyPair.\r\n\r\nSo it seems to me that `HashToScalar` should really return a non-zero scalar and this should be addressed in VOPRF, right?",
          "createdAt": "2022-01-06T20:53:47Z",
          "updatedAt": "2022-01-06T20:53:47Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For example, the key generation for ECDSA (https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf) admits two methods:\r\nrejection sampling (non-constant time) and reduction mod n-1 plus one: `d = (c mod (n\u20131)) + 1`.\r\nThus, it is guaranteed to produce non-zero scalars (private keys).\r\n\r\n\r\nFor OPAQUE/VOPRF, the key generation could adopt something similar. However, note that the HashToScalar method must not be the target for changes, we want HashToScalar returns 0 since it's a valid scalar, but not a valid key.\r\n\r\nAlso, there is a negligible probability that HashToScalar returns 0. This may be the reason why, in practice, the current key generation method works without issues.\r\n",
          "createdAt": "2022-01-06T21:08:23Z",
          "updatedAt": "2022-01-06T21:08:23Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For example, the key generation for ECDSA (https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf) admits two methods: rejection sampling (non-constant time) and reduction mod n-1 plus one: `d = (c mod (n\u20131)) + 1`. Thus, it is guaranteed to produce non-zero scalars (private keys).\r\n\r\nThank you, I wasn't aware that the method I mentioned above is actually standardized somewhere.\r\n> For OPAQUE/VOPRF, the key generation could adopt something similar. However, note that the HashToScalar method must not be the target for changes, we want HashToScalar returns 0 since it's a valid scalar, but not a valid key.\r\n\r\nSo in VOPRF we will have to adjust `DeriveKeyPair` and in OPAQUE `DeriveKeyPair` and `DeriveAuthKeyPair`. I believe this covers all?\r\n> Also, there is a negligible probability that HashToScalar returns 0. This may be the reason why, in practice, the current key generation method works without issues.\r\n\r\nI am aware. It's just that in the Rust implementations I'm working on these sort of invariants are enforced on a type level (which is amazing ofc), so the only reason why I noticed this issue is because I couldn't infallibly convert a `Scalar` to a `PrivateKey` type.\r\n\r\nI'm still unsure what is necessary to \"fix\" for example `DeriveKeyPair` in OPAQUE if we don't intend to touch `HashToScalar`:\r\n```\r\n1. private_key = HashToScalar(seed, dst=\"OPAQUE-DeriveKeyPair\")\r\n2. public_key = ScalarBaseMult(private_key)\r\n3. Output (private_key, public_key)\r\n```\r\nJust put a step between 1 and 2 to fail if `private_key` is zero? Or should we just insert a function that makes sure to reduce it to something non-zero, like the one you mentioned above: `d = (c mod (n\u20131)) + 1`?",
          "createdAt": "2022-01-06T21:22:35Z",
          "updatedAt": "2022-01-06T21:22:35Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For OPAQUE/VOPRF, the key generation could adopt something similar.\r\n\r\nSorry, so what you are proposing is basically:\r\n```\r\nDeriveKeyPair(seed)\r\n\r\nSteps:\r\n1. scalar = HashToScalar(seed, dst=\"OPAQUE-DeriveKeyPair\")\r\n2. private_key = (scalar mod (n - 1)) + 1\r\n3. public_key = ScalarBaseMult(private_key)\r\n4. Output (private_key, public_key)\r\n```",
          "createdAt": "2022-01-06T21:57:13Z",
          "updatedAt": "2022-01-06T21:57:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since `DeriveAuthKeyPair` is run with a client-chosen envelope nonce, I suggest we instead treat invalid scalars as an exceptional case and require clients to retry with a new nonce. Same for servers when deriving the OPRF key pair.",
          "createdAt": "2022-01-07T14:02:19Z",
          "updatedAt": "2022-01-07T14:02:19Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What about `DeriveKeyPair`? For example in `CreateCredentialResponse`.",
          "createdAt": "2022-01-09T21:34:30Z",
          "updatedAt": "2022-01-09T21:35:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@daxpedda right, we'd do the same for `DeriveKeyPair`, which is what I meant when I said \"same for servers when deriving the OPRF key pair.\"",
          "createdAt": "2022-01-10T15:07:19Z",
          "updatedAt": "2022-01-10T15:07:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can fold this into #312. Closing as such.",
          "createdAt": "2022-02-07T15:32:27Z",
          "updatedAt": "2022-02-07T15:32:27Z"
        }
      ]
    },
    {
      "number": 304,
      "id": "I_kwDOD79ejs5BZeQA",
      "title": "Concat and structs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/304",
      "state": "CLOSED",
      "author": "BjoernPetersen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The definition for `concat` says:\r\n\r\n> `concat(x0, ..., xN)`: Concatenate byte strings. For example, concat(`0x01`, `0x0203`, `0x040506`) = `0x010203040506`.\r\n\r\nBut if I understand correctly, in all functions defined in [section 4](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#name-key-recovery) and in [CreateCredentialResponse](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-6.3.2.2) it's used to concatenate byte strings and structs (namely `CleartextCredentials` and `Envelope`).\r\n\r\nAm I assuming correctly that the values within the structs should be concatenated in order of declaration? In any case, this should probably be clarified.",
      "createdAt": "2022-01-09T13:29:19Z",
      "updatedAt": "2022-02-02T14:24:37Z",
      "closedAt": "2022-02-02T14:24:37Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Bj\u00f6rn,\r\n\r\nIndeed, serialization of a struct is the concatenation of its elements in the order of their position within the struct.\r\n\r\nWe take the notation from RFC8446, as indicated, and SerDe should follow that. I agree though that an additional phrase for clarification wouldn't hurt.",
          "createdAt": "2022-01-09T16:50:25Z",
          "updatedAt": "2022-01-09T16:50:25Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, the structures are specifically indicated as being in wire format in the document, which defines how they are serialized.",
          "createdAt": "2022-01-09T17:11:10Z",
          "updatedAt": "2022-01-09T17:11:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Correct. Structs are wire format messages -- byte strings -- so concat works on them like any other message. Closing as such. @BjoernPetersen, please reopen if you think further clarification is needed.",
          "createdAt": "2022-02-02T14:24:37Z",
          "updatedAt": "2022-02-02T14:24:37Z"
        }
      ]
    },
    {
      "number": 305,
      "id": "I_kwDOD79ejs5BZl7Z",
      "title": "Missing masking key mention in relevant section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/305",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "next-version",
        "editorial"
      ],
      "body": "In `Notable Design Differences` we mention\r\n\r\n> - Envelopes are masked with a per-user masking key as a way of preventing client enumeration attacks. See {{preventing-client-enumeration}} for more details.\r\n\r\nBut such details are missing in that section.",
      "createdAt": "2022-01-09T15:39:23Z",
      "updatedAt": "2022-02-03T22:24:16Z",
      "closedAt": "2022-02-03T22:24:16Z",
      "comments": []
    },
    {
      "number": 307,
      "id": "I_kwDOD79ejs5BaHEv",
      "title": "Clarification on how to serialize CleartextCredentials",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/307",
      "state": "CLOSED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi, I'm trying to create a `C` implementation and one particular step was very unclear to me. It was how to serialize the `CleartextCredentials` struct. I only discovered how to serialize the strings looking at the `poc` code.\r\n\r\nI'm willing to provide notes around it if you think it's something useful, just let me know.",
      "createdAt": "2022-01-10T01:18:31Z",
      "updatedAt": "2022-02-02T14:33:42Z",
      "closedAt": "2022-02-02T14:33:42Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We already note this:\r\n\r\n> All protocol messages and structures defined in this document use the syntax from [RFC8446], Section 3.\r\n\r\nI'm happy to consider further clarifying suggestions, but I think this is sufficient. @aldenml please feel free to make a proposal!",
          "createdAt": "2022-02-02T14:23:25Z",
          "updatedAt": "2022-02-02T14:23:25Z"
        },
        {
          "author": "aldenml",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It was lack of familiarity with RFC8446 on my part :)",
          "createdAt": "2022-02-02T14:33:42Z",
          "updatedAt": "2022-02-02T14:33:42Z"
        }
      ]
    },
    {
      "number": 308,
      "id": "I_kwDOD79ejs5BdKw0",
      "title": "Memory hard function to key stretching function",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/308",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "... since not all variants will necessarily be memory-hard.",
      "createdAt": "2022-01-10T17:15:03Z",
      "updatedAt": "2022-02-03T14:14:21Z",
      "closedAt": "2022-02-03T14:14:21Z",
      "comments": []
    },
    {
      "number": 309,
      "id": "I_kwDOD79ejs5BdxRd",
      "title": "Test cases for edge cases and failing conditions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/309",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "next-version"
      ],
      "body": "It would be interesting to provide values, test vectors, and expected behavior for edge cases and conditions we expect the protocol and implementations to return errors. This will help implementors evaluate some security properties to a certain degree.\r\n\r\nWe could draw a first list of some of these values and testing functions (e.g. invalid points). This goes well in hand with #256 ",
      "createdAt": "2022-01-10T20:10:30Z",
      "updatedAt": "2023-03-10T18:50:28Z",
      "closedAt": "2023-03-10T18:50:27Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Pinged the VOPRF team in https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/333 to see if such vectors are planned for the OPRF scope.",
          "createdAt": "2022-04-09T21:44:42Z",
          "updatedAt": "2022-04-09T21:44:42Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "We will implement these test vectors for the three error types in the Error Considerations section (one for each).",
          "createdAt": "2022-05-20T16:21:27Z",
          "updatedAt": "2022-05-20T16:21:27Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this since it was also closed in https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/333",
          "createdAt": "2023-03-10T18:50:27Z",
          "updatedAt": "2023-03-10T18:50:27Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "I_kwDOD79ejs5Bd3LK",
      "title": "Replace symmetric masking_key protection with an asymmetric method",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/310",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [],
      "body": "Currently, one of the client enumeration mitigation techniques is to encrypt the server's login response with a symmetric key furnished by the client during registration.\r\n\r\nThe notion that there is data in that record that is supposedly secret (the `masking_key`)  puts some constraint on the server and the operator of the user database. The \"_OPAQUE manual_\" would read _\"this key is a secret symmetric encryption key used to protect against client enumeration_\", and any good practice would hence indicate that this needs more attention than if there wasn't secret data.\r\n\r\nI'm trying to see this from the point of view in some years when OPAQUE is mainstream and deployed everywhere one can think of, and millions of developers are using it in their apps. The less poisonous/radioactive the record is (or just appears to be) the better.\r\n\r\nI have more trust in protocol implementers doing the right machinery to build OPAQUE than I have in people using it correctly. So the smaller the operational risk surface, the better.\r\n\r\n___\r\n\r\nMy suggestion is to replace the current masking mechanism with a non-interactive DHKE to encrypt the envelope in transit. Replace the symmetric `masking_key` with an asymmetric user public key.\r\n\r\nOn registration, the client uses a server-provided public key (in the registration response) to encrypt its record to that key and send the result to the server. This adds confidentiality to the record as discussed in #240.\r\nOn login, the server encrypts the envelope to the client's public key and sends that along in the credential response. The client recovers its private key (just like now) and can decrypt that ciphertext.\r\n\r\n**This brings the advantage of having a less sensitive client record since it won't contain any secret value anymore.**\r\n\r\nHPKE could be a good candidate for this.\r\n\r\ncc @chris-wood @kevinlewi ",
      "createdAt": "2022-01-10T20:39:02Z",
      "updatedAt": "2022-07-01T16:03:39Z",
      "closedAt": "2022-07-01T16:03:38Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "**Proposed changes**\r\n\r\n**Change 1**\r\nOn registration, the server sends a public key that the client will use in Change 3\r\n~~~\r\nstruct {\r\n  uint8 data[Noe];\r\n  uint8 server_public_key[Npk];\r\n  uint8 server_hpke_key[Npk];\r\n} RegistrationResponse;\r\n~~~\r\n\r\n**Change 2**\r\nInstead of the `masking_key` in the record, the client derives a private key and associated public `client_hpke_key` from the OPRF output and places it in its registration record. N.b. this key pair is used for the masking mechanism, and not for the AKE.\r\n~~~\r\nstruct {\r\n  uint8 client_public_key[Npk];\r\n  uint8 client_hpke_key[Npk];\r\n  Envelope envelope;\r\n} RegistrationRecord;\r\n~~~\r\n\r\n**Change 3**\r\nThe client uses the server's `server_hpke_key` to encrypt that `RegistrationRecord` to ensure its confidentiality (cf #240). The message sent instead to the server at registration would then be the following\r\n~~~\r\nstruct {\r\n  uint8 masked_record[???];\r\n} RegistrationFinalize;\r\n~~~\r\n\r\n**Change 4**\r\nIn CredentialResponse during login, the new `masked_response` field is the encryption of `server_public_key||envelope` using the `client_hpke_key` from the record.\r\n~~~\r\nstruct {\r\n  uint8 data[Noe];\r\n  uint8 masked_response[???];\r\n} CredentialResponse;\r\n~~~\r\n\r\n**Change 5**\r\nThe client recovers the pseudorandom key and `client_hpke_key` (like in Change 1) and decrypts the masked_response to finalize the AKE key recovery.",
          "createdAt": "2022-01-15T23:00:19Z",
          "updatedAt": "2022-01-21T02:39:22Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I have the feeling that I am misunderstanding the intention here. So pardon me if what I am writing makes no sense (please explain to me again).\r\n\r\nIs client_hpke_key a symmetric key with the same functionality as masking_key but with a different name? Is the only substantial change here the sending of a PK from the server during registration for  implementing a secret channel from client to server during registration? If this is all then I would prefer not to add this mechanism. In the large majority of cases, in particular those doing registration over server-encrypted TLS, this would not be needed. In other cases, , the application will need to create such a secret channel by sending a (possibly ephemeral) public key over the authenticated channel. Is it worth adding complexity to the OPAQUE spec for something that may only be needed in a minority of cases? (In general, it frustrates me how much complexity this \"stupid\" enumeration issue introduces.)\r\n\r\nBtw, one way to eliminate the secrecy of masking_key and the need for a secret channel during registration, is to use a client's public key instead of a masking key to mask the server's message during login. The client will produce a second (private,public) key pair  (additional to the one used by regular OPAQUE)  from the OPRF output and send it to the server during registration. During login, the server encrypts an ephemeral masking key under this client's public key and uses the masking key to mask the server's login response. This prevents the need for a secret channel during registration and the need to store the secret masking_key at the server. However, it adds complexity to the protocol and, even worse, people will end reusing the OPAQUE client public key for this masking purpose. Also, one would need to require that the PK scheme in use be \"key private\" in the sense  of Bellare et al https://iacr.org/archive/asiacrypt2001/22480568.pdf.",
          "createdAt": "2022-01-20T21:18:30Z",
          "updatedAt": "2022-01-20T21:18:30Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello Hugo,\n\nclient_hpke_key is an asymmetric key, for the exact purpose you describe in the second part of your message :)\n\nI'm updating my description to make this point clearer.",
          "createdAt": "2022-01-21T02:25:59Z",
          "updatedAt": "2022-01-21T02:34:05Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding key privacy, the scheme I'm suggesting for the registration is directly intended for that: the client encrypts the client record under the server's hpke key, thus hiding the client's public key.\n\nI agree that this brings some complexity. That's why I'd like to discuss the benefits vs the added complexity. It would also be interesting if we find solutions to reduce the added complexity.",
          "createdAt": "2022-01-21T02:32:39Z",
          "updatedAt": "2022-01-21T02:32:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Why do you need to encrypt the client's public key? If this is for key privacy as in the Bellare paper, then encrypting the public key may not be enough to ensure key privacy. In any case, while I hate to require a secret channel just for the (symmetric) masking key, I feel this alternative using public key encryptions adds complexity and can lead to shortcuts that reuse of the OPAQUE public key for this masking encryption. Yet, if you guys prefer this solution, I can live with it.",
          "createdAt": "2022-01-21T02:52:20Z",
          "updatedAt": "2022-01-21T02:52:20Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "From what I understand, the key privacy property in the paper is to ensure the privacy of the receiver (i.e. client) public-key in the case it is already public. In our setting, the client's public key is not known by an eavesdropper unless they had access to the cleartext client record on the server. If I'm not mistaken, the lack of that property is not a problem here.\r\n\r\nI agree that this solution adds some sort of complexity and some more configuration options. But maybe we can figure something out to reduce that overhead.",
          "createdAt": "2022-02-14T02:11:12Z",
          "updatedAt": "2022-02-14T02:11:12Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I understand that the added complexity might not be worth baking this into the protocol, and I'm failing to gain traction for this \ud83d\ude03 \r\n\r\nI therefore propose to just mention it in the security considerations section with #240 in #306.\r\n\r\n@chris-wood @kevinlewi, what do you think?",
          "createdAt": "2022-02-18T02:13:16Z",
          "updatedAt": "2022-02-18T02:14:13Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As an implementer I think this adds a great deal of complexity, but I believe it would be worth it. If I understand this correctly, that would not only protect the transport, but also any potential database leaks from revealing the masking key, as long as the servers private and public key aren't compromised.\r\n\r\nSo overall an improvement, the spec could also specify to make it optional, but standardizing it would still benefit implementers a lot.",
          "createdAt": "2022-02-23T12:58:03Z",
          "updatedAt": "2022-02-23T12:58:03Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "In the basic protocol, the server stores two per-user secrets: an OPRF key and a private key for the server. However, the former can be I avoided if the user's OPRF key is derived from a master PRF, and the latter is prevented if the server uses the same private key with all users. In this case, the masking key would be the only secret value to stored in the user's record. I do find value in @bytemare  effort to avoid storing such secret value. However, a simple solution is to use yet another system-wide PRF \r\n to derive per-user pseudo-random pads to encrypt the masking key.  The public key approach as suggested by @bytemare and supported by @daxpedda could work, but it is not theoretically sound: If the PK encryption scheme does not have the same space of ciphertexts (this is the case of RSA), then the masking using PK encryption may not be indistinguishable between existing and non-existing users.  This is not an issue with elliptic curves so at the moment this maybe a theoretical concern only. Not sure about PQ schemes.  One more element to consider: If an attacker has access to a user's record, then it does not need to mount an enumeration attack against that user; it already knows the user exists. Since the masking key is only needed to counter such attack, disclosing it to the attacker in this case does not seem a problem. Food for thought. I may well be missing some other considerations to support the PK variant.",
          "createdAt": "2022-02-24T23:47:01Z",
          "updatedAt": "2022-02-24T23:47:01Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If an attacker has access to a user's record, then it does not need to mount an enumeration attack against that user; it already knows the user exists.\r\n\r\nI didn't think about that. If I understand this correctly, there is really no point to store the masking key in it's encrypted form (whatever form that encryption might take, IANA cryptographer, I will let you guys hash that out), so the masking key should really only be encrypted during transfer of the `RegistrationRecord` from the client during registration?",
          "createdAt": "2022-02-25T12:26:33Z",
          "updatedAt": "2022-02-25T12:26:33Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "What we can do is to add some text in the security section suggesting this solution for people considering that risk needs to be addressed. Piggy backing on #306 ",
          "createdAt": "2022-04-05T21:17:08Z",
          "updatedAt": "2022-04-05T21:17:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved by #240.",
          "createdAt": "2022-07-01T16:03:38Z",
          "updatedAt": "2022-07-01T16:03:38Z"
        }
      ]
    },
    {
      "number": 312,
      "id": "I_kwDOD79ejs5Bj5ZP",
      "title": "Failure handling",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/312",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Currently it is not specified how to handle failures that aren't the fault of implementation, user or host (in the case of the usual authentication process).\r\n\r\nThe question on all the following points is:\r\n- What should be done in the case of a failure:\r\n  - Is it okay to just try again with a different input, for example in the case of randomness that caused the failure.\r\n  - Should simply an error be emitted and the process started from scratch again.\r\n- Should something be adjusted in the VOPRF spec to not produce an error.\r\n\r\nThis is a list of functions that can fail:\r\n- [`CreateRegistrationRequest`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.1-1) can fail because it uses [`Blind`](https://www.ietf.org/archive/id/draft-irtf-cfrg-voprf-08.html#section-3.3.3.1-1), which can produce the identity point. I don't know if this is a problem or not, see cfrg/draft-irtf-cfrg-voprf#305. The easiest solution is to simply try again as the failure depends on RNG.\r\n\r\n- The same applies to [`CreateRegistrationRequest`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.1-1).\r\n\r\n- [`CreateRegistrationResponse`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.2-1) can fail because it uses [`Evaluate`](https://www.ietf.org/archive/id/draft-irtf-cfrg-voprf-08.html#section-3.3.1.1-1), which can simply fail with [`InverseError`](https://www.ietf.org/archive/id/draft-irtf-cfrg-voprf-08.html#section-5.1-2.3). In this case `CreateRegistrationResponse` can't be completed, unless a new `oprf_seed` is generated, or users receive an error and have to start from [`CreateRegistrationRequest`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.1-1) again.\r\n\r\n- [`CreateCredentialResponse`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-6.3.2.2-3) can't fail, because otherwise `CreateRegistrationResponse` should have failed before, it might be helpful to mention that.\r\n\r\n- [`CreateRegistrationResponse`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.2-1), which can fail because of [`DeriveKeyPair`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-2.1-5), which can fail if `HashToScalar` returns a zero scalar. See #298.\r\n\r\n- [`CreateCredentialResponse`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-6.3.2.2-3), which can fail because of [`DeriveKeyPair`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-2.1-5), which can fail if `HashToScalar` returns a zero scalar. See #298.\r\n\r\n- [`FinalizeRequest`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.3-2), which can fail because of [`Store`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-4.1.2-2), which can fail because of [`DeriveAuthKeyPair`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-6.4.2-4), which can fail if `HashToScalar` returns a zero scalar. See #298.\r\n\r\n- [`RecoverCredentials`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-6.3.2.3-1) can't fail, because otherwise `FinalizeRequest` should have failed before, again, it might be helpful to mention that.",
      "createdAt": "2022-01-12T06:24:57Z",
      "updatedAt": "2022-07-05T19:15:36Z",
      "closedAt": "2022-07-05T19:15:36Z",
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I addressed some of the issues that relate to VOPRF here too: https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/307.",
          "createdAt": "2022-01-12T07:45:15Z",
          "updatedAt": "2022-01-12T07:45:15Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "That's some of what #256 tries to address: document falling/errors scenarios :)\r\n\r\nI'm preparing a PR around which to articulate the discussion on how to do that. Your input will be greatly appreciated \ud83d\udc4d ",
          "createdAt": "2022-01-12T18:27:15Z",
          "updatedAt": "2022-01-12T18:27:15Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that we should work to avoid having errors in functions where they can be avoided. I believe that the errors you mention relative to HashToScalar and DeriveKeys are being worked upon in VOPRF, e.g. see https://github.com/cfrg/draft-irtf-cfrg-voprf/pull/308\r\n\r\n",
          "createdAt": "2022-01-16T00:02:50Z",
          "updatedAt": "2022-01-16T00:02:50Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the end I would like to avoid any errors that require the whole protocol to be restarted even if every party involved did everything correctly (e.g. didn't produce invalid public keys).\r\n\r\nProducing an error like this makes it hard to control how library consumers will react. Most likely the user would simply receive an error saying \"Unexpected Error\", instead of library consumers just implementing a way to automatically try again.\r\n\r\nSo I think the solution provided in cfrg/draft-irtf-cfrg-voprf#308 is great because introducing the counter makes it basically infallible. Though of course I would prefer a solution that is constant-time and truly infallible much more, like simply  doing reduction mod n-1 plus one, like proposed here: https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/298#issuecomment-1006936162.\r\n\r\nI would also like to clarify something. Some of the failures I mentioned above are not currently handled by the spec at all. [`CreateRegistrationRequest`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.1-1) for example doesn't actually check if `Blind` produces an identity point. But maybe that is also something that is best handled in the VOPRF spec.",
          "createdAt": "2022-01-16T05:27:08Z",
          "updatedAt": "2022-01-18T10:52:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking at this based on latest developments, here's my summary of things:\r\n\r\n- CreateRegistrationRequest (and CreateCredentialRequest) can fail if Blind fails. This is an exceptional event that happens with negligible probability. We should simply note that it occurs and recommend that implementations require clients to change passwords\r\n- CreateRegistrationResponse can currently fail if DeriveKeyPair fails. We can fix that by recommending that the implementation choose a new credential identifier and re-run this step. This happens with negligible probability, too. Alternatively, the protocol could generate the credential identifier and output it, but that might complicate the interface.\r\n- FinalizeRequest can currently fail if DeriveAuthKeyPair in Store() fails. We can fix this by recommending that implementations choose a new envelope_nonce in this event. \r\n\r\nWith these changes, the corresponding authentication steps should not fail. Does this look right?",
          "createdAt": "2022-02-05T16:05:58Z",
          "updatedAt": "2022-02-05T16:05:58Z"
        },
        {
          "author": "Tronic",
          "authorAssociation": "NONE",
          "body": "It would be best to specify it as such that `DeriveKeyPair` cannot fail. Namely, depending on the curve different methods should be used to ensure that suitable non-zero scalar (secret key) is produced no matter what the random bytes. In particular with Ed25519 the RFC requires masking off bit 255 and masking on bit 254, such that no identity can ever be created (it also masks off the three lowest bits such that scalar multiplication always results in points in the prime subgroup even if the original point was in one of the normally never used 7 other subgroups). The mod n-1 plus 1 clamping works with prime order curves (producing a miniscule bias but that should really not be a concern).\r\n\r\nIn blinding one can similarly clamp `k` and `r` but not r's inverse. This should ensure that the points created are well-behaving and there can be no errors unless either the client or the server maliciously pass invalid values. Checking of points for correctness is slow and difficult, so whether that is necessary needs some thought (also pointing out that different curves again have different requirements).\r\n",
          "createdAt": "2022-06-04T13:40:49Z",
          "updatedAt": "2022-06-04T13:43:38Z"
        }
      ]
    },
    {
      "number": 321,
      "id": "I_kwDOD79ejs5CW6b8",
      "title": "tripledhikm redunantly and confusingly needs 6 parameters while it works really on only 4",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/321",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "next-version"
      ],
      "body": "```\r\nTripleDHIKM(sk1, pk1, sk2, pk2, sk3, pk3)\r\n```\r\nis later called with:\r\n```\r\n5. ikm = TripleDHIKM(server_private_keyshare, ke1.client_keyshare,\r\n                    server_private_key, ke1.client_keyshare,\r\n                    server_private_keyshare, client_public_key)\r\n```\r\nwhich is just a combination of eskS, skS and pkU, and epkU, i think the current way is very confusing and a source of silent coding errors.",
      "createdAt": "2022-01-25T00:57:19Z",
      "updatedAt": "2022-02-03T15:50:44Z",
      "closedAt": "2022-02-03T15:50:44Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i realized this is a way to have only one function doing the 3dh instead of one for the server and one for the client. although i do understand this ,i still believe that the caller should not be exposed to the semantics of the underlying function.  it definitely does not help readability of the code the cognitive costs of reading and getting the params right is in my opinion not worth having only one function.",
          "createdAt": "2022-01-25T15:19:18Z",
          "updatedAt": "2022-01-25T15:19:18Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I did that in my first implementation and even proposed that in a PR here: have one generic function and switch the computation based on a role argument (client or server). I don't remember why we didn't keep it.\r\n\r\nI ended up not doing it anymore because it added a slight complexity to the code, and the KE would fail anyway if not implemented correctly. For the spec, only implementors will need to read this thoroughly.\r\n\r\nI'm not saying I don't agree with you :) I understand your argument!",
          "createdAt": "2022-01-25T23:30:00Z",
          "updatedAt": "2022-01-25T23:30:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef's probably right in that there's a bit too much OO-like notation and code reuse in the doc. Let's just inline this function where it's used, and avoid the parameter mismatches?",
          "createdAt": "2022-02-02T14:21:39Z",
          "updatedAt": "2022-02-02T18:38:18Z"
        }
      ]
    },
    {
      "number": 323,
      "id": "I_kwDOD79ejs5C4AcT",
      "title": "Align reference implementation with the specification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/323",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "Right now the spec and reference implementation use different names for functions, parameters, etc. This is likely confusing. Let's update the reference implementation such that the two are in sync.",
      "createdAt": "2022-02-02T14:14:26Z",
      "updatedAt": "2023-05-21T09:22:57Z",
      "closedAt": "2023-05-21T09:22:57Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be good now, isn't it?",
          "createdAt": "2023-04-02T01:29:55Z",
          "updatedAt": "2023-04-02T01:29:55Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes I believe this was addressed by #407 -- thank you!",
          "createdAt": "2023-05-21T09:22:57Z",
          "updatedAt": "2023-05-21T09:22:57Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "I_kwDOD79ejs5C4DWu",
      "title": "Align with VOPRF-09",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/324",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "The title says it all.",
      "createdAt": "2022-02-02T14:24:57Z",
      "updatedAt": "2022-02-02T17:53:29Z",
      "closedAt": "2022-02-02T17:53:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Pushed directly to main.",
          "createdAt": "2022-02-02T17:53:29Z",
          "updatedAt": "2022-02-02T17:53:29Z"
        }
      ]
    },
    {
      "number": 328,
      "id": "I_kwDOD79ejs5C5Oq5",
      "title": "Adopt VOPRF DeriveKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/328",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "next-version"
      ],
      "body": "... and fix serialization stuff, as that's no longer part of the VOPRF abstraction.",
      "createdAt": "2022-02-02T19:22:15Z",
      "updatedAt": "2022-02-07T15:31:50Z",
      "closedAt": "2022-02-04T15:18:54Z",
      "comments": []
    },
    {
      "number": 334,
      "id": "I_kwDOD79ejs5DDZ2x",
      "title": "Add more prose",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/334",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Many of the sections in the document simply start with function or data structure descriptions without much context. We should add more prose so that the document is easier to follow and understand.",
      "createdAt": "2022-02-05T16:07:46Z",
      "updatedAt": "2022-05-21T00:29:04Z",
      "closedAt": "2022-05-21T00:29:04Z",
      "comments": []
    },
    {
      "number": 336,
      "id": "I_kwDOD79ejs5DH95I",
      "title": "Rework AKE messages and structures",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/336",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [
        "next-version"
      ],
      "body": "This section has changed so much it no longer makes any sense. For example, what is the \"KE2 structure\"? It's not defined anywhere, yet it's referenced as if it has member fields. This needs to be done before the next version.",
      "createdAt": "2022-02-07T15:43:10Z",
      "updatedAt": "2022-05-20T05:46:09Z",
      "closedAt": "2022-05-20T05:46:09Z",
      "comments": []
    },
    {
      "number": 337,
      "id": "I_kwDOD79ejs5DTeT_",
      "title": "include metadata about MHF in envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/337",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "currently the memory hard function (MHF) and its parameters are hard-coded in the ciphersuite, however if a user wants to use a different MHF, it would be possible to made parameters available as part of envelope's metadata.\r\n\r\ncc: @evanderkoogh , who may want to add more comments.",
      "createdAt": "2022-02-09T23:21:28Z",
      "updatedAt": "2022-03-29T09:35:57Z",
      "closedAt": "2022-03-29T09:35:57Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We've discussed this in the past and concluded that supporting negotiation of key stretching parameters via the envelope is not worth the complexity. (I don't have the relevant issue at hand, but we could probably dig it up.) Another complicating factor is that there's no registry for key stretching algorithms, so this would require us to introduce one.",
          "createdAt": "2022-02-10T01:50:37Z",
          "updatedAt": "2022-02-10T01:50:37Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "See https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/69 which contains the aforementioned discussion. Closing this issue but feel free to reopen if there are new points to be made!",
          "createdAt": "2022-03-29T09:35:57Z",
          "updatedAt": "2022-03-29T09:35:57Z"
        }
      ]
    },
    {
      "number": 341,
      "id": "I_kwDOD79ejs5DwEQe",
      "title": "does the authorization mac check really have to be constant time?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/341",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\ndef ServerFinish(ke3):\r\n  if !ct_equal(ke3.client_mac, state.expected_client_mac):\r\n```\r\neach run of the protocol must use different macs anyway, so if an attacker learn how many bytes they managed to match, does not help them at all.\r\n\r\nalso i was wondering i saw, that in contrast to earlier variants, now the session key is only considered valid if this check is successful, but the paper and earlier drafts also allowed for implicit authentication in case the session key is used for setting up an encrypted channel for example, what happened to that? ",
      "createdAt": "2022-02-14T02:40:40Z",
      "updatedAt": "2022-04-05T21:56:36Z",
      "closedAt": "2022-04-05T21:56:36Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @hugokraw in case he can help with answering about:\r\n1) the necessity for the constant-time mac checks here, and\r\n2) considering the session key as valid only if this mac check succeeds.",
          "createdAt": "2022-03-29T09:31:54Z",
          "updatedAt": "2022-03-29T09:31:54Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thx for reviving this",
          "createdAt": "2022-03-29T11:14:07Z",
          "updatedAt": "2022-03-29T11:14:07Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Stef is right that the MAC in the KE protocol (particularly 3DH) is \"one time\" in the sense that the MAC key is used only for this particular run of the protocol so there is no need to protect the key for repeated/long-term uses.\r\nHe is also right that if you forgo the check of the MAC, the session key is still implicit authenticated. MAC verification does provide value in the form of explicit authentication, key confirmation and forward security against active attackers. If you don't need these properties the KE protocol is still secure without the MAC.",
          "createdAt": "2022-03-29T17:08:59Z",
          "updatedAt": "2022-03-29T17:08:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for chiming in @hugokraw!\r\n\r\n@stef: Is your question mainly out of curiosity, or are you proposing that the requirements for the specification be changed to not require this mac check to be constant-time?\r\n\r\nIt seems to me that since implementations already have to make constant-time checks in other parts of the protocol, and so the cost/burden of doing this for the mac check is negligible, even if it is extraneous. So I would advocate for still keeping the constant-time requirement in there for simplicity of exposition.\r\n\r\nOr alternatively, we could add a small note saying that this last check isn't required to be in constant-time, into the draft text.\r\n\r\n",
          "createdAt": "2022-03-29T21:20:33Z",
          "updatedAt": "2022-03-29T21:20:33Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "The argument is indeed valid, but I would advocate to follow best practices as much as possible, more so when costs are negligible.\n\nI agree that Hugo's points could indeed be added to the text, and we add some prose to make the use case abundantly clear :)",
          "createdAt": "2022-03-29T21:54:44Z",
          "updatedAt": "2022-03-29T21:54:44Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @stef: Is your question mainly out of curiosity, or are you proposing that the requirements for the specification be changed to not require this mac check to be constant-time?\r\n\r\ni'm sorry, for mixing up two things:\r\n\r\n1/ yes the constant timeness of the check is just out of curiosity, since i noticed it is unnecessary i just wanted it to be confirmed if i'm right about this.\r\n\r\n2/ the question if the mac is necessary at all is another one. and that is less out of curiosity. without the mac, an attacker can check for correctness by checking the mac, without the mac, an attacker needs (at least) one more step to confirm the success of a guess at a correct password. and in some cases i think that is actually a good thing that improves security of the password. which is weird, not doing a mac having a positive effect. but i guess it's similar to having a mac of the plaintext of some otp encrypted message, it reduces the security level from information theoretic to computational. at least that is what i was thinking, maybe i'm wrong.",
          "createdAt": "2022-03-29T22:49:43Z",
          "updatedAt": "2022-03-29T22:49:43Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "actually i'm not quite sure about this anymore it was quite some time ago i was wondering about this and i might not get all things right anymore regarding 2/.",
          "createdAt": "2022-03-29T22:51:38Z",
          "updatedAt": "2022-03-29T22:51:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "In OPAQUE, the attacker learns if it guessed the password correctly by verifying the MAC computed on the envelope so omitting the server's MAC from the key exchange does not help.",
          "createdAt": "2022-03-29T23:27:35Z",
          "updatedAt": "2022-03-29T23:27:35Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "uh. thank you for this lesson. /o\\",
          "createdAt": "2022-03-30T09:39:54Z",
          "updatedAt": "2022-03-30T09:39:54Z"
        }
      ]
    },
    {
      "number": 346,
      "id": "I_kwDOD79ejs5E41MS",
      "title": "Should the OPRF seed and client keypair be different per client?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/346",
      "state": "CLOSED",
      "author": "jamesw1892",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [],
      "body": "[Paragraph 1 of section 5](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5-1) states that the same keypair can be used with multiple clients and different OPRF seeds can be used for each client.\r\n\r\nWhereas [section 5.3](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#name-finalize-registration) states that different keypairs can be used with each client and the same OPRF seed SHOULD be used for all clients.\r\n\r\nThis seems to be a bit confusing, it might be worth clarifying this in both places in the spec.",
      "createdAt": "2022-03-01T19:52:01Z",
      "updatedAt": "2022-05-20T11:10:40Z",
      "closedAt": "2022-05-20T11:10:39Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi James,\n\nIndeed, the server can either use unique AKE key pairs for each client, or for a subset, or the same for all of them. They point is to associate that key pair with the client as to use the right one during execution.\n\nThe OPRF seed _can_ be the same or different for each client. Since it is mixed with the client id when used, a unique per client OPRF key is derived, whatever the seed is. This document specifies a method where the seed is global.\n\nReading your comment and then the sections I agree that this might be confusing. Do you have a suggestion to make this clearer ?",
          "createdAt": "2022-03-06T18:02:45Z",
          "updatedAt": "2022-03-08T22:03:25Z"
        },
        {
          "author": "jamesw1892",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Daniel,\r\n\r\nThanks for your response, that clarifies things. I don't have any specific suggestions, maybe just say something like:\r\n\r\n\"While a different OPRF seed can be used for each client, the same OPRF seed may as well be used for all clients since regardless, a unique OPRF key will be derived for each client using it.\"\r\n\r\nAnd something exactly like what you said for AKE keypairs.",
          "createdAt": "2022-03-08T22:01:18Z",
          "updatedAt": "2022-03-08T22:01:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been fixed on the editor's copy, which no longer implies that the OPRF seed is different across users. (It's important that this seed is the same for all users for the purposes of preventing enumeration.) Closing as such. Please feel free to reopen if you think more should be done here.",
          "createdAt": "2022-05-20T11:10:39Z",
          "updatedAt": "2022-05-20T11:10:39Z"
        }
      ]
    },
    {
      "number": 356,
      "id": "I_kwDOD79ejs5JzrMU",
      "title": "Mismatch of function signatures in AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/356",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "There are inconsistencies in the way we describe returning structs from functions.\r\n\r\nIn most of the functions, we say something like:\r\n\r\n  Create CredentialRequest request with blinded_message\r\n  return (request, blind)\r\n  \r\n    Create CredentialResponse response with (evaluated_message, masking_nonce, masked_response)\r\n  return response\r\n  \r\n  \r\nBut for the AKE section, in some places, we say:\r\n\r\n  return KE1(request, ake_1)\r\n\r\n  return KE2(response, ake_2)\r\n  \r\nThis is also not right, since we should be returning ake_1 and ake_2 directly in these cases.",
      "createdAt": "2022-05-17T08:36:59Z",
      "updatedAt": "2022-06-16T08:12:14Z",
      "closedAt": "2022-06-16T08:12:13Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #364 ",
          "createdAt": "2022-06-16T08:12:13Z",
          "updatedAt": "2022-06-16T08:12:13Z"
        }
      ]
    },
    {
      "number": 359,
      "id": "I_kwDOD79ejs5KFqC1",
      "title": "Remove Nseed in favor of Nok everywhere",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/359",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "It's one less constant and the result would be the same. I think I'd be fine with this change. @kevinlewi, @bytemare: thoughts?",
      "createdAt": "2022-05-20T11:12:02Z",
      "updatedAt": "2022-07-01T17:58:15Z",
      "closedAt": "2022-07-01T17:58:15Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "So as the keyspace of decaf is higher than that of ristretto, it means that it goes as well (32 to 56), which would be a different value than for now (but for what we have not provided test vectors). It sounds indeed reasonable to me have a longer seed in these cases!",
          "createdAt": "2022-05-20T16:19:19Z",
          "updatedAt": "2022-05-20T16:19:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I mean, anything longer than 32 is really overkill for security, but it might simplify implementations and help readability if there are less constants.",
          "createdAt": "2022-05-20T16:32:33Z",
          "updatedAt": "2022-05-20T16:32:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "On reflection, this seems like it would be confusing in practice, as some seeds we derive are totally unrelated to keys. Let's keep this as-is.",
          "createdAt": "2022-07-01T17:58:15Z",
          "updatedAt": "2022-07-01T17:58:15Z"
        }
      ]
    },
    {
      "number": 361,
      "id": "I_kwDOD79ejs5Khv8Y",
      "title": "Questions on OPAQUE Implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/361",
      "state": "CLOSED",
      "author": "afbase",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello @chris-wood ,\r\n\r\nI have some questions regarding some of the inputs, outputs, and implementation ideas i have in my head.  Hopefully they don't sound too off the mark here.\r\n\r\n1. **Offline Registration**: Can the offline registration server be different than the server in the online AKE?  \r\n    - I feel like the answer is yes, and if that is the case, as the offline registration server, I could then push any `RegistrationRecord` (or the subset of the registration record of the `client_public_key` and encrypted `envelope`  and the online AKE server can query an HSM/KMS for the masking key) to any Online AKE server.  Here is an example with a Client, (offline) Registration Server, (online) AKE'ing Microservice, and a Cloud HSM/KMS:\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client\r\n    participant Registration Server\r\n    participant AKE'ing Microservice\r\n    participant Cloud HSM/KMS\r\n    Client->>Registration Server: registration request\r\n    Registration Server->>Client: registration response\r\n    Client->>Registration Server: record\r\n    Registration Server->>AKE'ing Microservice: (record.envelope, record.client_public_key)\r\n    Registration Server->>Cloud HSM/KMS: store record.masking_key @ HSM/KMS\r\n    Client->>AKE'ing Microservice: KE1\r\n    AKE'ing Microservice->>Cloud HSM/KMS: Runs Expand with record.masking_key @ HSM/KMS\r\n    AKE'ing Microservice->>Client: KE2\r\n    Client->>AKE'ing Microservice: KE3\r\n```\r\n\r\n   - \u2b06\ufe0f  I feel like I'm missing a problematic assumption about the `server_private_key` here, i.e. the AKE'ing Microservice and Registration Server share the `server_private_key`.  Maybe it helps if it is also on the HSM/KMS???\r\n1. **password**:  Does it _need_ to be a password? A couple of ideas here, each separate and distinct but regard this question:\r\n     - Can this be a Client's private key instead that is different from the `client_private_key`?\r\n         - I've not really given much thought here nor am I sure why I would.\r\n2. If I'm an SSO provider (and acting as an offline registration server), I feel like I might just want to use OPAQUE as a third way to authenticate Clients instead of composing it with say SAML or OIDC as the two usual ways authentication + authorization is done, yes?  \r\n      - I just can't imagine composing OPAQUE registration or AKE'ing protocols with say OIDC ID tokens, access tokens, or refresh tokens, or SAML assertions.\r\n      - On the other hand, Can I use ID tokens, access tokens, or refresh tokens, or SAML assertions as a `client_identity`?  I don't know what is gained (or lost) by doing that.  I welcome any and all pointers on thinking about this in a different way.  \r\n3. **Application Layer Idea**: Apologies if this is very high level and not a lot of details explained.\r\n     - **HTTPS REST API Requests**: It would be really \"inefficient\" to use OPAQUE over HTTPS assuming the underlying TLS session provides communication security; but I might want to use OPAQUE to authentication an HTTPS REST API client with a password and not suffer from the [have I been pwned](https://haveibeenpwned.com) problem.  So suppose I am an HTTPS REST API client and have authenticated and have my `session_key`.\r\n       - If I'm the client and I go through the AKE to get the `session_key`, can I use my `client_private_key` to sign the session key and submit that to an authorization server that has my `client_public_key` to get a some kind of authorization token like a [biscuit](https://www.biscuitsec.org/docs/getting-started/introduction/)?\r\n       - can I use the `session_key` as-is for a bearer token for HTTPS requests? (This feels very wrong :zipper_mouth_face:)\r\n4. **Protocols that don't use TLS**: I'm drawing a bit of a blank as to other protocols that aren't TLS based that could stand to benefit from OPAQUE right now.  I would love to do a survey of protocols where OPAQUE might be better suited.",
      "createdAt": "2022-05-27T05:34:28Z",
      "updatedAt": "2022-12-06T10:47:03Z",
      "closedAt": "2022-12-06T10:47:03Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "regarding your 2nd 1st question, it's an PAKE where the P stands for password, and the password is treated as such (hashing it to a curve with a password hashing algorithm) - so if you have a private key instead of a password, then you could of course use it, but your public key would go unused, and if you already have a pub/priv keypair then there are other better protocols to achieve what opaque does. actually you only need the ake then, and can skip the OP part, so that means naked 3dh...",
          "createdAt": "2022-05-27T08:55:38Z",
          "updatedAt": "2022-05-27T09:10:26Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "re 4: i wrote this blogpost https://www.ctrlc.hu/~stef/blog/posts/Running_around_with_an_OPAQUE_hammer.html\r\nand later i realised the answer to be SASL, for which i wrote a mech: https://github.com/stef/libopaque/tree/master/sasl and even a mod for nginx https://github.com/stef/ngx_http_auth_sasl_module/ (but then https is already tls based)",
          "createdAt": "2022-05-27T08:58:25Z",
          "updatedAt": "2022-05-27T08:58:25Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> can I use the session_key as-is for a bearer token for HTTPS requests? (This feels very wrong zipper_mouth_face)\r\n\r\nyou should use the session_key as an ephemeral HOTP shared secret and do HMAC(kdf(session_key,domain_seperator), counter++) as a bearer token.",
          "createdAt": "2022-05-27T09:04:57Z",
          "updatedAt": "2022-05-27T09:07:09Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On the other hand, Can I use ID tokens, access tokens, or refresh tokens, or SAML assertions as a client_identity\r\n\r\nif those tokens stay constant over the life-time of an account?\r\nif these tokens are not constant over the life-time of an account, but need to be stored for some time, then you might consider this approach https://ctrlc.hu/~stef/blog/posts/How_to_recover_static_secrets_using_OPAQUE.html",
          "createdAt": "2022-05-27T09:13:35Z",
          "updatedAt": "2022-05-27T09:13:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@afbase it seems like @stef helped address most of your questions. Are there still things you're unsure about?",
          "createdAt": "2022-06-30T15:13:54Z",
          "updatedAt": "2022-06-30T15:13:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to lack of activity. @afbase, please do re-open if you still have unanswered questions!",
          "createdAt": "2022-12-06T10:47:03Z",
          "updatedAt": "2022-12-06T10:47:03Z"
        }
      ]
    },
    {
      "number": 363,
      "id": "I_kwDOD79ejs5KqWzy",
      "title": "\"ke2.inner_ke2\" is missing a definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/363",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "The \"inner_ke2\" field of ke2 is missing a definition, and needs a formal one somewhere.",
      "createdAt": "2022-05-30T11:41:43Z",
      "updatedAt": "2022-06-20T14:54:40Z",
      "closedAt": "2022-06-20T14:54:40Z",
      "comments": []
    },
    {
      "number": 369,
      "id": "I_kwDOD79ejs5QXTWL",
      "title": "`Ne` is undefined",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/369",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-opaque-09 and https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md both refer to `Ne`, but this value is not defined anywhere.\r\n\r\nTwo occurrences I found are the definition of `masked_response` [here](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-opaque-09#section-6.3.1), and `credential_response_pad` [here](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-opaque-09#section-6.3.2.2). There may be others.",
      "createdAt": "2022-08-23T17:21:52Z",
      "updatedAt": "2022-10-03T16:57:17Z",
      "closedAt": "2022-10-03T16:57:17Z",
      "comments": []
    },
    {
      "number": 370,
      "id": "I_kwDOD79ejs5RGtn_",
      "title": "OPAQUE-3DH config and example are inconsistent",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/370",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#configurations-configurations\r\nsays the following:\r\n> An OPAQUE-3DH configuration is a tuple (OPRF, KDF, MAC, Hash, KSF, Group, Context) ....\r\n\r\nand then a few lines below that this:\r\n\r\n> Absent an application-specific profile, the following configurations are RECOMMENDED:\r\n\r\n>    OPRF(ristretto255, SHA-512), HKDF-SHA-512, HMAC-SHA-512, SHA-512, Scrypt(32768,8,1), internal, ristretto255\r\n>    OPRF(P-256, SHA-256), HKDF-SHA-256, HMAC-SHA-256, SHA-256, Scrypt(32768,8,1), internal, P-256\r\n\r\nthe next to last tuple member `internal` is inconsistent with the first quoted line, instead the group should be listed here. and i'm not quite sure if it is correct for the context, for me this is confusing, what is this `internal` and how this relates - if at all - to the context.",
      "createdAt": "2022-09-03T01:11:27Z",
      "updatedAt": "2022-10-03T16:57:34Z",
      "closedAt": "2022-10-03T16:57:34Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the confusion. I believe this \"internal\" string should be omitted. It was introduced in https://github.com/cfrg/draft-irtf-cfrg-opaque/commit/950f2f0586dd03a2b3ffab11008c21a4d0d3f12b back when there was an \"external\" and \"internal\" mode for the envelope configuration portion of the protocol. Now that we no longer have those, we should have removed this internal configuration reference, but failed to.",
          "createdAt": "2022-09-12T01:01:20Z",
          "updatedAt": "2022-09-12T01:01:20Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed! Good catch \ud83d\udc4d",
          "createdAt": "2022-09-12T05:33:16Z",
          "updatedAt": "2022-09-12T05:33:16Z"
        }
      ]
    },
    {
      "number": 371,
      "id": "I_kwDOD79ejs5RHyGJ",
      "title": "why keyshare why not ephemeral key pairs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/371",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm confused by the term keyshare, this term doesn't tell me anything, and i think it obscures the nature of this value, the keyshare is nothing but an ephemeral key pair, and if we would call it that i think understanding would be easier.\r\n\r\nmaybe you use keyshare because it's a more generic term that applies to other opaque instantiations, but the current spec focuses on 3dh where the keyshare is really an ephemeral  keypair, please lets call it that.",
      "createdAt": "2022-09-04T00:27:59Z",
      "updatedAt": "2022-10-03T17:03:59Z",
      "closedAt": "2022-10-03T17:03:59Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @stef, thanks for the feedback. Can you clarify what exactly would be the proposed change here? I believe we use keyshare to refer to one half of the keypair, not the keypair itself. (keyshare = public component, private_keyshare = private component).\r\n\r\nAt the moment, there are the following four variables that have \"keyshare\" in their name:\r\n- `server_keyshare`\r\n- `client_keyshare`\r\n- `server_private_keyshare`\r\n- `client_private_keyshare`\r\n\r\nAre you suggesting that we alter these variable names? And if so, do you have a proposal for what these variables should be renamed to?\r\n\r\nThe terminology \"key share\" only appears as prose in the text in 3 locations (unless I missed some):\r\n1) In the definition of client_keyshare: \"A serialized client ephemeral key share of fixed size `Npk`.\"\r\n2) In the definition of server_keyshare: \"Server ephemeral key share of fixed size `Npk`, where `Npk`\r\ndepends on the corresponding prime order group.\"\r\n3) In the last paragraph of the \"SIGMA-I instantiation sketch\" section: \"[...] would use only the ephemeral key shares exchanged between client and server\"\r\n\r\nAre you proposing that we just replace \"ephemeral key share\" here with \"ephemeral public key\"?\r\n\r\nThanks in advance for any clarifications!",
          "createdAt": "2022-09-12T01:26:35Z",
          "updatedAt": "2022-09-12T01:26:35Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "The term _keyshare_ or _key share_ is a common term in Diffie-Hellman-protocol-like literature to designate the participants' key material that they share with each other.",
          "createdAt": "2022-09-12T05:48:49Z",
          "updatedAt": "2022-09-12T05:48:49Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Are you proposing that we just replace \"ephemeral key share\" here with \"ephemeral public key\"?\r\n\r\nthis! please! :)",
          "createdAt": "2022-09-12T21:11:50Z",
          "updatedAt": "2022-09-12T21:11:50Z"
        }
      ]
    },
    {
      "number": 375,
      "id": "I_kwDOD79ejs5TAXKe",
      "title": "Allow changing Preable construction & usage in OPAQUE-3DH",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/375",
      "state": "CLOSED",
      "author": "dequbed",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As of [4c36aa9](https://github.com/cfrg/draft-irtf-cfrg-opaque/commit/4c36aa9eede4f12c3d0cdbce196e9256af930671), the Preamble used by OPAQUE-3DH is defined as:\r\n```\r\nconcat(\"RFCXXXX\",\r\n       I2OSP(len(context), 2), context,\r\n       I2OSP(len(client_identity), 2), client_identity,\r\n       ke1,\r\n       I2OSP(len(server_identity), 2), server_identity,\r\n       credential_response,\r\n       server_nonce,\r\n       server_keyshare)\r\n```\r\n\r\nI'm currently working on a [SASL mechanism specification](https://github.com/dequbed/draft-reitzenstein-auth-opaque) using OPAQUE, where it would be benefitial to be able to construct this transcript hash, that is the `preamble`, in a very different way.\r\n\r\nFor one, due to SASLprep and encoding limitates enforced by the wire format, `client_identity` has three different representations. The mechanism specification would need to be careful to make clear which one is used in every context and it would make implementation bugs much more likely, as the representations only differ with identities containing complex unicode or characters such as '=' and ','.\r\n\r\nSecondly, while the preamble does have a `context` field parts of the data I would like to include are only available after the server response, making constructing the preamble using a running hash function impossible.\r\n\r\nI think this is a reasonably simple change as making 'preamble' an (opaque) parameter to `AuthServerRespond` and `AuthClientFinalize` instead of constructing it inline would already allow me to refer to those functions as-is instead of having to redefine them using a different preamble construction.\r\n\r\nIf this change is something that is wanted I'm happy to write a pull request with updated text to this end.",
      "createdAt": "2022-09-30T15:22:25Z",
      "updatedAt": "2022-10-06T17:31:05Z",
      "closedAt": "2022-10-06T17:31:05Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the preamble construction should be changed, as it is core to the security of the protocol and should be kept as required with this specific format. The preamble must incorporate its current parameters (client_identity, ke1, server_identity, ke2), as leaving any of them out would not be a good idea.\r\n\r\nPerhaps the way the elements are concatenated together could be adjusted without affecting security, but I don't think that that is what you are suggesting...",
          "createdAt": "2022-10-02T04:56:54Z",
          "updatedAt": "2022-10-02T04:56:54Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "may i ask why this is necessary? my guess would be that this is for channel binding? if so i don't think channel binding is a useful thing in the context of opaque, since each session is unique and thus implicitly channel-bound. channel binding only makes sense for auth protocols where the authentication token (hashed? password) is static and thus can be replayed/reused easily in other connections.",
          "createdAt": "2022-10-02T15:59:46Z",
          "updatedAt": "2022-10-02T15:59:46Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "NONE",
          "body": "Right, I put the cart before the horse here a bit.\r\n\r\nThe first thing I think that I should explain is that I'm treating OPAQUE in this application not as a complete monolithic and immutable protocol but rather as one that can be adapted to its application where necessary.\r\n\r\nIn this specific application I'm wrapping the OPAQUE exchange for authentication and have the requirement that some additional adjacent data is integrity protected and cryptographically bound into this authentication exchange.\r\n\r\nThe best approach for that is to protect this adjacent data with the MAC sent in KE2 and KE3.\r\n\r\nTo illustrate what I'm planning with an example, `C:` and `S:` meaning messages sent by the client and server side respectively (newlines and comments added for readability):\r\n\r\n```\r\nC: y=tls-exporter,a=admin,n=user,r=rqdPU7Jkr.../QdeUv2Re+uCl\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500 adjacent data  \u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500 b64 encoding of ke1 \u2500\u2518\r\n\r\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 adjacent data \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\nS: c=YYWzZcN...sq3Ur6/hHBfw==,i=dj0xOSxtPTQwO...D0zLHA9MQo=,\r\n   v=f7s7GPGMl2DPCgoPyqh...jhuYAWdMqC4yl3qZYmT58=,p=MAANo1c2VwPlWV7e...0PZhvrpjyKs3+Bko=\r\n   \u2514\u2500 b64 encoding of ke2 minus the server MAC \u2500\u2518   \u2514\u2500 b64 encoding of the server mac \u2500\u2518\r\n\r\nC: p=+HU90iCCXustmuDlOejEcig5inkRPlIraEDh7kJwT1w=\r\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 b64 encoding of ke3  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThis adjacent data is here the (client) Authorization and Authentication identities, channel binding data, and the parameters to the KSF that need to be used.\r\n\r\nMy approach to generating a preamble / transaction log here would be to construct a running hash over the wire-format messages and MAC that, the server mac running up to but excluding the `,p=` of its message. (Which is the reason why KE2 needs to be split up)\r\n\r\n\r\n\r\n> The preamble must incorporate its current parameters (client_identity, ke1, server_identity, ke2), as leaving any of them out would not be a good idea.\r\n\r\nYes, I am acutely aware of that and as you can see from my above example I do not plan to *exclude* any data from the transaction hash, and instead only want to *include* further important data. An open question is however that I would prefer to bind to the public keys of the parties and not other identities like usernames. However, including the public keys of both sides into the transaction log is merely an issue of *specifying it*.\r\n\r\n> Perhaps the way the elements are concatenated together could be adjusted without affecting security, but I don't think that that is what you are suggesting...\r\n\r\nI did in fact realize yesterday evening that a solution would be to use this adjacent data as `client_identity` and `server_identity` respectively. It would allow to keep the running hash and would solve most technological hurdles, but it does strike me as violating the spirit of the standard and also makes little obvious sense to users.\r\n\r\n\r\nre stef:\r\n\r\n> if so i don't think channel binding is a useful thing in the context of opaque, since each session is unique and thus implicitly channel-bound.\r\n\r\nChannel binding is about binding an authentication to an underlying encrypted channel like TLS and thus making sure that both sides see the same channel. That's very much not something that OPAQUE gives you implicitly.\r\n\r\n> channel binding only makes sense for auth protocols where the authentication token (hashed? password) is static and thus can be replayed/reused easily in other connections.\r\n\r\nWell, in that case channel binding would make sense because the password and server-side record are static and reused in other connections. :)",
          "createdAt": "2022-10-04T14:25:41Z",
          "updatedAt": "2022-10-04T14:25:41Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Channel binding is about binding an authentication to an underlying encrypted channel like TLS and thus making sure that both sides see the same channel. That's very much not something that OPAQUE gives you implicitly.\r\n\r\nok, it might seem a dumb question, but it's genuine. what does it matter if a channel is encrypted or not, if the goal is to make sure that both sides see the same channel? and if the two parties can authenticate each other (which they do) then presuming that the ephemeral keys are indeed only used once, the authentication is bound to that tcp connection - limiting here to tcp like transports makes sense i hope, with udp this might not work. so i think opaque does indeed bind to a channel implicitly, and i think the fact of it being encrypted does not matter, as long as the channel is tcp-like connection-based.\r\n",
          "createdAt": "2022-10-04T14:50:54Z",
          "updatedAt": "2022-10-04T14:50:54Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "NONE",
          "body": "@stef This is somewhat derailing the original issue by now, so I'm answering this in a new issue.",
          "createdAt": "2022-10-04T15:19:39Z",
          "updatedAt": "2022-10-04T15:19:39Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "NONE",
          "body": "As the approach of 'just shove it into the identities' does solve this particular need as far as I can tell I think its appropiate to close this issue for now.",
          "createdAt": "2022-10-06T17:31:04Z",
          "updatedAt": "2022-10-06T17:31:04Z"
        }
      ]
    },
    {
      "number": 376,
      "id": "I_kwDOD79ejs5UBHrJ",
      "title": "recommend argon2i instead of scrypt in configurations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/376",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "i would like to reopen this issue: https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/155#discussion_r586922995 since the reason for this is now solved, as there is now a rfc for this: https://www.rfc-editor.org/rfc/rfc9106.txt\r\n",
      "createdAt": "2022-10-14T16:20:01Z",
      "updatedAt": "2023-06-08T21:32:56Z",
      "closedAt": "2023-06-08T21:32:56Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "quoting here the original answer from the above review comment, since github hides it:\r\n\r\n> This is not a great answer, but.... we can't properly cite Argon2i as it's not yet an RFC. (The same is true of the OPRF draft, but that's a dependency we can't workaround.)\r\n\r\n> We can certainly change this to argon2i, or whatever, provided there's a suitable reference and evidence that the new thing is more widely supported than scrypt. The purpose of this is to be a recommendation for applications should they not know what they're doing.\r\n",
          "createdAt": "2022-10-14T16:22:18Z",
          "updatedAt": "2022-10-14T16:22:18Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef Do you have a recommendation for the exact parameters for Argon2?\r\n\r\nRight now, the recommendation for scrypt reads as: `Scrypt(32768,8,1)`\r\n\r\nWhat would be the equivalent for Argon2 / Argon2i (and what about Argon2id)?\r\n\r\nEdit: Or perhaps we can just be ambiguous about this, and simply state `Argon2` without specifying any parameters such as recommended salt length, etc. (which are already stated in the Argon2 RFC anyway)",
          "createdAt": "2022-11-02T02:21:14Z",
          "updatedAt": "2022-11-02T02:23:19Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @stef Do you have a recommendation for the exact parameters for Argon2?\r\n> \r\n> Right now, the recommendation for scrypt reads as: `Scrypt(32768,8,1)`\r\n\r\nthis seems to me approximately as an `INTERACTIVE` setup. \r\n\r\n> What would be the equivalent for Argon2 / Argon2i (and what about Argon2id)?\r\n\r\nthe paper only gives an algo how to determine these: https://github.com/P-H-C/phc-winner-argon2/raw/master/argon2-specs.pdf\r\n\r\nlooking at libsodium these are the parameters for the interactive versions of argon2:\r\n\r\n```\r\ncrypto_pwhash_argon2id.h\r\n66:#define crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE 2U\r\n70:#define crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE 2**26\r\n\r\ncrypto_pwhash_argon2i.h\r\n66:#define crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE 4U\r\n70:#define crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE 2**25\r\n```\r\n\r\nwhile the argon2 rfc recommends two settings, one using 2GB ram (which i think is not workable for phones) and a second one using 64MB ram:\r\n\r\n> If much less memory is available, a uniformly safe option is\r\n>  Argon2id with t=3 iterations, p=4 lanes, m=2^(16) (64 MiB of\r\n>  RAM), 128-bit salt, and 256-bit tag size.  This is the SECOND\r\n>  RECOMMENDED option.\r\n\r\n> Edit: Or perhaps we can just be ambiguous about this, and simply state `Argon2` without specifying any parameters such as recommended salt length, etc. (which are already stated in the Argon2 RFC anyway)\r\n\r\ni think the default variant should be Argon2id which is a hybrid protecting against sidechannels and is also the mandatory variant as per the RFC.\r\n\r\nso i guess we can/should recommend also argon2id.\r\n\r\nregarding what parameters, i have asked @jedisct1 why libsodium uses different params than the rfc (i guess because the latest sodium release predates the rfc) - i think it makes sense to choose parameters that are already widely used as defaults, thus the libsodium params as an alternative.\r\n",
          "createdAt": "2022-11-02T15:00:14Z",
          "updatedAt": "2022-11-02T15:00:14Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "body": "Especially with interactive settings, using multiple lanes to compute a single hash can quickly turn into a DoS vector. Doubling memory usage instead provides a similar security level.\r\n\r\nThat being said, none of these recommended settings is really useful. It all depends on the resources the service is going to have, what latency is acceptable for an interactive session, how many concurrent sessions will run in parallel, and what else will be sharing the same resources.\r\n",
          "createdAt": "2022-11-02T15:40:03Z",
          "updatedAt": "2022-11-02T15:40:03Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments and for providing the analysis! Perhaps we can avoid going into this discussion in the draft by just mentioning \"Argon2\" instead of \"Scrypt(...)\" as a recommendation without going into further details.\r\n\r\nSee https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/378 for the proposed change, and let me know if this looks OK, or if you think we should explicitly say \"Argon2id\" or something even more specific.",
          "createdAt": "2022-11-02T18:16:25Z",
          "updatedAt": "2022-11-02T18:16:25Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "body": "Looking good!\r\n\r\nFor interoperability purposes, explicitly saying \"Argon2id` may be a good idea, though.",
          "createdAt": "2022-11-02T19:37:02Z",
          "updatedAt": "2022-11-02T19:37:02Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That being said, none of these recommended settings is really useful. It all depends on the resources the service is going to have, what latency is acceptable for an interactive session, how many concurrent sessions will run in parallel, and what else will be sharing the same resources.\r\n\r\n@jedisct1 this KSF is only running on clients devices, not on servers.",
          "createdAt": "2022-11-02T19:52:40Z",
          "updatedAt": "2022-11-02T19:52:40Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "NONE",
          "body": "That was the justification for libsodium's parameters.\r\n\r\nBut on clients, doing recommendations is equally device-specific.",
          "createdAt": "2022-11-02T19:54:40Z",
          "updatedAt": "2022-11-02T19:54:40Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. I changed the text to recommend `Argon2id` instead of `Argon2` in the PR.",
          "createdAt": "2022-11-02T21:42:15Z",
          "updatedAt": "2022-11-02T21:42:15Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Negotiating the parameters as part of the protocol means we need the client to be able to verify/authenticate the parameters coming from the server. As @jedisct1, there's a risk of DoS with malicious parameters. But the KSF is used as part of the OPRF-PRK output, so we can't do that.\r\n\r\nI think parameters must therefore be defined or negotiated outside of the protocol, e.g. as application configuration, hardcoded parameters. @kevinlewi should we add that to the doc?",
          "createdAt": "2022-12-04T17:24:52Z",
          "updatedAt": "2022-12-04T17:24:52Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "actually it is not necessary to negotiate anything! the KSF and its params are completely client-side, and the server has no idea, and no way of verifying if a certain KSF configuration has been used by the client. as such the KSF and its configuration can be either just stored in a config file (next to the server address) on the client. or in many cases just use a default config which can be changed on the UI/preferences/configfile.",
          "createdAt": "2022-12-04T17:31:43Z",
          "updatedAt": "2022-12-04T17:31:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to @stef -- no negotiation is needed here. These all should be configured by the application as needed.",
          "createdAt": "2022-12-06T10:44:41Z",
          "updatedAt": "2022-12-06T10:53:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for chiming in late here, folks. I want to gently push back on the general idea that we ought not to included recommended parameters for Argon2. I think applications should of course be able to choose the parameters that bet fit their use case and threat model. However, for the _recommended_ profiles or configurations, which are meant to be turnkey options ready for use, I don't think we should burden the application with this choice. I think we ought to pick reasonable defaults here.",
          "createdAt": "2022-12-06T10:53:06Z",
          "updatedAt": "2022-12-06T10:53:06Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "since this is all gonna run on clients, and since a majority of the clients can be expected to be phones, and since i doubt that phones have 2GB of ram lying around for a KSF i recommend to use the 2nd recommendation from the rfc, which only needs 64MB of ram.",
          "createdAt": "2022-12-06T14:58:22Z",
          "updatedAt": "2022-12-06T14:58:22Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it. So right now we have one vote from @chris-wood for the first recommended option, and one vote from @stef for the second recommended option from the Argon spec.\r\n\r\nI think I am slightly in favor of the first recommended option, since I would say that we do not know what clients to expect, and if there are indeed clients with memory constraints, they can simply choose to use the second recommendation on their own.\r\n\r\nAlso, we already caveat the recommendations with the wording: \"Absent an application-specific profile ...\"\r\n\r\nLet me know if you have a particularly strong opinion against this @stef. For now, I'll put up a PR which recommends the first recommendation.",
          "createdAt": "2022-12-08T07:27:01Z",
          "updatedAt": "2022-12-08T07:27:01Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "nah, go for it! thx! <3",
          "createdAt": "2022-12-08T12:10:23Z",
          "updatedAt": "2022-12-08T12:10:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening this issue based on the topic in here: https://mailarchive.ietf.org/arch/msg/cfrg/7xBO1Yb8uYvb6-jPl7IKHbTqO8Q/\r\n\r\nI am OK with restoring the previous recommended configuration:\r\n\r\nP256-SHA256, HKDF-SHA-256, HMAC-SHA-256, SHA-256, scrypt(32768,8,1), P-256\r\n\r\n*in addition* to the Argon one. Note that we don't supply test vectors for the slow hashing function anyway, so this would effectively just be a one-line change.\r\n\r\n@stef, @jedisct1: wanted to get your thoughts on this as well, if you are against doing so. Thanks!",
          "createdAt": "2023-05-31T22:21:06Z",
          "updatedAt": "2023-05-31T22:21:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved.",
          "createdAt": "2023-06-08T21:32:56Z",
          "updatedAt": "2023-06-08T21:32:56Z"
        }
      ]
    },
    {
      "number": 382,
      "id": "I_kwDOD79ejs5dXq3a",
      "title": "Update Test Vectors to VOPRF draft version 17",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/382",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "Since VOPRF draft version 17 the Ciphersuite IDs have changed to being strings instead of a simple 2 byte integers.\r\nAdditionally the `CreateContextString` function changed the first string to `OPRFV1-` and added a `-` before the Ciphersuite ID.\r\n\r\nI have also noticed that the editor's copy actually links to the VOPRF draft version 17, even though the test vectors don't seem to have been updated.",
      "createdAt": "2023-02-01T17:07:29Z",
      "updatedAt": "2023-02-08T11:34:40Z",
      "closedAt": "2023-02-08T11:34:38Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @daxpedda \ud83d\udc4b \r\nhttps://github.com/cfrg/draft-irtf-cfrg-voprf/pull/347 seems to be modifying the poc API. I'll wait for this to be merged to update our poc (even though it has no impact on the vectors).",
          "createdAt": "2023-02-06T17:57:29Z",
          "updatedAt": "2023-02-06T17:57:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be done now. Closing.",
          "createdAt": "2023-02-08T11:34:38Z",
          "updatedAt": "2023-02-08T11:34:38Z"
        }
      ]
    },
    {
      "number": 384,
      "id": "I_kwDOD79ejs5eiqz6",
      "title": "Return values of the Recover and RecoverCredentials functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/384",
      "state": "CLOSED",
      "author": "stsch9",
      "authorAssociation": "NONE",
      "assignees": [
        "bytemare"
      ],
      "labels": [],
      "body": "The _ClientFinish_ function (Section 6.2.3) needs the _client_public_key_ if the _client_identity_ is empty. However, the _client_public_key_ is calculated in the _Recover_ function (Section 4.1.3). \r\nWould it therefore make sense that both the _Recover_ function and the _RecoverCredentials_ function (Section 6.3.2.3) return the _client_public_key_ so that it can also be used for the _AuthClientFinalize_ function (_client_identity_ = _client_public_key_ if _client_identity_ is empty)?",
      "createdAt": "2023-02-15T16:17:43Z",
      "updatedAt": "2023-03-27T00:12:12Z",
      "closedAt": "2023-03-27T00:12:12Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "That's what I actually do in my implementation. I makes sense to add it in the spec if it helps :)",
          "createdAt": "2023-03-10T17:13:06Z",
          "updatedAt": "2023-03-10T17:13:06Z"
        },
        {
          "author": "stsch9",
          "authorAssociation": "NONE",
          "body": "Thank you very much for the feedback. You are also welcome to close the issue.",
          "createdAt": "2023-03-12T13:34:05Z",
          "updatedAt": "2023-03-12T13:34:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare are you still able to send a PR for this?",
          "createdAt": "2023-03-20T18:38:34Z",
          "updatedAt": "2023-03-20T18:38:34Z"
        }
      ]
    },
    {
      "number": 386,
      "id": "I_kwDOD79ejs5fWkuT",
      "title": "Listing more implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/386",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was exploring OPAQUE implementations (especially in Go) and I have found more. Not sure if they should all be listed in the README, but I am documenting them here because it might help others:\r\n\r\n* https://github.com/bytemare/opaque (Go, one already listed, by one of authors of the spec, not audited)\r\n* https://github.com/facebook/opaque-ke (in Rust, now maintained by Facebook, audited)\r\n* https://github.com/cymony/cryptomony and https://github.com/cymony/cryptomonyjs-opaque (Go server side, JS client side, not audited)\r\n* https://github.com/jchauhan/gopaque, https://github.com/cretz/gopaque, https://github.com/ivn-nz/gopaque (Go, variations of the same codebase, not sure how maintained, not audited)\r\n* https://github.com/frekui/opaque (Go, old, not audited)\r\n* https://github.com/gustin/opaque (Rust, old, not audited)\r\n* https://github.com/stef/libopaque (C, already listed, with bindings for many other languages, not audited)\r\n* https://github.com/cloudflare/opaque-core (Go, reference implementation, not audited)",
      "createdAt": "2023-02-25T16:08:03Z",
      "updatedAt": "2023-03-09T08:17:04Z",
      "closedAt": "2023-03-09T08:17:04Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "We only list implementations for which the authors have requested to be listed. Very often they validate the vectors.\r\n\"Old\" implementations usually don't implement the spec, but the original paper, and are not compliant with the spec.\r\n(And as for the third implementation you listed, it's a plain copy of my implementations where they stripped the license/copyright).\r\n\r\nDo you see here an issue to be addressed? If not, I suggest we close that ticket.",
          "createdAt": "2023-03-08T22:25:48Z",
          "updatedAt": "2023-03-08T22:25:48Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We only list implementations for which the authors have requested to be listed.\r\n\r\nI see. Then we can close this.",
          "createdAt": "2023-03-09T08:17:04Z",
          "updatedAt": "2023-03-09T08:17:04Z"
        }
      ]
    },
    {
      "number": 388,
      "id": "I_kwDOD79ejs5fX5YO",
      "title": "User enumeration on registration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/388",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reading the spec, I see that there is in few places explained how to prevent user enumeration at login time, e.g., by returning fake envelops to the client. But I also see that user enumeration on registration is not really addressed and just rate limiting is suggested as a mitigation. To me this means that attacker would simply be doing user enumeration through registration and not login. If both are not protected attacker picks the unprotected path, not the protected path.\r\n\r\nI think that maybe all this about user enumeration should be removed from the spec. Because as it currently stands you start reading it and you think that OPAQUE is protected against user enumeration and then in the last paragraph of 10.9 you read that it is incomplete and thus not really. Spec should just suggest rate limiting as mitigation both for login and registration.\r\n\r\n---\r\n\r\nOne way to address this could be if there was a way to combine registration and login flows into one flow (potentially with unnecessary messages/data) and client would simply always do the same flow: if user is already registered, they would authenticate to the server, if they are not, they would both register and authenticate to the server. I am not (yet) familiar enough with OPAQUE too see if this would be possible and how, so I am bringing it here.\r\n\r\nOne way I think it might work is if servers would be constructing envelopes (as it was in JKX18, but without encrypted credentials). Then server could construct a new one if user is not yet registered, or send an existing one if user is already registered. For client there would be no difference and would do the same in both cases.\r\n\r\nBut this approach seems to enable MITM attack (currently the identity of the server is pinned at the registration time by storing the server public key into the envelope, if I understand correctly). But by using a TLS channel this might be mitigated?",
      "createdAt": "2023-02-26T15:37:02Z",
      "updatedAt": "2023-04-16T20:25:53Z",
      "closedAt": "2023-04-16T20:25:53Z",
      "comments": [
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having login and registration as one step could also address #392.",
          "createdAt": "2023-02-26T19:54:10Z",
          "updatedAt": "2023-02-26T19:54:10Z"
        },
        {
          "author": "cyyynthia",
          "authorAssociation": "NONE",
          "body": "I think you're completely missing the point by assuming only a single threat model applies. In a setting where a form has both a login and registration form, there is no need to prevent enumeration on the login form as the registration form will naturally leak this information.\r\n\r\nHowever, in a setting where the registration is locked behind prior authorization (there is no way to register an account without prior authorization), there is no registration form to target. In these scenarios, having user enumeration protection *does* make sense and the protocol reflects its ready for these use cases, where user enumeration is a concern in your threat model.\r\n\r\nThis is something that already exists in traditional username/password logins, where accounts can be enumerated via the register form regardless of any protection applied onto your login form.\r\n\r\nI'm unsure about what you mean by mixing up both flows as a way to mitigate it. If the user doesn't exist, then the password used during registration will always be valid \"first-try\", enabling the attacker to know it was a successful registration attempt. Unnecessary traffic would be bad for the efficiency of the protocol, which already is quite heavy on low-end devices considering the password derivation is done by the client in addition of the cryptographic operations going on.\r\n\r\nMy understanding is that the authentication side of the protocol is capable of being resilient to enumeration attacks, and is documented as such. The registration process is not capable of such resilience due to its very nature, which is also documented as such. It's then up to the users of the protocol to see if these properties fit their threat model, how they must use OPAQUE to fit said threat model, and what additional measures they must take to fully address their threat model.",
          "createdAt": "2023-03-04T20:07:02Z",
          "updatedAt": "2023-03-04T20:07:02Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, maybe I was not clear here. My motivation is to have a system where user enumeration is not possible for both login and registration flows. And I know how to do that using standard \"send password to the server and hash it there\" way of storing passwords. It works by combining registration and login flow into one flow and tie it with one-time code as 2FA. So user is prompted with a form with two fields: email and password. They enter them and press \"login or register\" button. Now there are three options:\r\n\r\n* Account is already registered with that e-mail and password was correct for that account. In that case, user is logged in (or some 2FA is invoked).\r\n* Account is not yet registered with that e-mail, then one-time code is send to the e-mail address and user is asked to enter that code. After entering the correct code, a new account is registered and e-mail address has been validated. It is like usual \"activate your account\" flow, just combined to prevent enumeration.\r\n  * If user does not have access to the e-mail, no information is leaked to the user about e-mail address having or not an account.\r\n* Account is already registered with that e-mail, but the password is not correct, then one-time code is send to the e-mail address and user is asked to enter that code. After entering the correct code, user is logged in. They can be optionally prompted to reset their password. This flow is like usual \"reset your password\" flow, just combined to prevent enumeration.\r\n  * If user does not know the password, no information is leaked to the user about e-mail address having or not an account.\r\n\r\nNow, I am trying to see how could I use OPAQUE and prevent user enumeration both at login and registration time. This is why I am thinking that maybe combining login and registration flows into one flow could help here as well to achieve it.",
          "createdAt": "2023-03-05T22:24:29Z",
          "updatedAt": "2023-03-05T22:26:06Z"
        },
        {
          "author": "cyyynthia",
          "authorAssociation": "NONE",
          "body": "I think your approach could be much simpler and better on the users, by still keeping both separate and only applying special treatment to the registration. Having it setup this way is absolutely horrible for the user experience as an invalid password immediately trips an implicit password reset which isn't great.\r\n\r\nIf you keep both forms separate, you can still treat duplicate registrations as an attempt to password reset, store the hashed password in a temporary place, and have the user confirm the change by email. So a failed login doesn't cause unnecessary noise on the user, while having the registration endpoint not leak anything about the status of that email, and perform the same-ish operations and prevent a possible timing attack.\r\n\r\nApplying this to the OPAQUE protocol, in the event of a duplicate registration, store the RegistrationRecord somewhere temporary and send the user a confirmation email, if they want to confirm the password change or not (possibly, word clearly what's going on to avoid confusion, UX stuff blah blah blah). If the change is confirmed, persist the record, otherwise let it expire and discard it from your database.\r\n\r\nThis allows your flow to have a better UX, better fits the way OPAQUE works, and doesn't leak registered emails on the registration form. Unless I'm missing something.\r\n\r\nEdit: In fact, you can skip altogether sending the user anything and just fully engage in the protocol, pretend to say \"Please check your email for the next steps\", while not sending anything. This probably is the best approach UX wise, but be careful to not cause any timing attacks where an attacker could observe if an email has been sent or not.\r\n\r\nEdit 2: Better for UX provided your users don't forget they have an account... Might still be a good idea to send an email to let them know the registration attempt failed because there's already an account here and link them the password reset procedure if necessary... Either way, just fully engage in the protocol and transmit the results via email to avoid leaking anything, and you should be good to go",
          "createdAt": "2023-03-06T00:30:12Z",
          "updatedAt": "2023-03-06T00:47:19Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Having it setup this way is absolutely horrible for the user experience as an invalid password immediately trips an implicit password reset which isn't great.\r\n\r\nIt is not exactly password reset, but login with a code. They do not have to reset the password after the login (but are prompted by a non-modal message that the password was wrong, if they want to reset it). This workflow comes from three insights:\r\n\r\n* Users are more and more using password managers, so wrong passwords are rare.\r\n* Those users who do make mistakes are generally those who use site rarely and do not even remember if they do have an account or not. For them it is often a very confused process. They start login, they get their password wrong, then they decide that maybe they do not have an account (they do not remember well), they start registration, registration complains that e-mail is already in use, they go to password reset, etc.\r\n* Most sites use \"login with code\" for password reset, trusting such login fully (in my system you are prompted with another 2FA if user has it enabled).\r\n\r\nSo if password reset is already trusted, then it does not really matter if user logged in with (correct) password or just one time code. In fact, they can jump to one time code directly, without messing up the password. :-) And maybe they configured that one time code is not their 2FA, then when they enter the wrong password and get to one time code dialog, they know they messed it up and can go back.\r\n\r\nBut I have not yet done user studies to test this workflow to see if it is horrible. :-) So really thanks for your feedback.\r\n\r\n> If you keep both forms separate, you can still treat duplicate registrations as an attempt to password reset, store the hashed password in a temporary place, and have the user confirm the change by email.\r\n\r\nThat is a good proposal. I am trying to remove the need for them to make a decision \"do I have an account here already or not\" though. (But I am not sure if it is a good solution to remove that decision. It is currently my intuition after observing issues some users had using authentication on some other projects.)\r\n\r\n> So a failed login doesn't cause unnecessary noise on the user\r\n\r\nThat is a good point.\r\n\r\nAnyway, we are getting too specific about my own system here and maybe we should move this elsewhere, feel free to chime in at https://gitlab.com/charon/charon (project is still in early stages and not yet pushed). Thank you.\r\n\r\nTrying to tie this back in to OPAQUE:\r\n\r\n> Applying this to the OPAQUE protocol, ...\r\n\r\nThat is a great proposal and should probably be documented somewhere (e.g., that registration enumeration can be prevented by linking it to another verification, like e-mail address verification, before anything is leaked).\r\n\r\nBut I think combining both login and registration in OPAQUE could still be possible with simply registration be done every time, and simply both login and registration messages be send at the same time to the server, if login is correct, registration is discarded, otherwise the flow you proposed above is attempted.",
          "createdAt": "2023-03-06T12:35:11Z",
          "updatedAt": "2023-03-06T12:35:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mitar I'm sorry for the delay here. My take is that we should _not_ remove user enumeration support in the draft, as (a) that would be a fairly invasive and breaking change, and (b) it is possible to implement registration such that it does not easily allow enumeration (perhaps by using the \"go check your email for a link\" method above, or similar). As we worked on this document, we tried to carefully balance the diversity of threat models in which this protocol might be deployed and concluded that what's currently in the draft was a reasonable balance of real world considerations.\r\n\r\n@kevinlewi, @bytemare: what do you think?",
          "createdAt": "2023-03-21T11:44:23Z",
          "updatedAt": "2023-03-21T11:44:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the original purpose behind giving instructions for handling client enumeration was to match parity against a \"normal password login form\", where the client hashes the password and sends it to the server over a secure channel. In normal password login, the client sends a single message to the server, which the server then takes and can output whether or not the password matched registration for that user. This gives the server the ability to obscure whether or not a wrong password was entered for a registered account, versus the account not being registered.\r\n\r\nNow, when attempting to use OPAQUE for a password login form, one big difference is that login now takes multiple steps, where the server must send a response to the client that could leak whether or not the user was registered. Therefore, a server that implements OPAQUE (without the fake credential responses) would no longer have the ability to obscure the existence of a registration, should they desire to do so. This was the purpose of introducing the fake credential responses -- so that we could give servers this option that exists in the normal flow.\r\n\r\nHowever, in the normal password login flow (where registration isn't gated behind some other authentication mechanism), this information could still be leaked through registration. I don't think it is within our plans for this OPAQUE spec to try to go beyond what normal password login flows achieve.\r\n\r\nSo if there is an application that does want to try to prevent user enumeration through registration, I believe it should be handled outside of the scope of the OPAQUE protocol. And one way that sounds viable for addressing this is to combine the registration and login flows.",
          "createdAt": "2023-03-22T08:43:03Z",
          "updatedAt": "2023-03-22T08:43:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi would you be supportive of adding text to the Application Considerations section that touches on this? ",
          "createdAt": "2023-03-22T12:55:30Z",
          "updatedAt": "2023-03-22T12:55:30Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The section on Client Enumeration already has the text in the last paragraph giving the caveat that OPAQUE doesn't prevent these attacks during the registration flow:\r\n\r\n> OPAQUE does not prevent either type of attack during the registration flow. Servers necessarily react differently during the registration flow between registered and unregistered clients. This allows an attacker to use the server's response during registration as an oracle for whether a given client identity is registered. Applications should mitigate against this type of attack by rate limiting or otherwise restricting the registration flow.\r\n\r\nI don't think there is any need to add the background context I provided above into the document itself. But do let me know if you think there is a specific part which would be valuable to include...",
          "createdAt": "2023-03-22T20:30:07Z",
          "updatedAt": "2023-03-22T20:30:07Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue as resolved (but feel free to reopen if it isn't).",
          "createdAt": "2023-04-16T20:25:53Z",
          "updatedAt": "2023-04-16T20:25:53Z"
        }
      ]
    },
    {
      "number": 389,
      "id": "I_kwDOD79ejs5fX54P",
      "title": "Distributing the server",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/389",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial"
      ],
      "body": "In [10.11 Password Salt and Storage Implications](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-password-salt-and-storage-i) it says:\r\n\r\n> OPAQUE enables defense against such offline dictionary attacks by distributing the server so that an offline attack is only possible if all - or a minimal number of - servers are compromised [[JKX18](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#JKX18)].\r\n\r\nMy understanding is that the OPAQUE in the paper describes how one could distribute the server, but this spec itself does not mention this anywhere? (Or have I missed it.) Probably using a threshold OPRF? I think it would be beneficial to the spec if this would be more fleshed out somewhere. Or made into one of showcased features of OPAQUE. I think this is a cool feature but currently one finds hidden inside one set of parenthesis.",
      "createdAt": "2023-02-26T15:43:13Z",
      "updatedAt": "2023-03-22T12:54:15Z",
      "closedAt": "2023-03-22T12:54:15Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "afaik, there is no cfrg/irtf specification for t-oprf, and much less implementations, the only one i am aware of is mine at  https://github.com/stef/liboprf/ . anyway the paper and the spec here deviate in a couple of points, so t-opaque is one of those really. on the other hand it is possible to implement t-oprf in a way, that a proxy hides the threshold setup from the client, and thus could enable a threshold opaque without any changes to the spec itself.",
          "createdAt": "2023-02-26T15:55:35Z",
          "updatedAt": "2023-02-26T15:55:35Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My main issue here is that the paragraph is confusing because OPAQUE here is about the one from the paper. Maybe the solution could be to write something like:\r\n\r\n> OPAQUE [[JKX18](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#JKX18)] enables defense against such offline dictionary attacks by distributing the server so that an offline attack is only possible if all - or a minimal number of - servers are compromised. This is out of the scope of this spec.",
          "createdAt": "2023-02-26T16:05:29Z",
          "updatedAt": "2023-02-26T16:05:29Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "This suggestion sounds reasonable to me.\r\n@chris-wood @kevinlewi what do you think?",
          "createdAt": "2023-03-08T22:30:06Z",
          "updatedAt": "2023-03-08T22:30:06Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point, I think it would be a good idea to clarify that threshold OPAQUE is out of scope for this spec, since as @mitar mentioned, it is described in the paper. Thanks for bringing this up!",
          "createdAt": "2023-03-08T22:33:46Z",
          "updatedAt": "2023-03-08T22:33:46Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i think it is very much possible to implement a threshold opaque without violating the spec.",
          "createdAt": "2023-03-08T22:37:41Z",
          "updatedAt": "2023-03-08T22:37:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest to keep this \"informational-only\" remark. Note that the remark touches on an implementation of the server, not a change to OPAQUE.  Namely, this mention the possibility of implementing the server's OPRF in a distributed manner. This is a strong defense against essentially the only inherent remaining weakness of a \"strong aPAKE\", namely, offline dictionary attacks upon server compromise. By distributing the OPRF, you need t+1 parties to be compromised and only then you can start running the offline attack. Actually, with the 2HashDH implementation you  get that even if you break into all n servers, you still need an full offline dictionary attack against the password. In short: I propose to keep the remark on a distributed implementation, possibly mentioning a distributed OPRF rather than just \"distributing the server\", and definitely adding the sentence that this is out-of-scope for this specification.",
          "createdAt": "2023-03-21T15:52:29Z",
          "updatedAt": "2023-03-21T15:52:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> By distributing the OPRF, you need t+1 parties to be compromised and only then you can start running the offline attack.\r\n\r\nI don't agree with this assessment. With a server-side threshold OPRF, it's true that the OPRF computation is split across n different servers, but there is still one entity which combines t of them to compute the OPRF value. The threat model doesn't change here: just compromise the entity that combines these values together.\r\n\r\nFundamentally, if the motivation to use a threshold OPRF is to distribute trust in the server away from a single entity, then a server-only threshold OPRF implementation doesn't solve that problem.\r\n\r\nEDIT: Ah, wait! You said _offline_ attack, which, yes, I would agree with. I don't think this helps with the online attack though.",
          "createdAt": "2023-03-21T16:39:22Z",
          "updatedAt": "2023-03-21T16:40:29Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "since the value is blinded, the combining/proxy oprf evaluate function does not learn anything about either the secret of the client, nor of the distributed oprf key. and the combining/proxy oprf evaluate function needs to query the distributed oprf shares for every bruteforce attempt, thus eliminating server offline bruteforce attacks, and thus making them online.",
          "createdAt": "2023-03-21T16:44:08Z",
          "updatedAt": "2023-03-21T16:44:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I misunderstood the original comment and agree that a server-only threshold implementation forces attacks to either be online or for an attacker to compromise t different key shares. ",
          "createdAt": "2023-03-21T16:45:56Z",
          "updatedAt": "2023-03-21T16:45:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "glad that this has been cleared up! <3",
          "createdAt": "2023-03-21T16:47:17Z",
          "updatedAt": "2023-03-21T16:47:17Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello @hugokraw,\r\nI took some of your words in your comment to brew a paragraph mentioning TOPPSS, here: https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/397\r\n\r\nMay I ask you to take a look and tell me what you think?",
          "createdAt": "2023-03-21T22:40:54Z",
          "updatedAt": "2023-03-21T22:40:54Z"
        }
      ]
    },
    {
      "number": 390,
      "id": "I_kwDOD79ejs5fX7zH",
      "title": "Use of server_private_key in offline registration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/390",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial"
      ],
      "body": "In [5. Offline Registration](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-offline-registration-2) it lists `server_private_key` as input, but it is not used anywhere in the registration protocol shown later on.",
      "createdAt": "2023-02-26T16:07:21Z",
      "updatedAt": "2023-03-22T12:54:16Z",
      "closedAt": "2023-03-22T12:54:16Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed! Good catch !",
          "createdAt": "2023-03-08T22:34:56Z",
          "updatedAt": "2023-03-08T22:34:56Z"
        }
      ]
    },
    {
      "number": 391,
      "id": "I_kwDOD79ejs5fYA3x",
      "title": "Is server private key used in AKE protocol?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/391",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In [6. Online Authenticated Key Exchange](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-online-authenticated-key-exc) it is listed that `server_private_key` is input to the AKE protocol, but in [10.12. AKE Private Key Storage](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-ake-private-key-storage) it says:\r\n\r\n> Server implementations of OPAQUE do not need access to the raw AKE private key.\r\n\r\nDo do server implementations need a private key or not? Or is this not the same private key and is something else?",
      "createdAt": "2023-02-26T17:13:42Z",
      "updatedAt": "2023-03-09T08:28:44Z",
      "closedAt": "2023-03-09T08:28:44Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "The answer to your question should be in the rest of the paragraph.\r\n\r\nA server implementation could delegate operations with the AKE private key to a dedicated backend. The protocol doesn't need raw access to the private key (in contrast with the public key) but needs \"something\" to perform the AKE on its behalf, like using an HSM for example.",
          "createdAt": "2023-03-08T22:41:41Z",
          "updatedAt": "2023-03-08T22:41:41Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see. Thanks.",
          "createdAt": "2023-03-09T08:28:44Z",
          "updatedAt": "2023-03-09T08:28:44Z"
        }
      ]
    },
    {
      "number": 392,
      "id": "I_kwDOD79ejs5fYMzv",
      "title": "Rotating server keypair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/392",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I am missing mention/protocol/description of how can the server keypair be rotated. To me this is a bit surprising because I am used for keys to have expiration and are rotated before that expiration. OPAQUE seems to expect that server keys will be in use forever or at least be changed only after a compromise?\r\n\r\nCurrently, the only way I can see that rotation is done is by having support for that in clients so that they re-register after successful login. But clients might misbehave or simply skip that step. It looks to me like a potential deployment nightmare where some clients keep using old keypair.",
      "createdAt": "2023-02-26T19:53:40Z",
      "updatedAt": "2023-03-22T12:25:52Z",
      "closedAt": "2023-03-22T12:25:52Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "A client is not supposed to \"keep using old keypairs\": it fetches the server's public key on each run.\r\n\r\nBut indeed, when the server updates its AKE key pair, the client must re-register a new envelope.",
          "createdAt": "2023-03-08T22:51:08Z",
          "updatedAt": "2023-03-08T22:51:08Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A client is not supposed to \"keep using old keypairs\": it fetches the server's public key on each run.\r\n\r\nHmmm. I must say this sounds a bit strange here. So public keypair is stored in the envelope client obtains from the server. Are you saying that it also additional fetches server's current public key? So what if they differ? How does it know if this means that the server rotated its key pair and the client should re-register a new envelope or that there is an attack and somebody is doing MITM? Or it does not matter?\r\n\r\n> But indeed, when the server updates its AKE key pair, the client must re-register a new envelope.\r\n\r\nSo I think the question is how does the client know when to do so?",
          "createdAt": "2023-03-09T22:19:39Z",
          "updatedAt": "2023-03-09T22:19:39Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "> So public keypair is stored in the envelope client obtains from the server. Are you saying that it also additional fetches the server's current public key?\r\n\r\nNo, no key is stored in the envelope. The envelope holds a nonce and authentication tag. The authentication tag is computed, among other values, over the server's public key. The server sends its public key to the client alongside the envelope. It's almost the same. But yes, through this the server commits to using the same key.\r\n\r\n> So I think the question is how does the client know when to do so?\r\n\r\nSince that is an application-specific problem, it would be up to the application to inform the client.",
          "createdAt": "2023-03-10T09:00:21Z",
          "updatedAt": "2023-03-10T09:00:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's note this in the application consideration section as something apps ought to, well, consider. Similar to #394, this is something that would likely require re-registration.",
          "createdAt": "2023-03-20T18:31:44Z",
          "updatedAt": "2023-03-20T18:31:44Z"
        }
      ]
    },
    {
      "number": 393,
      "id": "I_kwDOD79ejs5fYRRk",
      "title": "Registration requires integrity protected channel",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/393",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "> Registration is the only stage in OPAQUE that requires a server-authenticated and confidential channel: either physical, out-of-band, PKI-based, etc.\r\n\r\nI think the channel also has to protect integrity?",
      "createdAt": "2023-02-26T20:54:52Z",
      "updatedAt": "2023-03-22T12:25:11Z",
      "closedAt": "2023-03-22T12:25:11Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps this should be:\r\n\r\n> Registration is the only stage in OPAQUE that requires a server-authenticated channel with confidentiality and integrity: either physical, out-of-band, PKI-based, etc.\r\n\r\n",
          "createdAt": "2023-03-20T18:29:02Z",
          "updatedAt": "2023-03-20T18:29:02Z"
        }
      ]
    },
    {
      "number": 394,
      "id": "I_kwDOD79ejs5fYTSd",
      "title": "Migration to a new protocol version, hash, etc.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/394",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "editorial"
      ],
      "body": "With regular password based authentication when the client sends the password to the server over TLS connection, migration to new ways of storing passwords is relatively easy: on successful login you migrate the user to new version or new hash, etc. Completely transparent to the user/client.\r\n\r\nI am trying to understand how can this be done with OPAQUE. For example, how to bump hash complexity or pick a new hash? It looks like client would have to do that in some way (similar to #392).\r\n\r\nShould a description of steps here be documented in the spec? Some recommended practice?\r\n\r\nMaybe the solution is to always do both registration and login, which would probably address this, #392, and #388. In a way this is what sending plaintext password is: you can register the user, login the user, or even both at the same time, with the same type of a message (username and password) to the server.",
      "createdAt": "2023-02-26T21:20:18Z",
      "updatedAt": "2023-03-22T12:25:52Z",
      "closedAt": "2023-03-22T12:25:52Z",
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/294 for some previous discussion.",
          "createdAt": "2023-02-26T22:10:11Z",
          "updatedAt": "2023-02-26T22:10:11Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "if your question is regarding password hashing, the server is completely indifferent what algo you use to hash your password for password hardening. you can use whatever password hashing algo and difficulty you prefer, the server has absolutely no clue about what you're doing. changing either of these is the same problem as changing the password itself, the client needs to do a re-registration.",
          "createdAt": "2023-02-28T01:18:25Z",
          "updatedAt": "2023-02-28T01:18:25Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I understand that client fully controls that. What I would probably I like is to is in the spec a protocol for:\r\n\r\n> the client needs to do a re-registration\r\n\r\nSo it probably means client first does login with old protocol/hash version and then re-registration with a new one. But are there any security considerations here so that server could not be tricked into doing something bad? Like how you tie the login with registration? Are messages around this something which should be standardized or is this left completely to the implementer to implement? I just worry that I would miss something and that this would open a security hole. Maybe this is not something which has to be in the spec, but only in client library implementations, providing an easy API to do this.",
          "createdAt": "2023-03-02T16:07:47Z",
          "updatedAt": "2023-03-02T16:07:47Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For example, it would be neat if protocol would include \"force re-registration\" flag in messages or something. So that if the server is compromised, one could start issuing that on login to communicate to client libraries to do re-registration.",
          "createdAt": "2023-03-02T16:16:19Z",
          "updatedAt": "2023-03-02T16:16:46Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I understand all your points, but I agree that this may need some clearer explanation.\r\n\r\nI wouldn't add anything operational to the protocol at this point, though. I see this more as something to be handled on a higher, application, level than in the core protocol.",
          "createdAt": "2023-03-08T22:57:16Z",
          "updatedAt": "2023-03-08T22:57:16Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree here, for most of this a good library could handle handling this. I think the only thing left is if there are needs for messages to include some version, or some other flags, which would help client libraries do the right thing and if we should standardize those?",
          "createdAt": "2023-03-09T22:21:45Z",
          "updatedAt": "2023-03-09T22:21:45Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "What version are you thinking about?\r\n\r\nAlso, users are free to embed a standard OPAQUE message into another one including a version, e.g.\r\n```\r\nstruct {\r\n  OPAQUEMessage bytes;\r\n  Version string;\r\n  SomethingElse string;\r\n} KE2;\r\n```\r\n\r\nThe spec doesn't have a notion of versioning in the protocol, yet, and I don't know whether it will. That's why it's left out.\r\n\r\nBut remember there are Ciphersuite identifiers, that specify different parameters. Would that answer your need for versioning?",
          "createdAt": "2023-03-10T08:31:23Z",
          "updatedAt": "2023-03-10T08:31:41Z"
        }
      ]
    },
    {
      "number": 395,
      "id": "I_kwDOD79ejs5fYZhy",
      "title": "Slowing down attacks on compromised database",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/395",
      "state": "CLOSED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Section [10.8. OPRF Key Stretching](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-oprf-key-stretching) explains:\r\n\r\n> that applications must consider a tradeoff between the performance of the protocol on clients (specifically low-end devices) and protection against offline attacks after a server compromise.\r\n\r\nThis is very high-level and not very instructive for how exactly can one find sweet spot in this tradeoff. Especially the issue here is that somebody integrating OPAQUE into their applications might not be savvy enough to do make this call. (I like how [Ory](https://www.ory.sh/choose-recommended-argon2-parameters-password-hashing/#use-open-source-to-choose-recommended-parameters) made a script to help their integrators to determine good configuration.)\r\n\r\nTo my understanding the underlying issue here is that there is a fundamental issue with OPAQUE: because hash is computed on the client side and not on the server side, integrator of OPAQUE has much less control and even understanding of capabilities clients might have, not to mention that the diversity of client devices is higher and thus one generally has to pick the least resource intensive hash configuration for good user experience for all or most users or at least less resource intensive configuration than what one for server-side would be (e.g., mobile devices has less memory and CPU power than a server). As such it looks to me that OPAQUE already makes a trade-off and weakens offline attacks protection for protecting passwords in transit.\r\n\r\nI feel spec is slightly misleading here. When I started reading it it looked to me like perfect combination of things: a) expensive hashing is done on the client b) no password is stored on the server in any form c) password is never send to the server. But even if password is not stored on the server in any form, server contains everything needed for (bruteforce or dictionary) attacking and trying to determine the password. OPAQUE just replaces one one-way function (hashing) with another (decryption without a key). And we generally now know how to have slow hashing functions, while decryption we generally still optimize for speed. So the only thing standing in way of how fast you can do an offline attack is the hashing configuration intended for the client.\r\n\r\nTogether with no good story on how to upgrade hashing configuration (#394) this looks to me like a pretty important downside of OPAQUE. And leaving to integrators to determine how to solve this does not feel good to me. Maybe OPAQUE is missing one more piece which would make the offline attack harder while client hashing would be what protects data in transit?",
      "createdAt": "2023-02-26T22:49:08Z",
      "updatedAt": "2023-05-22T19:53:34Z",
      "closedAt": "2023-05-22T19:53:34Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "n.b. \"upgrade hashing configuration\" is exactly the same problem and solution as when the user wants to upgrade their password. this is because the server is completely oblivious regarding the used password hashing algo or difficulty.\r\n\r\nand thus an attacker who has access to a leaked database of opaque server side records, has absolutely no clue (from the opaque server records only only) which record is protected by which password hashing algo and difficulty (assuming a multitude of clients and configs here), so in this case the attacker has to guess a triple, algo/difficulty/password to succeed with an offline bruteforce attack. good luck with that :)",
          "createdAt": "2023-02-28T01:25:10Z",
          "updatedAt": "2023-02-28T01:25:10Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> so in this case the attacker has to guess a triple, algo/difficulty/password to succeed with an offline bruteforce attack\r\n\r\nNeat, I didn't think about that. But this is security through obscurity, so I am not sure if it counts. :-) At least for web apps, you get client code served easily. But yea, it is a nice idea.",
          "createdAt": "2023-03-02T16:12:43Z",
          "updatedAt": "2023-03-02T16:12:43Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > so in this case the attacker has to guess a triple, algo/difficulty/password to succeed with an offline bruteforce attack\r\n> \r\n> Neat, I didn't think about that. But this is security through obscurity, so I am not sure if it counts. :-) At least for web apps, you get client code served easily. But yea, it is a nice idea.\r\n\r\nwell, even if you get the code for the webapp, you don't get the configuration of the user for this webapp? what if every user has their own preferences stored locally?",
          "createdAt": "2023-03-02T16:17:35Z",
          "updatedAt": "2023-03-02T16:17:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay, @mitar! And thanks for filing the issue. The complete text in Section 10.8 reads:\r\n\r\n> Applying a key stretching function to the output of the OPRF greatly increases the cost of an offline attack upon the compromise of the credential file at the server. Applications SHOULD select parameters that balance cost and complexity. Note that in OPAQUE, the key stretching function is executed by the client, as opposed to the server. This means that applications must consider a tradeoff between the performance of the protocol on clients (specifically low-end devices) and protection against offline attacks after a server compromise.\r\n\r\nWhile this doesn't exactly say _how_ key stretching parameters ought to be chosen, it does seem to make the tradeoff clear.\r\n\r\nAre you asking for clarity on how the parameters ought to be chosen, perhaps by pointing to common examples? Or maybe you're asking for additional text about how this tradeoff is unique to OPAQUE compared to other password hashing scenarios? Do you have suggested text you might add?",
          "createdAt": "2023-03-20T18:25:51Z",
          "updatedAt": "2023-03-20T18:27:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mitar we're going to close this in the absence of concrete suggestions on how to make the tradeoff. Please feel free to reopen if you feel strongly that something should be done here, and ideally if you also have something specific to add, change, or remove!",
          "createdAt": "2023-05-22T19:53:32Z",
          "updatedAt": "2023-05-22T19:53:32Z"
        }
      ]
    },
    {
      "number": 398,
      "id": "I_kwDOD79ejs5glBlF",
      "title": "`params` in `Stretch`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/398",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "When investigating what the right salt to use for Argon2 is, I noticed that the spec talks says the following:\r\n> Stretch(msg, params): Apply a key stretching function with parameters `params` to stretch the input `msg` and harden it against offline dictionary attacks.\r\n\r\nI'm not sure what `params` is supposed to be here and it's not specified anywhere else. I believe this should be removed from the spec?\r\n\r\n---\r\n\r\nFor context:\r\nI noticed that some OPAQUE implementations use a zero salt for Argon2, which I believe is incorrect. For example in Rust, Argon2 implementations sometimes **require** a salt, which according to the Argon2 specification is not correct. So OPAQUE implementations just used a zero salt.",
      "createdAt": "2023-03-12T10:53:06Z",
      "updatedAt": "2023-03-22T12:25:51Z",
      "closedAt": "2023-03-22T12:25:51Z",
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@stef, I found that you also used an all zero salt in your KSF instead of none.\r\n\r\nhttps://github.com/stef/libopaque/blob/6037463f4faae04ade5a1fb53acc647075cf4caa/src/opaque.c#L205\r\n\r\nIf somebody could correct me here, my assumption from reading the spec is that a salt is **not** required. So shouldn't using no salt at all be preferred over an all zero salt, as long as the specification allows it?\r\n\r\nTo my knowledge Argon2 does allow it:\r\nhttps://www.rfc-editor.org/rfc/rfc9106#section-3.1-2.2\r\n> Nonce S, which is a salt for password hashing applications. It MUST have a length not greater than 2^(32)-1 bytes. 16 bytes is RECOMMENDED for password hashing. The salt SHOULD be unique for each password.\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc9106#section-3.2-3.1.1\r\n> If K, X, or S has zero length, it is just absent, but its length field remains.",
          "createdAt": "2023-03-12T11:04:13Z",
          "updatedAt": "2023-03-12T11:04:13Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hey, correct, i supply all zeros salt to pwhash. this is due to two reasons:\r\n\r\n1/ sodium_pwhash requires a salt. see here https://libsodium.gitbook.io/doc/password_hashing/default_phf#key-derivation and in the code verifying params here: https://github.com/jedisct1/libsodium/blob/master/src/libsodium/crypto_pwhash/argon2/argon2-core.c#L257-L270\r\n\r\n2/ until may 23 (hail eris!) 2020 the spec contained the phrase:\r\n\r\n> We note that the salt value typically input into the KDF can be set to a constant, e.g., all zeros. \r\n\r\nwhich was removed with https://github.com/cfrg/draft-irtf-cfrg-opaque/commit/4503e46e694907fdf610cf02a8ad1b53aecd7e02#diff-09a16f0dd79bfde63faf766f3c58ba43f6795026ce020fa36006cfec7094cf0aL527\r\n\r\nregarding 1/ i think sodium made the right choice and removed a footgun, so people cannot do pwhash without a salt, which in general i think is a bad thing to do (TM). and i think if some rust implementations do allow pwhashes without salts, that is actually quite reckless, so much  for the safety of rust (*snicker*). regarding 2/ i think it is historical, and i think it makes sense to actually get it back and spell it out, that since implementations out there sometimes require salts, to always require an all zero salt here. ",
          "createdAt": "2023-03-12T14:05:24Z",
          "updatedAt": "2023-03-12T14:05:59Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "btw here is a discussion on params in argon2i https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/376\r\n\r\nit is a difficult one, and i think the right solution is to have it configurable by the client who also needs to store and remember this configuration. every client should use the hardest possible solution that still is sufficient for interactive use. and that is very different on my ryzen7, a raspi 1b+, and some iphone, especially also considering available ram.",
          "createdAt": "2023-03-12T14:10:20Z",
          "updatedAt": "2023-03-12T14:10:20Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> regarding 1/ i think sodium made the right choice and removed a footgun, so people cannot do pwhash without a salt, which in general i think is a bad thing to do (TM). and i think if some rust implementations do allow pwhashes without salts, that is actually quite reckless\r\n\r\nI do agree that libraries should not make an API that is easy to abuse in this context. I'm unaware of any Rust Argon2 implementation that has an API without a minimum salt requirement, but depending on the outcome here I would have proposed a raw/unsafe API that does exactly that for the use-case with OPAQUE in the Rust libraries we use. I don't know anything about `pwhash` but maybe they could do the same.\r\n\r\nAll in all it would be simpler of course to just use an all zero salt, but for compatibilities sake the spec should definitely say something about it.\r\n\r\n> it is a difficult one, and i think the right solution is to have it configurable by the client who also needs to store and remember this configuration. every client should use the hardest possible solution that still is sufficient for interactive use.\r\n\r\nThis is probably off-topic but here are my two cents:\r\nAs ideal as that would be, it's not really applicable to all use cases. In our case we can't expect users to have a saved configuration because they might not always use the same device or loose their device.\r\n\r\nOf course one could save the configuration on the server and then send it to the user ... which would be bad for user enumeration and privacy ... you could also pre-define multiple levels, if a user tries to log in on a new device you could just run all levels ... you see where this is going.",
          "createdAt": "2023-03-12T14:17:48Z",
          "updatedAt": "2023-03-12T14:19:30Z"
        }
      ]
    },
    {
      "number": 399,
      "id": "I_kwDOD79ejs5gtKfq",
      "title": "Include test vectors for Argon2id ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/399",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Current test vectors use the Identity function as KSF.\r\nwhile PoC implementation uses scrypt. ",
      "createdAt": "2023-03-13T23:19:07Z",
      "updatedAt": "2023-03-22T12:25:51Z",
      "closedAt": "2023-03-22T12:25:51Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the problem is that the params are device dependent, see more info here https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/376",
          "createdAt": "2023-03-14T01:19:38Z",
          "updatedAt": "2023-03-14T01:19:38Z"
        }
      ]
    },
    {
      "number": 400,
      "id": "I_kwDOD79ejs5gtLNE",
      "title": "what is the salt value for Argon2id?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/400",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In the parametrization for KSF=Argon2id there is no specification for the salt parameter expected by Argon2id.\r\n\r\nAccording to [spec](https://www.password-hashing.net/argon2-specs.pdf): \"...salt must be at least 8 bytes, and 16 for password hashing...\"",
      "createdAt": "2023-03-13T23:21:39Z",
      "updatedAt": "2023-03-22T12:25:50Z",
      "closedAt": "2023-03-22T12:25:50Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "duplicate of https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/398 ?",
          "createdAt": "2023-03-14T01:18:48Z",
          "updatedAt": "2023-03-14T01:18:48Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> According to [spec](https://www.password-hashing.net/argon2-specs.pdf): \"...salt must be at least 8 bytes, and 16 for password hashing...\"\r\n\r\nThe IETF spec, the one this spec relies on, doesn't actually enforce a salt:\r\nhttps://www.rfc-editor.org/rfc/rfc9106#section-3.1-2.2\r\n> Nonce S, which is a salt for password hashing applications. It MUST have a length not greater than 2^(32)-1 bytes. 16 bytes is RECOMMENDED for password hashing. The salt SHOULD be unique for each password.",
          "createdAt": "2023-03-21T12:04:16Z",
          "updatedAt": "2023-03-21T12:04:16Z"
        }
      ]
    },
    {
      "number": 406,
      "id": "I_kwDOD79ejs5hzuaI",
      "title": "Harmonize variable and function names",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/406",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Some variables and functions have different names between the spec and the POC. I suggest we use the same names for clarity.",
      "createdAt": "2023-03-26T15:08:26Z",
      "updatedAt": "2023-04-01T23:27:27Z",
      "closedAt": "2023-04-01T23:27:27Z",
      "comments": []
    },
    {
      "number": 410,
      "id": "I_kwDOD79ejs5kK1mm",
      "title": "2 factor authentication",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/410",
      "state": "CLOSED",
      "author": "stsch9",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Many applications have the requirement to offer a 2 factor authentication.\r\nWould it be possible to integrate 2 factor authentication directly into the Opache protocol. \r\nA suggestion:\r\nInstead of deriving the per-client seed (the seed used to derive per-client OPRF keys) with\r\n```\r\nseed = Expand(oprf_seed, concat(credential_identifier, \"OprfKey\"), Nok)\r\n```\r\n(see [Section 5.2.2)](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-5.2.2) the server chooses a random seed per client:\r\n```\r\nseed = random(Nok)\r\n```\r\nThe server has a secret key to encrypt the seed and sends the encrypted seed to the client during offline registration, so that the client cannot decrypt the seed. The server does not store the encrypted seed.\r\n\r\nThis means: The client has to know its password and send the encrypted seed to the server to authenticate successfully.\r\n\r\nI am aware that the client has to store the encrypted seed. Also, the encrypted secret must be distributed to all devices of the client. This is not very user friendly.\r\n\r\nFor example, to combine Opache with TOTP authentication, i think TOTP authentication should be performed first, followed by Opache authentication, since the export key and the session key should be known at the end of the authentication process.",
      "createdAt": "2023-04-24T06:43:05Z",
      "updatedAt": "2023-05-10T18:36:21Z",
      "closedAt": "2023-05-10T18:36:21Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In OPAQUE, the setting is that the client only needs to know the password (and no other information) to be able to authenticate and complete the login step. So unfortunately I don't think that this mechanism that you describe would be incorporated directly into the OPAQUE protocol.",
          "createdAt": "2023-05-09T18:00:04Z",
          "updatedAt": "2023-05-09T18:00:04Z"
        },
        {
          "author": "stsch9",
          "authorAssociation": "NONE",
          "body": "Thank you for the answer. Of course you are welcome to close the issue.",
          "createdAt": "2023-05-10T07:17:45Z",
          "updatedAt": "2023-05-10T07:17:45Z"
        }
      ]
    },
    {
      "number": 412,
      "id": "I_kwDOD79ejs5nSrfc",
      "title": "detecting password change",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/412",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In a new paper by Hao et all https://eprint.iacr.org/2023/768 in the 3rd argument for designing an alternative for OPAQUE is the following:\r\n\r\n> 3) After OPAQUE was selected by IETF, it was discovered that the original protocol reveals information to passive observers about whether the password has been recently changed during a login session [16]. Although this revelation may at first appear minor, it can be of significant concern in practice. Recall that the main motivation for augmented PAKE is to address the threat of \u201cserver com- promise\u201d. In principle, with the stolen credentials from a compromised server, the attacker is able to launch brute-force attacks to uncover plaintext passwords, but this is a time-consuming process. If a user diligently updates the password, her account on the server can remain secure. However, many users may be slow to update passwords. By passively monitoring the login sessions for all users, an attacker learns valuable information to identify those who have not changed the password and hence prioritizes the brute-force attack against those users. SPR-6a does not appear to have this problem.\r\n\r\ni looked up the reference, which is a paper by Hao https://eprint.iacr.org/2021/839 - i was unable to find this issue on a quick skimming. and i am not sure i can immediately pinpoint where such an information leak would be possible in the current draft during the login.\r\n\r\ni think others might stumble on this paper and wonder if and how this is considered in the draft, so it might be prudent ;) to address this issue, perhaps in the security considerations?",
      "createdAt": "2023-05-30T20:25:25Z",
      "updatedAt": "2023-06-11T02:30:13Z",
      "closedAt": "2023-06-11T02:30:13Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "We call this attack \"client enumeration\", and it was indeed missing from the original protocol, but since then we have addressed it: see related issues #183, #210 for instance.\r\n\r\nWe also have the subsection on Client Enumeration in the draft, which is already included within the Security Considerations section. So I think we've more or less addressed it, falling short of explicitly making a reference to the paper in the draft.\r\n\r\nWill let others chime in with their thoughts, but I'd be in favor of closing this issue without modification to the current draft.\r\n\r\n",
          "createdAt": "2023-06-01T06:20:42Z",
          "updatedAt": "2023-06-01T06:20:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "well, client enumeration is an attack detecting the existence of users, according to the quote the infoleak leaks something different it leaks if the users changed their password.",
          "createdAt": "2023-06-01T11:51:44Z",
          "updatedAt": "2023-06-01T11:51:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "We define \"client enumeration\" differently. From the doc:\r\n\r\nClient enumeration refers to attacks where the attacker tries to learn extra information about the behavior of clients that have registered with the server. There are two types of attacks we consider:\r\n- An attacker tries to learn whether a given client identity is registered with a server, and\r\n- An attacker tries to learn whether a given client identity has recently completed registration, re-registered (e.g. after a password change), or changed its identity.\r\n\r\nI believe the second bullet point is exactly referring to what was quoted, no?",
          "createdAt": "2023-06-01T20:25:32Z",
          "updatedAt": "2023-06-01T20:25:32Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hmm, ok. if the doc defines it like this. it's a bit confusing to deviate from the normal interpretation. but i guess it's ok. maybe put a footnote to the paper in the issue that the spec as is does not have the problem that is listed in that paper? just to make it explicit.",
          "createdAt": "2023-06-01T20:36:48Z",
          "updatedAt": "2023-06-01T20:37:06Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, so in regards to adding a footnote with a link to the paper, I am not sure if we should essentially set the precedent that any paper in the future which claims a weakness in OPAQUE is something that we should mention that we have addressed in the spec.\r\n\r\nI'm in favor of not mentioning the paper, but will also let others chime in. @chris-wood , @bytemare ",
          "createdAt": "2023-06-01T20:50:03Z",
          "updatedAt": "2023-06-01T20:50:03Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hmmm, you do have a good point with this \"not making a precedent\". i agree.",
          "createdAt": "2023-06-01T21:40:55Z",
          "updatedAt": "2023-06-01T21:40:55Z"
        }
      ]
    },
    {
      "number": 414,
      "id": "I_kwDOD79ejs5nWnwr",
      "title": "Random Oracle Requirements for AKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/414",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "During https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/404 a question came up on why a random oracle is required for the NIST and Ristretto ciphersuites but not for Curve25519: https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/404#discussion_r1148436284.\r\n\r\nCurrently NIST and Ristretto use the OPRF `DeriveKeyPair` function: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21#name-deterministic-key-generatio. Which is more complicated and also compute intensive then simply using the NIST [ECDSA Key Pair Generation by Rejection Sampling](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf#[{%22num%22%3A156%2C%22gen%22%3A0}%2C{%22name%22%3A%22XYZ%22}%2C70%2C409%2C0]).\r\n\r\nAs far as I can tell, if `HashToScalar` can be dropped in key generation for the AKE without any security concerns, it would be an overall gain for the specification; reducing complexity and computational requirements.",
      "createdAt": "2023-05-31T11:20:16Z",
      "updatedAt": "2023-07-10T23:42:06Z",
      "closedAt": "2023-07-10T23:42:06Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ^",
          "createdAt": "2023-06-01T06:35:34Z",
          "updatedAt": "2023-06-01T06:35:34Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "I don't think you need a kdf for curve25519, but how people get to the seed matters.\n\nYou might look at BIP44 and BIP39 and see if there is anything relevant.",
          "createdAt": "2023-06-09T12:33:25Z",
          "updatedAt": "2023-06-09T12:33:25Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chiming in here -- I also don't think we need to KDF the input seed\r\n\r\nNote that the input is already presumed to be a (pseudo)-random output:\r\n```\r\nseed = Expand(randomized_password, concat(envelope.nonce, \"PrivateKey\"), Nseed)\r\n(client_private_key, client_public_key) = DeriveDiffieHellmanKeyPair(seed)\r\n```\r\n\r\nI recommend we close this issue without changing anything.",
          "createdAt": "2023-07-10T23:09:24Z",
          "updatedAt": "2023-07-10T23:09:24Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there might be a misunderstand here, my suggestions is to **not** use KDF for the input seed.\r\n\r\nSpecifically we currently do **not** use `DeriveKeyPair` for Curve25519. I want to extend **not** using `DeriveKeyPair` for the other curves as well.",
          "createdAt": "2023-07-10T23:26:31Z",
          "updatedAt": "2023-07-10T23:26:31Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think there might be a misunderstand here, my suggestions is to **not** use KDF for the input seed.\r\n> \r\n> Specifically we currently do **not** use `DeriveKeyPair` for Curve25519. I want to extend **not** using `DeriveKeyPair` for the other curves as well.\r\n\r\nOh, thanks for the clarification! I think the original message got lost a bit after a small game of telephone, and I perpetrated that, sorry :)\r\n\r\nI think we should continue using `DeriveKeyPair` for the other curves as well. Curve25519 is an exception because you can take a random bytestring and interpret it as a scalar, safely (well, you have to do the Curve25519 clamping operations, but those are efficient and constant-time).\r\n\r\nHowever, ristretto255 and P-256 do need to do HashToScalar in order to be considered secure, and this is done in VOPRF. The VOPRF draft also references the hash-to-curve draft about this, from https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#name-hashing-to-a-finite-field:\r\n\r\n> Implementors MUST NOT use rejection sampling to generate a uniformly random element of F, to ensure that the hash_to_field function is amenable to constant-time implementation. The reason is that rejection sampling procedures are difficult to implement in constant time, and later well-meaning \"optimizations\" may silently render an implementation non constant-time. This means that any hash_to_field function based on rejection sampling would be incompatible with constant-time implementation.\r\n\r\nSo, I believe curve25519 is a unique beast in that respect. But dropping HashToScalar for ristretto255 and P-256 would be a mistake.",
          "createdAt": "2023-07-10T23:38:47Z",
          "updatedAt": "2023-07-10T23:38:47Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, thank you, I missed that.\r\n\r\nI think that pretty much answers my question and resolves this issue.",
          "createdAt": "2023-07-10T23:42:06Z",
          "updatedAt": "2023-07-10T23:42:06Z"
        }
      ]
    },
    {
      "number": 418,
      "id": "I_kwDOD79ejs5vDZO1",
      "title": "Incorrect signature of function `Preamble`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/418",
      "state": "CLOSED",
      "author": "k13n",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The signature of function `Preamble` in Section 6.4.2.1 is not aligned with its description nor its function body. The function has a parameter `ke2` that's not used inside the function. Values `credential_response`, `server_nonce`, and `server_public_keyshare` are used in the function body, but are not passed in as parameters.\r\n\r\nCurrently the signature is `Preamble(client_identity, ke1, server_identity, ke2)`, but it probably should be `Preamble(client_identity, ke1, server_identity, credential_response, server_nonce, server_public_keyshare)`",
      "createdAt": "2023-08-23T11:41:14Z",
      "updatedAt": "2023-09-28T15:00:38Z",
      "closedAt": "2023-09-28T15:00:38Z",
      "comments": [
        {
          "author": "k13n",
          "authorAssociation": "NONE",
          "body": "As I'm going through the algorithms I've spotted minor typos or things like that. What's the best way to report them? Just append them to this issue?",
          "createdAt": "2023-08-24T13:19:03Z",
          "updatedAt": "2023-08-24T13:19:03Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, feel free to append to this issue, or open multiple issues. Thanks!!",
          "createdAt": "2023-09-07T07:54:29Z",
          "updatedAt": "2023-09-07T07:54:29Z"
        },
        {
          "author": "k13n",
          "authorAssociation": "NONE",
          "body": "Ok thanks, here are some more tiny issues:\r\n\r\nIn function `AuthServerRespond` the value `expected_client_mac` is computed twice (I think the first line can be dropped):\r\n```\r\nexpected_client_mac = MAC(Km3, Hash(concat(preamble, server_mac)))\r\nstate.expected_client_mac = MAC(Km3, Hash(concat(preamble, server_mac)))\r\n```\r\n\r\nIn function `AuthClientFinalize` the value `ke2.server_mac` is used that doesn't exist, it should be `ke2.auth_response.server_mac`\r\n\r\nIn function `GenerateKE3` the value `server_public_key` is returned from `RecoverCredentials`, but it's never used in `GenerateKE3`.\r\n",
          "createdAt": "2023-09-27T11:10:45Z",
          "updatedAt": "2023-09-27T11:10:45Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for surfacing these -- we are really fortunate to have these caught!",
          "createdAt": "2023-09-28T04:00:46Z",
          "updatedAt": "2023-09-28T04:00:46Z"
        }
      ]
    },
    {
      "number": 426,
      "id": "I_kwDOD79ejs5yEo7T",
      "title": "Inconsistency about OPRF seed reusage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/426",
      "state": "CLOSED",
      "author": "daxpedda",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/66834054528d1daf4f68d730fb95c15d625006d0/draft-irtf-cfrg-opaque.md?plain=1#L487-L489\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/blob/66834054528d1daf4f68d730fb95c15d625006d0/draft-irtf-cfrg-opaque.md?plain=1#L792-L793\r\n\r\nIt says \"SHOULD\", so I guess it might not actually conflict, but maybe the first statement should link to the second statement.",
      "createdAt": "2023-09-26T15:49:47Z",
      "updatedAt": "2023-10-05T21:29:48Z",
      "closedAt": "2023-10-05T21:29:40Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The first statement is really just intended to refer to the flexibility that we give to an implementor to not use the same seed for all clients. For instance, they could choose to use a unique seed per client (but of course that seed needs to stay the same between registration and login). I added a sentence which should hopefully help to clarify this in #427 ",
          "createdAt": "2023-09-28T03:10:12Z",
          "updatedAt": "2023-09-28T03:10:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as completed by #427.",
          "createdAt": "2023-10-05T21:29:40Z",
          "updatedAt": "2023-10-05T21:29:48Z"
        }
      ]
    },
    {
      "number": 434,
      "id": "I_kwDOD79ejs50kdhs",
      "title": "checking of password strength",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/434",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "the section `Password Salt and Storage Implications` says the following:\r\n\r\n> Some applications may require learning the client's password for enforcing password rules. Doing so invalidates this important security property of OPAQUE and is NOT RECOMMENDED.\r\n\r\ni agree that this is not a good thing, and also should not be recommended, but maybe caveat this, with \"depending on threat model, for example internal corporate deployments are possible exceptions were enforcement of strong password policies is mandated by regulation\"\r\n\r\n> Applications should move such checks to the client.\r\n\r\n\"malicious\" clients can easily ignore password rules, and the server will never know about this. This can be a problem when corporate rules mandate strong passwords, but users want to circumvent this for whatever reason (mostly lazyness?) - this is well known rule in application security that the server should never trust any input validation by the client.\r\n\r\n> Note that limited checks at the server are possible to implement, e.g., detecting repeated passwords upon re-registrations or password change.\r\n\r\ni wonder how this would work, can someone enlighten me?",
      "createdAt": "2023-10-22T00:57:17Z",
      "updatedAt": "2024-02-28T16:58:11Z",
      "closedAt": "2024-02-27T09:18:53Z",
      "comments": [
        {
          "author": "odiferousmint",
          "authorAssociation": "NONE",
          "body": "> > Applications should move such checks to the client.\r\n> \r\n> \"malicious\" clients can easily ignore password rules, and the server will never know about this. This can be a problem when corporate rules mandate strong passwords, but users want to circumvent this for whatever reason (mostly lazyness?) - this is well known rule in application security that the server should never trust any input validation by the client.\r\n> \r\n> > Note that limited checks at the server are possible to implement, e.g., detecting repeated passwords upon re-registrations or password change.\r\n> \r\n> i wonder how this would work, can someone enlighten me?\r\n\r\nI have not finished reading the document, but I assume that we can tell whether the password is the same or not (as it was on the initial registration) based on the data associated with the client that we store (such as `Opaque_UserRecord`[1]). Either way, supposedly the server may store information related to the client that should make us able to tell that the password has either remained the same (repeated password, theoretically could keep a counter per registration), or that it is different (password change).\r\n\r\nPre-define `TRACE` when compiling, and then perform the registration at least three times (two identical, one different password) and then you will gain more insight as to what has changed and what did not change and when.\r\n\r\n[1] https://github.com/stef/libopaque/blob/master/src/opaque.c#L61 tells me that `Opaque_UserRecord` may definitely be stored at the server upon registration. I assume - depending on what they claimed - that at least one of those values remains the same across registrations as long as the password is the same.\r\n\r\n---\r\n\r\n> server should never trust any input validation by the client.\r\n\r\nIn many cases it is true, the server must have its own checks, be it for input validation or whatever else. That said, as per specification, the protocol provides forward secrecy and the ability to hide the password from the server, even during password registration. Ultimately it is up to the application whether or not it wants the password, but I believe it would defeat the purpose of using OPAQUE to begin with.",
          "createdAt": "2023-10-22T01:25:13Z",
          "updatedAt": "2023-10-22T02:00:55Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ah, the the mac of the envelope will not change if nothing (even the password - password reuse) changes on re-registration. if the prf key is not changed. but 1/ reregistration itself is not well specified and 2/ i think how and where prf key comes from in such a case is neither, i do not think its a good idea to not change the prf key on reregistration. ",
          "createdAt": "2023-10-22T09:52:04Z",
          "updatedAt": "2023-10-22T09:54:45Z"
        },
        {
          "author": "odiferousmint",
          "authorAssociation": "NONE",
          "body": "> ah, the the mac of the envelope will not change if nothing (even the password - password reuse) changes on re-registration. if the prf key is not changed. but 1/ reregistration itself is not well specified and 2/ i think how and where prf key comes from in such a case is neither, i do not think its a good idea to not change the prf key on reregistration.\r\n\r\nYeah, I do not know if it is supposed to NOT change, but I do not like the idea of it not changing, to be honest.",
          "createdAt": "2023-10-22T11:03:07Z",
          "updatedAt": "2023-10-22T11:03:07Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the enforcement of strong password policies because it is mandated by regulation: I agree that this is to some extent in conflict with OPAQUE, because it fundamentally does not allow the server to perform these password checks server-side. In fact, I feel like if it is absolutely required for these server-side checks to be done on the password, then OPAQUE should not be used. Therefore, I feel like the wording should stay as-is, without the caveat.\r\n\r\n(However, in practice, I feel like doing client-side checks should still suffice. Perhaps this is dependent on the regulation, but I feel like if a client is specifically trying to get around client-side checks to make a weaker password, then this is the client's fault, not the server's. But that's just my opinion of course :) )\r\n\r\nSome other comments:\r\n1. Note that limited checks at the server are possible to implement, e.g., detecting repeated passwords upon re-registrations or password change. This would work by essentially simulating the login mechanism using the old record with the server and checking if it succeeds. Note that it requires the client to be honest and report the success, which in my opinion is sufficient, but perhaps if there are regulations which mandate this to be foolproof, would not suffice.\r\n2. I am not sure I am understanding, but the MAC will indeed change if the password is re-used upon re-registration. This is because, at the very least envelope_nonce gets sampled randomly. To be clear, upon re-registration, we should be completely clearing the old record, and re-running all of the procedures for envelope creation from scratch. Ok, fair enough, if the client chooses to remember these nonces and re-use them during re-registration, then they would be leaking information to the server about this. But again this is an instance of a client shooting themselves in the foot.",
          "createdAt": "2023-11-06T19:16:22Z",
          "updatedAt": "2023-11-06T19:16:22Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Regarding the enforcement of strong password policies because it is mandated by regulation: I agree that this is to some extent in conflict with OPAQUE, \r\n> because it fundamentally does not allow the server to perform these password checks server-side.\r\n\r\nuhm, but the original paper provides exactly such a registration function and mentions it even that the password strength can be checked using this approach. to say \"fundamentally does not allow\" is in direct contradiction with the original paper.\r\n\r\n> In fact, I feel like if it is absolutely required for these server-side checks to be done on the password, then OPAQUE should not be used. Therefore, I feel like the wording should stay as-is, without the caveat.\r\n\r\ni think even if the one-shot registration of the paper is implemented, and the password is exposed once to the server, the other benefits and security guarantees of opaque make it still the best solution otherwise.\r\n\r\nso i would like to insist to have this wording changed and acknowledged that there are other use-cases.\r\n\r\n",
          "createdAt": "2023-11-18T19:56:11Z",
          "updatedAt": "2023-11-18T19:56:11Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef: Oh interesting, do you have a reference to where in the original OPAQUE paper this is explained? I am looking at the top of page 48 of https://eprint.iacr.org/2018/163.pdf:\r\n\r\n\"Note that this prevents S from checking password\r\nrules, an operation that can be moved to the client side (restricted server-side\r\nchecks such as preventing the repeat of a recent password can be implemented).\"\r\n\r\nIs there wording elsewhere in the paper that indicates that these password strength checks can be done server-side?\r\n\r\nAlso, can you offer a suggested PR / change to the text to address your concern? IMO the \"NOT RECOMMENDED\" wording implicitly carries a caveat that applications may have different requirements and doesn't enforce that the application can't do these password checks on the server's side already.",
          "createdAt": "2023-12-04T19:19:00Z",
          "updatedAt": "2023-12-04T19:19:00Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've been looking at previous versions of the paper (since also my local copy has a bit different wording) and found that the section you quoted previously said:\r\n\r\n> A problem arises with this approach if S\u2019s policy is to check the user\u2019s password for compliance with some rules.\r\n\r\ni must admit i remember something more explicit on this topic. but can't find it myself, but knowing that Hugo likes to have multiple papers on the same topic, it might be that my confusion comes from one of his other papers...\r\n\r\ni'll try to draft a proposal that caveats the contended fragment.",
          "createdAt": "2023-12-05T00:41:26Z",
          "updatedAt": "2023-12-05T00:41:26Z"
        },
        {
          "author": "bbeallo12",
          "authorAssociation": "NONE",
          "body": "After reading this thread, I have a question.\r\nWould there be a way for the client to cryptographically prove to the server it hasn't been tampered with in a way only the genuine client could do?",
          "createdAt": "2023-12-07T23:57:00Z",
          "updatedAt": "2023-12-07T23:57:00Z"
        },
        {
          "author": "bbeallo12",
          "authorAssociation": "NONE",
          "body": "Also doesn't the existence of 2FA make the password complexity issue a non-issue?  If the password is guessed, they still need the 2FA. At which point the user is notified of the attempted login and can easily change their password.\r\n\r\nIf you also require a new 2FA token along with the password change, doesn't that make it even better?",
          "createdAt": "2023-12-08T00:04:24Z",
          "updatedAt": "2023-12-08T00:04:24Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Also doesn't the existence of 2FA make the password complexity issue a non-issue? If the password is guessed, they still need the 2FA. At which point the user is notified of the attempted login and can easily change their password.\r\n> \r\n> If you also require a new 2FA token along with the password change, doesn't that make it even better?\r\n\r\nOPAQUE is essentially and AKE, and has nothing to do with 2FA, OPAQUE can be part of a 2FA scheme, but that is only one use of an AKE, in other settings where OPAQUE is used to derive a key for an encrypted channel or for retrieving some encrypted blob, there is no 2FA and thus password strength does matter. Futhermore password strength also matters (although not in the enterprise setting) because a server (or someone who has the server records) can just offline brute force the password, and thus even then password strength matters and 2FA is irrelevant.\r\n\r\nre: https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/434#issuecomment-1846285005 - clients can prove correctness using attestation, and that is a brittle concept or it leads to a bad DRM dystopia, on phones this is a bit easier, apple and windows might be able to pull this off, but uefi/secureboot is really a broken concept, so it is quite impossible to do so reliably on desktops.",
          "createdAt": "2023-12-08T00:40:15Z",
          "updatedAt": "2023-12-08T00:40:15Z"
        },
        {
          "author": "bbeallo12",
          "authorAssociation": "NONE",
          "body": "> > Also doesn't the existence of 2FA make the password complexity issue a non-issue? If the password is guessed, they still need the 2FA. At which point the user is notified of the attempted login and can easily change their password.\r\n> > If you also require a new 2FA token along with the password change, doesn't that make it even better?\r\n> \r\n> OPAQUE is essentially and AKE, and has nothing to do with 2FA, OPAQUE can be part of a 2FA scheme, but that is only one use of an AKE, in other settings where OPAQUE is used to derive a key for an encrypted channel or for retrieving some encrypted blob, there is no 2FA and thus password strength does matter. Futhermore password strength also matters (although not in the enterprise setting) because a server (or someone who has the server records) can just offline brute force the password, and thus even then password strength matters and 2FA is irrelevant.\r\n> \r\n> re: [#434 (comment)](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/434#issuecomment-1846285005) - clients can prove correctness using attestation, and that is a brittle concept or it leads to a bad DRM dystopia, on phones this is a bit easier, apple and windows might be able to pull this off, but uefi/secureboot is really a broken concept, so it is quite impossible to do so reliably on desktops.\r\n\r\nDoesn't that make the assumption you're using OPAQUE in a vacuum? Why not use it together with multiple authentication methods?\r\n\r\nAs for attestation, so it isn't an issue of possibility but more an issue of the potential implications.",
          "createdAt": "2023-12-08T00:48:38Z",
          "updatedAt": "2023-12-08T00:49:11Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "you are reducing OPAQUE to an auth mechanism, instead of considering it an AKE. for an auth mechanism this makes sense, but for an AKE not.",
          "createdAt": "2023-12-08T01:05:17Z",
          "updatedAt": "2023-12-08T01:05:17Z"
        },
        {
          "author": "bbeallo12",
          "authorAssociation": "NONE",
          "body": "> you are reducing OPAQUE to an auth mechanism, instead of considering it an AKE. for an auth mechanism this makes sense, but for an AKE not.\r\n\r\nAh okay, that makes sense. Thanks for explaining that.\r\n\r\nWhat if hypothetically there could be a zero knowledge proof algorithm that can prove to a server the password was generated using the required complexity requirements without sharing the actual password.  If such an algorithm could exist, would that resolve the issue?",
          "createdAt": "2023-12-08T01:09:08Z",
          "updatedAt": "2023-12-08T01:09:08Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@bbeallo12 Yes, hypothetically that would resolve the issue. However, the issue is that these ZK proofs are expensive, and it would have to be custom-tailored to the password complexity rules. Either way, out of scope for the draft work here (since in the future if one does pursue that path, it could be sent to the server in addition to the OPAQUE messages).\r\n\r\nClosing this issue since #437 was merged",
          "createdAt": "2024-02-27T09:18:53Z",
          "updatedAt": "2024-02-27T09:18:53Z"
        },
        {
          "author": "cyyynthia",
          "authorAssociation": "NONE",
          "body": "I'll just add this resource I stumbled across a while ago while researching this myself that might interest people reading this thread; some people have been working on zero-knowledge password policy check protocols, although they are currently impractical. They do exist, though, so there's hope they'll become more practical soon!\r\n\r\n- Kiefer, F., Manulis, M. (2014). Zero-Knowledge Password Policy Checks and Verifier-Based PAKE. In: Kuty\u0142owski, M., Vaidya, J. (eds) Computer Security - ESORICS 2014. ESORICS 2014. Lecture Notes in Computer Science, vol 8713. Springer, Cham. https://doi.org/10.1007/978-3-319-11212-1_17\r\n- Nguyen, K., Tan, B.H.M., Wang, H. (2017). Zero-Knowledge Password Policy Check from Lattices. In: Nguyen, P., Zhou, J. (eds) Information Security. ISC 2017. Lecture Notes in Computer Science(), vol 10599. Springer, Cham. https://doi.org/10.1007/978-3-319-69659-1_6",
          "createdAt": "2024-02-28T16:58:10Z",
          "updatedAt": "2024-02-28T16:58:10Z"
        }
      ]
    },
    {
      "number": 440,
      "id": "I_kwDOD79ejs58OBO5",
      "title": "explicit auth necessary for opaque security?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/440",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "doing my full re-read of the doc, for the rglc, i noticed this sentence in section 6:\r\n\r\n> KE3 provides explicit client authentication and full forward security (without it, forward secrecy is only achieved against eavesdroppers, which is insufficient for OPAQUE security)\r\n\r\nskipping KE3 and using the session_key for a protected channel successfully provides implicit authentication, does the above quote mean that with implicit auth OPAQUE security would be reduced? if so how? as the original paper states this implicit auth possibility, it makes sense to describe this deviation and reduced opaque security in the document.",
      "createdAt": "2024-01-16T14:08:45Z",
      "updatedAt": "2024-02-27T09:43:47Z",
      "closedAt": "2024-02-27T09:43:46Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "OPAQUE with a key exchange that is not forward secure is not a secure aPAKE. The first version of the OPAQUE paper did not identify this issue (forward secrecy was implicit in the formalization of key exchange but not identified as an explicit requirement). This was corrected in subsequent [eprint publication](https://eprint.iacr.org/2018/163.pdf) (and in the CFRG mailing list). The issue is that if the server sends  information encrypted under the session key immediately after the server's (single)  OPAQUE message (without waiting for authentication from the user) then the following attack is possible. The attacker opens a session with the server in the name of some user for whom the attacker does not know the password but where the attacker chooses the ephemeral private key. When the server responds with its OPAQUE message and encrypts information under the session key, the attacker cannot decrypt it as it does not know the password. However, the attacker will be able to decrypt it if it learns the password in the future. The forward secrecy model of aPAKE is that once an attacker learns a password, all future sessions may be insecure, but past sessions should remain secure.",
          "createdAt": "2024-02-13T05:11:11Z",
          "updatedAt": "2024-02-13T05:11:11Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you very much for this insightful answer!\r\n\r\nSo the attack only applies if the server sends data encrypted with it's opaque response. right? if it doesn't then the implicit authentication should be enough? I think this is a very interesting and important detail. I'm not sure if this needs to be mentioned explicitly in the document though, what do you think @kevinlewi @chris-wood ?",
          "createdAt": "2024-02-13T15:37:59Z",
          "updatedAt": "2024-02-13T15:37:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's ok to not add this explicitly to the document, since references to this are already present in multiple locations. In addition to the one cited above, under the `ServerFinish` section:\r\n\r\n>  The AuthServerFinalize function takes KE3 as input and MUST verify the client authentication material it contains before the session_key value can be used. This verification is necessary to ensure forward secrecy against active attackers.\r\n\r\nClosing this issue but feel free to re-open if anyone thinks we should add more verbiage to the document",
          "createdAt": "2024-02-27T09:43:46Z",
          "updatedAt": "2024-02-27T09:43:46Z"
        }
      ]
    },
    {
      "number": 442,
      "id": "I_kwDOD79ejs5-jEvy",
      "title": "2 citation anchors for 1 document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/442",
      "state": "CLOSED",
      "author": "tsahara",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-opaque-13#name-informative-references\r\n\r\n> 12.1. Normative References\r\n>\r\n> [I-D.irtf-cfrg-voprf]\r\n> Davidson, A., Faz-Hernandez, A., Sullivan, N., and C. A. Wood, \"Oblivious Pseudorandom Functions (OPRFs) using Prime-Order Groups\", Work in Progress, Internet-Draft, draft-irtf-cfrg-voprf-21, 21 February 2023, <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21>.\r\n>\r\n> [OPRF]\r\n> Davidson, A., Faz-Hernandez, A., Sullivan, N., and C. A. Wood, \"Oblivious Pseudorandom Functions (OPRFs) using Prime-Order Groups\", Work in Progress, Internet-Draft, draft-irtf-cfrg-voprf-21, 21 February 2023, <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21>.\r\n\r\n\r\n[I-D.irtf-cfrg-voprf] and [OPRF] point to the same internet-draft.",
      "createdAt": "2024-02-07T14:09:40Z",
      "updatedAt": "2024-03-09T01:05:58Z",
      "closedAt": "2024-03-09T01:05:58Z",
      "comments": []
    },
    {
      "number": 444,
      "id": "I_kwDOD79ejs5--ndT",
      "title": "Serialization of Diffie-Hellman output to allow use of HSM protected keys",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/444",
      "state": "CLOSED",
      "author": "Razumain",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Diffie-Hellman operations using HSM protected keys can potentially be used both in the OPRF function as well as in the 3DH Key-Exchange Functions.\r\n\r\nIn OPRF a DiffieHellman operation can be used on top of the current evaluated element\r\n\r\nThe function `BlindEvaluate(oprf_key, blinded_element)` can be voluntarily extended by the server to:\r\n\r\n`DiffieHellman( ks, BlindEvaluate(oprf_key, blinded_element))`\r\n\r\nThis simply adds another scalar multiplication to the evaluated element, which can be unblinded by the client blind inverse.\r\n\r\nThe only thing that stands in the way of this operation, is the inclusion of the Y coordinate in the result when the corresponding DiffieHellman only produce the X coordinate as result.\r\n\r\nThe same is true for the 3DH key Exchange Functions which could be fully compatible with HSM protected keys if the shared secret was the X coordinate only instead of a full point serialization.\r\n\r\n\r\n",
      "createdAt": "2024-02-12T15:13:17Z",
      "updatedAt": "2024-05-30T20:48:23Z",
      "closedAt": "2024-05-30T20:48:23Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "for previous discussion on this see #238 ",
          "createdAt": "2024-02-12T15:38:55Z",
          "updatedAt": "2024-02-12T15:38:55Z"
        },
        {
          "author": "Razumain",
          "authorAssociation": "NONE",
          "body": "> for previous discussion on this see #238\r\n\r\nIt seems to me that these discussions both adress HSM usage, but adress very different issues.\r\n\r\nNIST SP 800-56A establishes that the shared secret from Diffie-Hellman Z = xP where xP is the x-coordinate of P.\r\nThis is not in harmony with how Diffie-Hellman shared secret is specified in Opaque and effectively blocks performing Diffie-Hellman operations in a HSM that operates according to SP 800-56A.\r\n\r\nIn addition to this. I see a lost opportunity to use a HSM Diffie-Hellman operation to evaluate the blinded password\r\n\r\n- the client hashes an input to a curve using hash-to-curve > point p on the curve\r\n- the client blinds that point with an ephemeral scalar b using scalar multiplication > p^b\r\n- the servers uses the oprf secret scalar o to evaluate that, using scalar multiplication > p^(b . o)\r\n- the servers uses a (possibly) long term secret scalar k to evaluate that, using scalar multiplication via a HSM Diffie-Hellman operation > P = p^(b . o . k) ==> Z = xP\r\n- the client unblinds that using scalar multiplication with the modular inverse (it's noted 1/b) on the compressed point P' = 1|xP > P'^1/b ==> x-coordinate of  p^(o . k)\r\n\r\nThis does work at least for P256 and it seems to work also for 25519, but I have to verify that better in tests.\r\n\r\nIt is all made available by discarding the Y component in 2 places of the spec:\r\n\r\n1. As the used shared secret in 3DH\r\n2. As the unblinded element in the OPRF Finalize function:\r\n\r\nThat is if:\r\n\r\n  hashInput = I2OSP(len(input), 2) || input ||\r\n              I2OSP(len(unblindedElement), 2) || unblindedElement ||\r\n              \"Finalize\"\r\n\r\nInstead would be:\r\n\r\n  hashInput = I2OSP(len(input), 2) || input ||\r\n              I2OSP(len(xP of unblindedElement), 2) || xP of unblindedElement ||\r\n              \"Finalize\"\r\n\r\n\r\nI know this is a big ask, that quite possibly is too much of a change to accommodate. But If there would be any clever way to at least allow this us of a HSM without breaking the standard, that would be very valuable.",
          "createdAt": "2024-02-12T23:31:54Z",
          "updatedAt": "2024-02-12T23:31:54Z"
        },
        {
          "author": "Razumain",
          "authorAssociation": "NONE",
          "body": "Adding an illustration from my implementation that shows that this works just fine:\r\n\r\nLets first derive the client secret without blinding, using both the oprf private key AND the HSM protected server key ks\r\n\r\nPassword inputElement point (Size: 33)\r\n    03 D1 02 3A DC 03 FC AD AF D2  29 9C 2D 59 17 01 AD C7 5B 0E  2D 0D 84 ED 8D D0 2D 04 15 A0  52 5B 7A \r\nInputElement * oprfKey (Size: 33)\r\n    03 80 22 CD 98 28 8A C2 7E A1  5A 08 CC A9 A0 D3 43 C9 94 8A  1F E2 8D 05 A8 E8 8C 1F F3 B2  82 15 ED \r\nClient secret = DiffieHellman(sk, (InputElement * oprfKey) (Size: 32)\r\n    **11 B0 5C 21 3B 73 CA E5 DD A0  8A B0 5B 31 DD CC D7 16 DE 76  A2 4A 74 16 A6 C1 AC 31 FA 2D  7C EB** \r\n\r\nThe real EC point used to derive the DH shared secret (Size: 33)\r\n    02 11 B0 5C 21 3B 73 CA E5 DD  A0 8A B0 5B 31 DD CC D7 16 DE  76 A2 4A 74 16 A6 C1 AC 31 FA  2D 7C EB \r\n\r\nNote the dropped Y coordinate compressed value = 02\r\n\r\nNow do with with blinding\r\n\r\nBlinded input element (Size: 33)\r\n    02 3C E0 68 E9 BB DA B7 7C 73  7D 26 1F DD AB D9 78 7A 30 D1  C7 01 1D 79 4E 52 09 6F 48 43  41 EF 85 \r\nOPRF evaluate = blinded element * oprfKey (Size: 33)\r\n    02 3B 75 57 05 9D A6 E5 BF 63  3A 60 05 64 DC 7A 24 4D C5 08  02 B9 BD DA 54 5C 54 DC C6 DB  23 8D F1 \r\nHSM Server evaluate = DiffieHellman(ks, (blinded element * oprfKey) (Size: 32)\r\n    41 6C 6B 36 F3 EB 06 59 CB D8  6D 50 5F 98 EA 22 E5 25 D7 DB  83 D4 C5 39 40 A5 A0 42 D6 19  DA EC \r\nECPoint(HSM Server evaluate) =  0x02 | HSM Server evaluate (Size: 33)\r\n    02 41 6C 6B 36 F3 EB 06 59 CB  D8 6D 50 5F 98 EA 22 E5 25 D7  DB 83 D4 C5 39 40 A5 A0 42 D6  19 DA EC \r\nClient unblind = ECPoint(HSM Server evaluate) * 1/b (Size: 33)\r\n    03 11 B0 5C 21 3B 73 CA E5 DD  A0 8A B0 5B 31 DD CC D7 16 DE  76 A2 4A 74 16 A6 C1 AC 31 FA  2D 7C EB \r\n\r\nNote that we actually guessed wrong here on the HSM evaluate output. We added 02 but this was clearly wrong as we distorted the Y coordinate result to be 03, compared with 02 above\r\n\r\nDerived shared secret (Size: 32)\r\n    **11 B0 5C 21 3B 73 CA E5 DD A0  8A B0 5B 31 DD CC D7 16 DE 76  A2 4A 74 16 A6 C1 AC 31 FA 2D  7C EB** \r\n\r\nBu as we only use the X coordinate, the client secret matches anyway.",
          "createdAt": "2024-02-14T15:48:47Z",
          "updatedAt": "2024-02-14T15:49:06Z"
        },
        {
          "author": "Razumain",
          "authorAssociation": "NONE",
          "body": "I would like to revert my proposal here.\r\n\r\nMathematically and conceptually it works wonders, but given that this is build into OPRF, I think the right way to go, if you use HSM is to recover the missing Y.\r\n\r\nIllary provided a great solution for how to do that with the cost of en extra DH operation with the HSM:\r\n\r\n>- Have HSM output x(aB) and x(a(B+G)).\r\n>- Guess Z=aB from first HSM output.\r\n>- Calculate x coordinate of Z+A, where A is your public key.\r\n>- Check if that is consistent with the second HSM output.\r\n\r\nSo we should not do this for OPRF. If you want to do this in OPRF you simply have to do this trick to recover Y.\r\n\r\nFor the use of DH in 3DH AKE it might still be worth considering only using the X coordinate to be compatible with off the shelf DiffieHellman operations based on PrivateKey objects (rather than raw scalar multiplication).\r\n\r\nFinally, a note about this would be great in the OPAQUE draft to point out that the solution above is possible if you want to extend the security of the OPRF with an HSM protected scalar.\r\n\r\n",
          "createdAt": "2024-02-15T07:38:42Z",
          "updatedAt": "2024-02-15T07:38:42Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @Razumain, after reading through the context here, I'm glad to hear that there is a way to make this work, but am currently not seeing a good way to reference this in the draft. Am I also understanding correctly that this is specific to the curve point representation and would not apply to ristretto255 points (or would it)?\r\n\r\nIf you have any recommended language that you would like to add to the draft, it would be great if you could take a stab at it :)",
          "createdAt": "2024-02-27T18:44:44Z",
          "updatedAt": "2024-02-27T18:44:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as it seems to have been resolved.",
          "createdAt": "2024-05-30T20:48:23Z",
          "updatedAt": "2024-05-30T20:48:23Z"
        }
      ]
    },
    {
      "number": 450,
      "id": "I_kwDOD79ejs6HdozP",
      "title": "question re derivation of oprf_key from oprf_seed",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/450",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in `CreateCredentialResponse`  the following happens:\r\n\r\n```\r\n  seed = Expand(oprf_seed, concat(credential_identifier, \"OprfKey\"), Nok)\r\n  (oprf_key, _) = DeriveKeyPair(seed, \"OPAQUE-DeriveKeyPair\")\r\n```\r\nthis complex approach is unnecessary in the ristretto255 setting, there is safe implementations that provide a scalar.  is it safe to simply replace the above with \r\n\r\n```\r\noprf_key = crypto_core_ristretto255_scalar_random()\r\n```\r\n\r\nif it is not safe, why is that?\r\n\r\nreducing complexity is in the interest of reviewers and implementers.",
      "createdAt": "2024-05-01T00:14:59Z",
      "updatedAt": "2024-05-30T20:34:19Z",
      "closedAt": "2024-05-30T20:29:07Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "So in order to be compliant with the test vectors, we do need to compute the oprf_key parameter using this DeriveKeyPair procedure. This was introduced in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/329, see the discussion there (also see: https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/241). It also ensures that the oprf key is deterministically derived from this seed, which is to help prevent against client enumeration attacks. See the section on \"Client Enumeration\" in the draft.\r\n\r\nAlso, note the following paragraph in that section which may apply to you:\r\n\r\n> Finally, applications that do not require protection against client enumeration attacks can choose to derive independent OPRF keys for different clients. The advantage to using independently-derived OPRF keys is that the server avoids keeping the oprf_seed value across different clients, which if leaked would compromise the security for all clients reliant on oprf_seed, as noted in {{DL24}}.",
          "createdAt": "2024-05-30T20:29:07Z",
          "updatedAt": "2024-05-30T20:29:07Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ah, client enumeration mitigation is an acceptable reason. thank you!",
          "createdAt": "2024-05-30T20:34:17Z",
          "updatedAt": "2024-05-30T20:34:17Z"
        }
      ]
    },
    {
      "number": 451,
      "id": "I_kwDOD79ejs6Hdy9Q",
      "title": "updates authenticated by opaque",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/451",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "would it make sense to write a short blurb recommending that password updates and envelope and configuration updates can be simply constructed by first running an opaque to authenticate the user and then to run the registration based on this? or is this obvious?",
      "createdAt": "2024-05-01T01:01:22Z",
      "updatedAt": "2024-06-13T11:09:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe there is another (safe) way to do password / envelope / configuration updates other than running registration again. I think this is covered by the text in the Application Considerations section:\r\n\r\n> Configuration and envelope updates: Applications may wish to update or change their configuration or other parameters that affect the client's RegistrationRecord over time. Some reasons for changing these are to use different cryptographic algorithms, e.g., a different KSF with improved parameters, or to update key material that is cryptographically bound to the RegistrationRecord, such as the server's public key (server_public_key). Any such change will require users to re-register to create a new RegistrationRecord. Supporting these types of updates can be helpful for applications that anticipate such changes in their deployment setting.",
          "createdAt": "2024-05-30T20:12:31Z",
          "updatedAt": "2024-05-30T20:12:31Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ok, maybe my question was ambiguous, the point is how to authenticate the re-registration. and in case there is no compromise of the server, i think a regular opaque login would suffice for authenticating a re-registration.",
          "createdAt": "2024-05-30T20:22:28Z",
          "updatedAt": "2024-05-30T20:22:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see. I suppose this depends on the application though. One way to do it might be to do a regular opaque login. But maybe if this is implemented on a website which relies on 2-factor authentication (via SMS/email for instance), then a password reset could be triggered through the 2-factor authentication mechanism (and not rely on OPAQUE login at all). I think this is also outside of the scope, since at the protocol level we can't really make recommendations for what the right way for an application to handle this scenario would be without getting too specific.",
          "createdAt": "2024-05-30T20:59:59Z",
          "updatedAt": "2024-05-30T20:59:59Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sure, it does depend on the application. but in a closed universe where only opaque exists this would be a reasonable way to do it. but if we step out of this universe, there can be all kind of other authentication mechanisms piled on top. so maybe something like:\r\n\r\n\"An implementation can chose any other and more sophisticated authentication mechanism to authorize a re-registration. However the simplest - given OPAQUE is already implemented, and there is no direct compromise of the server known - method to authorize a re-registration flow by a user is to be authenticated by using a normal OPAQUE login flow, which upon success executes the re-registration.\"",
          "createdAt": "2024-05-30T21:26:08Z",
          "updatedAt": "2024-05-30T21:26:08Z"
        },
        {
          "author": "Imberflur",
          "authorAssociation": "NONE",
          "body": "IIUC authenticating with the normal login flow followed by re-registration works for simple password changes. But if this includes configuration updates like changing the KSF, I think additional complexity is necessary since the client needs to know what configuration to use for the login flow? Such as one of these:\r\n\r\n1. The client somehow already locally knows whether the configuration has been updated (e.g. by storing state, prompting the user(?)).\r\n2. The login flow is ran for all possible configurations at once as described in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/294#issuecomment-1152713386.\r\n3. External authentication is used (e.g. 2-factor auth method mentioned above).\r\n4. Current configuration is exposed in a way that allows user enumeration.\r\n\r\nWhile writing this I thought of another potential approach and potential issues with it:  \r\n  \r\nThe client tries the login flow with the latest configuration version first, and iteratively tries the next older version if that fails. I don't know whether there would be an issue with an attacker forcing the client to try older versions? If so, that probably also applies to (2). Unlike (2), this would allow someone listening to know what version the client was on before they updated to the latest version (could reveal rough information on when the client last logged in). Hmmm, any actual login failure from invalid credentials would also lead to trying all possible versions.\r\n",
          "createdAt": "2024-06-13T04:09:58Z",
          "updatedAt": "2024-06-13T04:09:58Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the server is unaware of the ksf used. and the client knowing the configuration is not an issue i believe, part of the configuration is also the server's address and port, and indeed the client itself - that can have all kind of hard-coded info.\r\n\r\ni think it is an implementation detail - and maybe an upgrade path config - that an update first uses the previous config for authentication and then the new config for the recreation.",
          "createdAt": "2024-06-13T11:09:24Z",
          "updatedAt": "2024-06-13T11:09:24Z"
        }
      ]
    },
    {
      "number": 452,
      "id": "I_kwDOD79ejs6Hd1IY",
      "title": "how to mixin the client and server identity into the oprf?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/452",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "the following section:\r\n\r\n> As specified in Section 5 and Section 6, OPAQUE only requires the client password as input to the OPRF for registration and authentication. However, if client_identity can be bound to the client's registration record (in that the identity will not change during the lifetime of the record), then an implementation SHOULD incorporate client_identity alongside the password as input to the OPRF. Furthermore, it is RECOMMENDED to incorporate server_identity alongside the password as input to the OPRF. These additions provide domain separation for clients and servers; see Section 10.2.\r\n\r\nis ambiguous should the client and server identity be concatenated with the password as input to blind() or also to finalize()?\r\nis concatenation enough? or is it necessary to prefix the two identities with a length prefix (and also the password?)",
      "createdAt": "2024-05-01T01:10:05Z",
      "updatedAt": "2024-05-30T20:47:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, there is some ambiguity here but ultimately it is up to the implementor to decide. Concatenation + length-prefixing should suffice, but the exact mechanism for this is outside of the scope of the document. And yes, this should be done for both blind() and finalize(), as the \"input to the OPRF\" is supplied in both stages.",
          "createdAt": "2024-05-30T20:09:25Z",
          "updatedAt": "2024-05-30T20:09:25Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ok, but any OPAQUE implementation doing so as recommended will deviate from the test vectors.\r\n\r\n> as the \"input to the OPRF\" is supplied in both stages.\r\n\r\nthat totally makes sense in hindsight, but is not obvious at all if not very closely read and interpreted.",
          "createdAt": "2024-05-30T20:20:14Z",
          "updatedAt": "2024-05-30T20:20:14Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's true, it is a bit underspecified, but note that this is only an option for applications where client_identity can be persisted on the client and not change during the lifetime of the record. We decided not to include this in the main specification because it is optional (and in some cases too restrictive, imagine if a client registers with an email address as their client_identity, and then wants to change their email address, and does not expect to have to run through registration again). So, if an OPAQUE implementation wishes to conform to the test vectors, they would test functionality by replacing the concatenation of client_identity | server_identity | password (or however it's organized) as the actual \"password\" field as referenced in the test vectors.\r\n\r\nRegarding clarity of the text: I suppose I am not exactly sure how to clarify it further. Ultimately what we want to convey is that the \"password\" field can be replaced with \"client_identity + server_identity + password\", and \"input to the OPRF\" is the placeholder which I think captures that. Let me know if you have a (hopefully concise) suggestion for how to improve the clarity here. Thanks!\r\n\r\n",
          "createdAt": "2024-05-30T20:45:40Z",
          "updatedAt": "2024-05-30T20:47:22Z"
        }
      ]
    },
    {
      "number": 453,
      "id": "I_kwDOD79ejs6Hd1k7",
      "title": "mark sensitive variables?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/453",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> Certain information created, exchanged, and processed in OPAQUE is sensitive. Specifically, all private key material and intermediate values, along with the outputs of the key exchange phase, are all secret. Implementations should not retain these values in memory when no longer needed.\r\n\r\nwould it make sense to mark all variables explicitly that are considered sensitive? such information would very well fit in the boxes for the functions where we list input/output/exceptions and the pseudo-code.",
      "createdAt": "2024-05-01T01:12:37Z",
      "updatedAt": "2024-05-31T14:40:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "red/black",
          "createdAt": "2024-05-01T01:15:44Z",
          "updatedAt": "2024-05-01T01:15:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't know if there is actually a way to do this with colors, in a way that also appears in the .txt version of the draft with no markup. ccing @chris-wood in case he has any thoughts, but otherwise closing...",
          "createdAt": "2024-05-30T20:13:34Z",
          "updatedAt": "2024-05-30T20:13:34Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "red/black is the name of the technique to mark sensitive and \"insensitive\" data, it doesn't have to be with colors in the document. it might as well be just a table with all the variables that are sensitive, and need proper protection from leaking (like with mprotect) and to be sanitized (like with bzero).",
          "createdAt": "2024-05-30T20:25:21Z",
          "updatedAt": "2024-05-30T20:25:21Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "or as i originally mentioned we could mark these directly in the functions with the pseudo-code, just giving it an extra section in there:\r\n\r\nsensitive variables: foo, bar, baz",
          "createdAt": "2024-05-30T20:26:50Z",
          "updatedAt": "2024-05-30T20:26:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see what you mean. So, this could be done, but I am a bit hesitant because I feel like it might be a bit too redundant / detract from the presentation. Note that all intermediate variables in a function are considered sensitive. So for instance if we take a look at doing this for the Store() function in Envelope Creation:\r\n\r\n```\r\ndef Store(randomized_password, server_public_key, server_identity, client_identity):\r\n  envelope_nonce = random(Nn)\r\n  masking_key = Expand(randomized_password, \"MaskingKey\", Nh)\r\n  auth_key = Expand(randomized_password, concat(envelope_nonce, \"AuthKey\"), Nh)\r\n  export_key = Expand(randomized_password, concat(envelope_nonce, \"ExportKey\"), Nh)\r\n  seed = Expand(randomized_password, concat(envelope_nonce, \"PrivateKey\"), Nseed)\r\n  (_, client_public_key) = DeriveDiffieHellmanKeyPair(seed)\r\n\r\n  cleartext_credentials =\r\n    CreateCleartextCredentials(server_public_key, client_public_key,\r\n                               server_identity, client_identity)\r\n  auth_tag = MAC(auth_key, concat(envelope_nonce, cleartext_credentials))\r\n\r\n  Create Envelope envelope with (envelope_nonce, auth_tag)\r\n  return (envelope, client_public_key, masking_key, export_key)\r\n```\r\n\r\npretty much every variable there that is not an input or output would be enumerated as \"sensitive\" (e.g. auth_key, cleartext_credentials), and arguably auth_tag, envelope as well since they are intermediate even though they are also included as part of the output.\r\n\r\nAnd for a function like AuthServerRespond:\r\n```\r\ndef AuthServerRespond(cleartext_credentials, server_private_key, client_public_key, ke1, credential_response):\r\n  server_nonce = random(Nn)\r\n  server_keyshare_seed = random(Nseed)\r\n  (server_private_keyshare, server_public_keyshare) = DeriveDiffieHellmanKeyPair(server_keyshare_seed)\r\n  preamble = Preamble(cleartext_credentials.client_identity,\r\n                      ke1,\r\n                      cleartext_credentials.server_identity,\r\n                      credential_response,\r\n                      server_nonce,\r\n                      server_public_keyshare)\r\n\r\n  dh1 = DiffieHellman(server_private_keyshare, ke1.auth_request.client_public_keyshare)\r\n  dh2 = DiffieHellman(server_private_key, ke1.auth_request.client_public_keyshare)\r\n  dh3 = DiffieHellman(server_private_keyshare, client_public_key)\r\n  ikm = concat(dh1, dh2, dh3)\r\n\r\n  Km2, Km3, session_key = DeriveKeys(ikm, preamble)\r\n  server_mac = MAC(Km2, Hash(preamble))\r\n\r\n  state.expected_client_mac = MAC(Km3, Hash(concat(preamble, server_mac)))\r\n  state.session_key = session_key\r\n  Create AuthResponse auth_response with (server_nonce, server_public_keyshare, server_mac)\r\n  return auth_response\r\n```\r\n\r\nThe intermediate variables are server_keyshare_seed, server_private_keyshare, preamble, dh1, dh2, dh3, ikm, Km2, Km3, session_key, etc.\r\n\r\nIt seems a bit too cumbersome, no? I kind of prefer just the overall statement we currently have, and leave it to implementors to make sure that the implemented functions follow good practices for writing secure code, such as zeroing out memory after the variables drop out of scope.\r\n",
          "createdAt": "2024-05-30T20:56:17Z",
          "updatedAt": "2024-05-30T20:57:01Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just because something is intermediate variable doesn't mean it's sensitive (red).\r\n\r\n> pretty much every variable there that is not an input or output would be enumerated as \"sensitive\" (e.g. auth_key, cleartext_credentials), and arguably auth_tag, envelope as well since they are intermediate even though they are also included as part of the output. \r\n\r\nactually i think in that function `cleartext_credentials` and `auth_tag` (maybe `envelope` but that is not clear to me and needs effort to figure out) are the only black variables, everything else is red in `Store()` and exactly that effort to figuring out if `envelope` is red or black could be spared. \r\n\r\nin the 2nd example `AuthServerRespond()` i would naively argue that preamble for example is not sensitive (black) (unless identities are to be hidden from 3rd parties), also `server_mac` seems to be black (but there might be some weird authentication attack where the `server_mac` can be used maliciously?)\r\n\r\nso as you can see even i am not entirely sure which of those few is actually sensitive or not without looking deeper. \r\n\r\ni was thinking, like in papers, we usually mark secret values with lower-case letters and public values with upper-case letters, that would be a non-intrusive way to signal sensitivity of intermediary variables. what do you think? i would volunteer to make a proposal PR for such a change...",
          "createdAt": "2024-05-30T21:37:50Z",
          "updatedAt": "2024-05-30T21:37:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The original guidance that we have in the draft, from the text you quoted, states that every intermediate variable is indeed sensitive:\r\n\r\n> Certain information created, exchanged, and processed in OPAQUE is sensitive. Specifically, **all private key material and intermediate values**, along with the outputs of the key exchange phase, are all secret. Implementations should not retain these values in memory when no longer needed.\r\n\r\nAnd I agree, it is difficult to examine a specific variable and determine whether or not it would be a security issue if it were not erased from memory. So instead we go with the recommendation to treat everything as sensitive, and I think this is probably the best approach, even if it is being a bit aggressive in some cases. So I would opt to still not change the draft text as it stands, since the original guidance captures it well enough in my opinion.\r\n\r\ncc: @hugokraw @chris-wood @bytemare for thoughts",
          "createdAt": "2024-05-30T21:42:18Z",
          "updatedAt": "2024-05-30T21:42:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "At this point I am strongly opposed to non-essential editorial changes to the document.",
          "createdAt": "2024-05-30T21:45:11Z",
          "updatedAt": "2024-05-30T21:45:11Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe for the future, i think this does help implementers, and also reviewers if there is a distinction between such and such intermediary variables.",
          "createdAt": "2024-05-30T21:58:22Z",
          "updatedAt": "2024-05-30T21:58:22Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\nOn Thu, May 30, 2024, 17:45 Christopher Wood ***@***.***>\r\nwrote:\r\n\r\n> At this point I am strongly opposed to non-essential editorial changes to\r\n> the document.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/453#issuecomment-2140910525>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AICFFXU5D7AQW6OZQZ7PFMLZE6MX3AVCNFSM6AAAAABHBIAB76VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDCNBQHEYTANJSGU>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2024-05-31T14:40:34Z",
          "updatedAt": "2024-05-31T14:40:34Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5NTMwNTY4",
      "title": "Cleanup the document.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-18T14:14:15Z",
      "updatedAt": "2021-04-24T15:11:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "141e15efee0a73c14ce1d9766c591e7fd974dba9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/cleanup",
      "headRefOid": "1f060a625d001ec1e9ba4cfcc1ba25c23a8b7742",
      "closedAt": "2020-05-18T14:14:21Z",
      "mergedAt": "2020-05-18T14:14:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3b004d0e822b3bdb0d3e2c42eefcadf4c1c5c0c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjMzOTc1",
      "title": "Fixed typo in K3dh definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/10",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #8",
      "createdAt": "2020-05-19T16:34:15Z",
      "updatedAt": "2020-05-19T16:43:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3b004d0e822b3bdb0d3e2c42eefcadf4c1c5c0c6",
      "headRepository": "hugokraw/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "5a5d843c37034a6bddab4de46951382be9761480",
      "closedAt": "2020-05-19T16:43:28Z",
      "mergedAt": "2020-05-19T16:43:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e73d7287709206ea755e23e6369e989b16bea940"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjMzMzE3",
          "commit": {
            "abbreviatedOid": "5a5d843"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T16:43:22Z",
          "updatedAt": "2020-05-19T16:43:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjQxNTk0",
      "title": "Minor fix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/11",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-19T16:48:47Z",
      "updatedAt": "2020-05-19T17:02:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e73d7287709206ea755e23e6369e989b16bea940",
      "headRepository": "hugokraw/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "0d9b5d801cf2d87dd7d6e575a75780acf174457f",
      "closedAt": "2020-05-19T17:02:19Z",
      "mergedAt": "2020-05-19T17:02:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "64e188b1197d555f14a4358bde2d9541b056b956"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjQ4MzUz",
          "commit": {
            "abbreviatedOid": "0d9b5d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T17:02:13Z",
          "updatedAt": "2020-05-19T17:02:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMTIyMjUw",
      "title": "Apply Hugo's changes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/12",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @hugokraw ",
      "createdAt": "2020-05-21T03:04:11Z",
      "updatedAt": "2021-04-24T15:11:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "64e188b1197d555f14a4358bde2d9541b056b956",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hugo-branch",
      "headRefOid": "5514ae0638c28572bc0ea06dfbbaf0a8ca71591e",
      "closedAt": "2020-05-21T13:24:21Z",
      "mergedAt": "2020-05-21T13:24:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9cef30edba1afce5701546450fa5be004e87fdd5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNDUwODQ5",
      "title": "Add self as an author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/13",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-21T16:25:28Z",
      "updatedAt": "2021-04-24T15:11:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9cef30edba1afce5701546450fa5be004e87fdd5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/author",
      "headRefOid": "5a7be151b0db2b30242c4973bcfa13b24fe170ce",
      "closedAt": "2020-05-21T21:32:59Z",
      "mergedAt": "2020-05-21T21:32:58Z",
      "mergedBy": "hugokraw",
      "mergeCommit": {
        "oid": "1a45065d3f8ef7617093b9e36d874a20f5d5a2ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTA4MjU2",
          "commit": {
            "abbreviatedOid": "5a7be15"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Welcome Chris :-)",
          "createdAt": "2020-05-21T21:31:57Z",
          "updatedAt": "2020-05-21T21:31:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNDUyNDc3",
      "title": "Address Eric's comments.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/14",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #9.",
      "createdAt": "2020-05-21T16:28:33Z",
      "updatedAt": "2021-04-24T15:11:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9cef30edba1afce5701546450fa5be004e87fdd5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/eric-comments",
      "headRefOid": "39be24df302cfce0bcc0ef9d66d4281ab1fd5ef8",
      "closedAt": "2020-05-21T21:27:52Z",
      "mergedAt": "2020-05-21T21:27:52Z",
      "mergedBy": "hugokraw",
      "mergeCommit": {
        "oid": "5bbe4a7e6e1b3938dd78ebe25470246301cf0418"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTA1MTE4",
          "commit": {
            "abbreviatedOid": "39be24d"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm good with #14 resolution (Eric comments)",
          "createdAt": "2020-05-21T21:27:22Z",
          "updatedAt": "2020-05-21T21:27:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMjg1MzU1",
      "title": "Initial draft of wire format messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change shuffles around content and replaces the text-based protocol descriptions with protocol flows and messages. It also includes a first cut at wire format details for these messages. (We can always iterate later on!) \r\n\r\ncc @hugokraw \r\n",
      "createdAt": "2020-05-23T14:58:59Z",
      "updatedAt": "2021-04-24T15:11:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "1a45065d3f8ef7617093b9e36d874a20f5d5a2ca",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/wire-formats",
      "headRefOid": "f9e7f430da7a35fcf3ec751927d31edcd9f0185a",
      "closedAt": "2020-05-28T12:32:08Z",
      "mergedAt": "2020-05-28T12:32:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "21de69f0b70488207df108cd25023ed421be24df"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Chris, I went over the specification text. Looks good (and a lot of\nwork).\nThanks!\n\nI have several comments. I was not sure how to better communicate this in\nthe\ngithub so pardon the use of 20th century technology here...\n\nComments are mostly in the order of appearance in the document, not by\norder of\nimportance.\n\n-- You say:\n> Client (U): Entity which has knowledge of a password and wishes to\nauthenticate.\nHere and in other places, including the naming of the online phase as the\n\"authentication\" phase, make this seem as just authentication when it is\nalso\nkey exchange. I have this note in the draft saying that authentication\nwithout\nkey exchange is \"analogous to carefully checking a visitor's credential at\nthe door and then leaving the door open for others to enter freely.\"\n\n-- The expression \"group key pair\" was unclear/confusing to me.\n\n-- Somewhere you say: \"Where noted, random choices can be replaced with\nfresh\noutputs from a cryptographically strong pseudorandom generator or\npseudorandom\nfunction.\"\n\nThe default is that we can replace randomness with pseudorandomness; we\nshould\nnote the cases where this is not the case and not the cases where\nreplacement is\nfine (essentially all cases).\n\n-- VOPRF: We never use the verifiability property; it would violate the\nPKI-freeness. We can use g^kU for fixed-base blinding but g^kU in this case\nis\nnot certified, just sent from server to client (possibly cached by the\nlatter)\n\n-- Fixed-base blinding: You are defining the OPRF with var-base blinding,\nnot\nleaving the option of fixed-base blinding (which would need to transfer\ng^kU).\n\n-- Generic OPRF vs DH-OPRF: This issue of blinding mechanisms points to the\nfact\nthat while all components of the protocol are generic in your\nspecification, the\nOPRF is fixed to DH-OPRF. I do not suggest complicating presentation too\nmuch\njust for the sake of being generic but I would definitely want to allow an\noptimization such as fixed-base blinding, and this may call for a more\ngeneral\nAPI (e.g., an OPRF structure with Request/Response).\n\n-- From the expression Open(k, n, aad, ct) I understand that you do not see\naad\nas part of ct. Is this right?\n\n-- In the OPRF ciphersuites there is no 256-bit curve. Why is that?\nIn the case of integration with TLS wouldn't we be using the curves TLS\nuses?\n\n-- In the hardening functions, shouldn't one allow for PBKDF for backward\ncompatibility reasons? I know of some company that wanted that exactly for\nthat\nreason.\n\n-- The Credentials structure: Setting it to the 4 elements as you define is\nfine\nand should cover common cases. However, pkU is usually not needed by the\nclient\n(that's the case for all the AKE examples I considered) so it may be\nremoved.\nThe public key pkS need not be encrypted but I assume we don't gain much by\nnot\nencrypting it. Do you mean to always encrypt all elements? And if so, why is\nthere a AAD field?\n\nI know we do not want to leave too many options but I would not want to\nprohibit\nthe encryption-less case where you only send the authenticated pkS (skS is\nderived from RwdU). The only place where I saw some benefit in AuCPace is\nthat\nthey had less bits in the wire. OPAQUE with the encryption-less option beats\nthem in that sense too. This mode also removes the annoying equivocable\nencryption property that we need in the UC analysis.\n\n--  When specifying the envelope encryption, I defined an optional key KdKey\nderived from RwdU for extended functionalities, e.g., as a way to retrieve\nnon-OPAQUE credentials (or to support the encryption-less option). We will\nsee\nhow we go about specifying the envelope encryption and then see what\nhappens to\nsuch KdKey.\n\n-- RwdU = Harden(y): This function should accept hardness parameters (or you\nassume they are part of the function definition)\n\n-- The name OPAQUE collides with \"opaque\" as an object type. Maybe say at\nthe\nbeginning that the name OPAQUE is always capitalized while the object type\nis\nnot (or don't say anything and trust the intelligence of the reader :-)\n\n-- You ask: should we blind both the identity and password?\n   Is the question whether IdU should be part of the input to the OPRF\n(together\n   with PwdU)? It is not necessary, I think, because kU is supposed to be\nunique\n   per user. Also, servers may use more than on IdU value to identify a\nuser or\n   use a value of IdU different than the one the user has (but we need some\n   agreement on the value of IdU for the sake of key derivation so maybe\nthis\n   would not be a problem if we wanted to use IdU as input to the OPRF).\n\n-- At registration the use chooses fresh keys (skU, pkU) =\nGenerateKeyPair().\n   Would it be possible that the user has a specific pair it wants to\nregister?\n   Maybe because it has a hardware token with these keys? But still uses the\n   envelope in case he left them at home...? WebAuth related?\n\n-- You say (regarding IdS): \"we should probably improve this a bit and\nprovide\n   guidance for where and how IdS is provisioned to clients\"\n   Probably such guidance is needed although there may be many use cases.\nOne\n   place where this id can be communicated is in the Response message from\nthe\n   server or in the envelope.\n\n-- Regarding the second stage you say: \"This stage is composed of a\nsequential\nOPRF and key exchange flow.\"\nDo not use the word sequential as we run them in parallel. In integration\nwith\nTLS we even start the KE part before the OPRF (exchanging DH values).\n\n-- \"client and server agree on the knowledge of the password and have\nmutually\nauthenticated one another\"\nThis is more like: Client proves user's knowledge of the password and agree\non a\nmutually authenticated shared secret key.\n\n-- In the online stage, should IdS be (at least an optional) input to the\nclient? It needs it to contact the server. Otoh, the name IdS used later in\nthe\nprotocol may be different than the one the client initially has for\ncontacting\nthe server, especially if IdS is communicated in the envelope.\n\n-- the context value is always derived as fresh randomness. However, it\nwould\nmake sense to set this value to the KE nonces (particularly in the case of\nTLS).\n\n-- Specification of the key-exchange protocol is out of scope for this\ndocument.\nThere is one point where the two components, OPRF and AKE, need to be bound\ntogether. This can be done by adding OPRF1 (what I call the value alpha) to\nthe\ndata authenticated by the KE. In the current specific, as I wrote it, all\nof the\nOPRF transcript (and even the envelope) is authenticated, not because this\nis\nneeded but because it is simpler to just add everything to the stream of\nauthenticated data. Anyway, the point is that this binding needs to be\naccommodated in gluing the OPRF and KE.\n\n-- Generic committed encryption. I am not convinced that the use of RKR here\njustifies a separate document. The main reason for having such document is\nbecause the trivial solution, namely, encrypt-then-CRmac (CRmac is any MAC\nthat\nis collision resistant), is slow for large pieces of data which is not the\ncase\nhere. I am afraid that such separate document will have much more complexity\nthat what's needed here, and we will end recommending using\nencrypt-then-hmac\nfor OPAQUE (it is the most robust mode for RKR encryption). I would have\nhoped\nto have a spec for it already but even defining it specifically for OPAQUE\nis\nnot a big deal. One issue is that given the popularity of GCM, people will\nwant\nto use it as the encryption part.  This is not a problem security-wise but\nwastes computation and bandwidth (not sure how serious this is). That's why\nI\ndefined standalone counter mode encryption (another self-contained spec I\ncould\nnot find).\n\n\n\nOn Sat, May 23, 2020 at 10:59 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> This change shuffles around content and replaces the text-based protocol\n> descriptions with protocol flows and messages. It also includes a first cut\n> at wire format details for these messages. (We can always iterate later on!)\n>\n> cc @hugokraw <https://github.com/hugokraw>\n> ------------------------------\n> You can view, comment on, or merge this pull request online at:\n>\n>   https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17\n> Commit Summary\n>\n>    - Work in progress on the wire format details.\n>    - Merge branch 'master' of github.com:cfrg/draft-irtf-cfrg-opaque into\n>    caw/wire-formats\n>    - Finish online authentication phase.\n>\n> File Changes\n>\n>    - *M* draft-irtf-cfrg-opaque.md\n>    <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17/files#diff-49c06d6581f7de28ecde5fcfac409830>\n>    (929)\n>\n> Patch Links:\n>\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17.patch\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17.diff\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXSS5EXWDTICPK34XZDRS7QD7ANCNFSM4NIPH3UQ>\n> .\n>\n",
          "createdAt": "2020-05-24T16:07:56Z",
          "updatedAt": "2020-05-24T16:07:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0NjczODg3",
      "title": "Generate nonces randomly.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/24",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #23.",
      "createdAt": "2020-05-28T19:01:02Z",
      "updatedAt": "2021-04-24T15:11:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "21de69f0b70488207df108cd25023ed421be24df",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/random-nonces",
      "headRefOid": "7d7a9bdc07b6bb8cb68336c2e92903fd3391034c",
      "closedAt": "2020-05-29T00:44:49Z",
      "mergedAt": "2020-05-29T00:44:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f39bcc8e8a4aceefeff19d778ceb4e6dcb0de1ec"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MDkyMjQ4",
      "title": "Add HMQV key derivation changes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/28",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #18.",
      "createdAt": "2020-05-29T13:06:33Z",
      "updatedAt": "2021-04-24T15:11:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f39bcc8e8a4aceefeff19d778ceb4e6dcb0de1ec",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hmqv-changes",
      "headRefOid": "2576ebb427c8bd9d189a2b6687c44f2dae839bfe",
      "closedAt": "2020-05-29T15:08:36Z",
      "mergedAt": "2020-05-29T15:08:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3a62bfb1ac0a1cc6e0d8f2492da0256724805be1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQyMzUy",
          "commit": {
            "abbreviatedOid": "2576ebb"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T15:08:08Z",
          "updatedAt": "2020-05-29T15:08:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MDc4Mjgz",
      "title": "Replace Encode/Decode with Serialize/Deserialize.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/32",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is to match the VOPRF document, which uses Serialize/Deserialize. (Encode was also used as a type of Hash in hash-to-curve, so this is probably better.)",
      "createdAt": "2020-06-04T20:44:51Z",
      "updatedAt": "2021-04-24T15:11:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41068ef6e0a02eed821764cc80ab8fe7fa084e32",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/encode-to-serialize",
      "headRefOid": "49033dd3d7167467e3ad9f7738160f4801e450be",
      "closedAt": "2020-06-05T16:00:44Z",
      "mergedAt": "2020-06-05T16:00:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7b2ac5fad20d031fedd697e5fe5ff2a75b245902"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Mzk2Mjgz",
          "commit": {
            "abbreviatedOid": "49033dd"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-05T15:20:40Z",
          "updatedAt": "2020-06-05T15:20:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MTM3NTIw",
      "title": "Fix and relocate KdKey derivation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This moves derivation of the KdKey to the main protocol flow (outside of the RKR-AEAD algorithm), uses HKDF-Extract for secret derivation, and renames KdKey to exporter_key. ",
      "createdAt": "2020-06-04T23:17:51Z",
      "updatedAt": "2021-04-24T15:11:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41068ef6e0a02eed821764cc80ab8fe7fa084e32",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/kdkey",
      "headRefOid": "f2dcf38c76c026d6b78b1195b9c48fd730691800",
      "closedAt": "2020-06-05T18:04:34Z",
      "mergedAt": "2020-06-05T18:04:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d4e6be35083e0280e749c87f6140ef1a13072f13"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I want to beef up the explanation of how the exporter_key may be used but no need to keep this open now.\r\n\r\nYeah, more text would certainly be useful. I figured we could do that in another PR. :-)",
          "createdAt": "2020-06-05T18:04:25Z",
          "updatedAt": "2020-06-05T18:04:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTEwNjQ2",
          "commit": {
            "abbreviatedOid": "f2dcf38"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks fine. I want to beef up the explanation of how the exporter_key may be used but no need to keep this open now. ",
          "createdAt": "2020-06-05T18:00:51Z",
          "updatedAt": "2020-06-05T18:00:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0MzgwMTYz",
      "title": "Addressing minor grammar and typo fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/34",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly addressing some minor grammar fixes and typos that I found during my pass.\r\n\r\nI also renamed \"xcript2\", \"xcript3\" to \"transcript2\" and \"transcript3\", feel free to push back on that.\r\n\r\nI noticed also that in some places it is referred to as \"xcript2\" and others it is \"xscript2\", at the very least those should be made consistent.",
      "createdAt": "2020-06-15T08:39:51Z",
      "updatedAt": "2020-12-16T09:54:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "b5894704b46ed915abf4d1c98734651caf59bb58",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "typo_fixes",
      "headRefOid": "245688a2d5779e7dd6b22d274e9ab439de59a299",
      "closedAt": "2020-06-15T14:23:27Z",
      "mergedAt": "2020-06-15T14:23:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "df8af66cf5dd6cf86c7c07fa7c853a6e7a42df44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNjgyODcw",
          "commit": {
            "abbreviatedOid": "245688a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-06-15T14:12:19Z",
          "updatedAt": "2020-06-15T14:12:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NTc1MDM3",
      "title": "Add 256-bit curve suites.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/35",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We address static DH oracle attacks in the security considerations. Nothing to be worried about! :-)",
      "createdAt": "2020-06-17T03:12:09Z",
      "updatedAt": "2021-04-24T15:11:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "df8af66cf5dd6cf86c7c07fa7c853a6e7a42df44",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/oprf-suites",
      "headRefOid": "b2b814034fcd2863c1307d2bccf70850b9194ec9",
      "closedAt": "2020-06-17T13:10:39Z",
      "mergedAt": "2020-06-17T13:10:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5b15b1938e36d068e600eed46442ec3cb3317e9a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDY4ODQ3",
          "commit": {
            "abbreviatedOid": "b2b8140"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good.",
          "createdAt": "2020-06-17T05:30:00Z",
          "updatedAt": "2020-06-17T05:30:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1OTY0MTE5",
      "title": "Remove RKR-AEAD dependency.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the RKR-AEAD dependency in favor of a simpler OTP-like construction for credential secrecy. It also replaces redundant Extract calls on RwdU with Expand calls (RwdU is already assumed to be the output of a RO). Finally, it removes the `context` parameter from all protocol messages, punting that functionality to applications.",
      "createdAt": "2020-06-17T16:29:13Z",
      "updatedAt": "2021-04-24T15:11:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5b15b1938e36d068e600eed46442ec3cb3317e9a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/otp",
      "headRefOid": "7fa14ae888c0edc05973148faee435b0a2fd3396",
      "closedAt": "2020-06-18T23:04:26Z",
      "mergedAt": "2020-06-18T23:04:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ed6bbd3cbffa33a78dd3c03369423d3280a11023"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Chris, I have several comments/corrections for PR #36.\nLet me know if there is a better way to communicate such things in github\nrather than as an email.\n\nHere is a list (items marked by *)\n\nLet me know if you have questions or need more clarity on these issues.\n\n\n* Question (pure curiosity): What was the functionality of the \"context\"\nvalue\nwhat was context\n\n* Line 642: Envelope is defined as an encryption of a Credentials\nstructure, but\n  encryption is only required for skU. Maybe \"an authenticated encoding\"\ninstead\n  of encryption, since everything in it requires authentication.\n\n(same appears in line 821)\n\n* params, the MHF parameters established out of band\n\nShouldn't we allow for params to be communicated by the server to client\n(this\nwould be another potential element of Envelope)\n\n* Calculation of keys using HKDF-Expand (lines 720..., also 891...)\n\nHere is how the calculation should look:\n\npseudorandom_pad = HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt))\nauth_key         = HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na)\nexporter_key     = HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne)\n\nThe keywords Key= and info= are not needed. RFC 5869 defines HKDF-Expand\nwith\nthree parameters corresponding to key, info and length, so just writing\npseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt))\nshould be enough\n(I write the name of the fields to clarify the semantics but this is not\nneeded\nfor specification).\n\nBtw, I prefer \"nonce\" or \"Nonce\" better than n.\n\nAlso: Is Ne (the length of exporter_key) defined?\nWe can use the same length for auth_key and exporter_key - they should be\nHashLen where this denotes the output length from the hash underlying HKDF\n(or\nHMAC)\n\n* Encryption and aad\n\nYou define (line 718)\n  pt = SerializeCredentials(C)\nand then (line 723)\n  ct = xor(pt, pseudorandom_pad)\nwhich means you are mandating the encryption of all fields in Credentials.\nI don't think we want to do that.\nSome people (like Kevin and I got this feedback from AWS too) want to keep\npkS\nunencrypted so we should accommodate that.\nI also find the text in line 733-736 confusing.\nShouldn't the SerializeCredentials get as input an indication of what\nCredentials fields are included and which are part of pt and which of aad?\n\nIn particular I don't like to leave this to the application:\n  \"Instantiations of OPAQUE MUST specify how aad is constructed and\nserialized.\"\nShouldn't the OPAQUE client be standardized independently of the\napplications?\n\n> Is it ok to leave it up to the application? Don't you want to build\ngeneric\nclients? Can't the SerializeCredentials function have as input the\nencrypted and\nauthenticated elements?\n\nBtw, you use the notation pk(skU) but this is denoted by the simple pkU\n\n* Important correction\n\nWhere it says (line 724):\n\nt = HMAC(auth_key, concat(ct, aad)),  where aad is application-specific\n\nit should be\n\nt = HMAC(auth_key, concat(n, ct, aad)),  where aad is application-specific\n\nthe nonce needs to be authenticated (it's my fault, I overlooked it in the\ntext\nI sent you).\n\n* line 896 Abort(): should one define an error message for it?\n\n\n\nOn Wed, Jun 17, 2020 at 12:34 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @chris-wood <https://github.com/chris-wood> requested your review on: #36\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36> Remove RKR-AEAD\n> dependency..\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#event-3454432475>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXX5T5AHOTNA2WBILLDRXDWAVANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T02:17:40Z",
          "updatedAt": "2020-06-18T02:17:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> * Question (pure curiosity): What was the functionality of the \"context\" value what was context \r\n\r\nIt was meant to link requests/responses together. But that's something that can be handled by the instantiation (OPAQUE-EA in this case).\r\n\r\n> * Line 642: Envelope is defined as an encryption of a Credentials structure, but encryption is only required for skU. Maybe \"an authenticated encoding\" instead of encryption, since everything in it requires authentication. (same appears in line 821) \r\n\r\nThat works for me -- I'll use that text.\r\n\r\n> * params, the MHF parameters established out of band Shouldn't we allow for params to be communicated by the server to client (this would be another potential element of Envelope) \r\n\r\nI don't think so. Clients can choose to harden the password using whatever parameters they wish, right? Why does the server need to have any input here?\r\n\r\n> * Calculation of keys using HKDF-Expand (lines 720..., also 891...) Here is how the calculation should look: pseudorandom_pad = HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt)) auth_key = HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na) exporter_key = HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne) The keywords Key= and info= are not needed. RFC 5869 defines HKDF-Expand with three parameters corresponding to key, info and length, so just writing pseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt)) should be enough (I write the name of the fields to clarify the semantics but this is not needed for specification). \r\n\r\nTo be clear, you're just suggesting removing the argument labels (\"key=\"), right? I don't see any difference between concat(nonce, \"Pad\") and concat(\"Pad\", nonce). \r\n\r\n> Btw, I prefer \"nonce\" or \"Nonce\" better than n. Also: Is Ne (the length of exporter_key) defined? We can use the same length for auth_key and exporter_key - they should be HashLen where this denotes the output length from the hash underlying HKDF (or HMAC) \r\n\r\nYep, Ne is the length of the exporter key. It's a parameter to the functions where it's used. I folded Na and Ne together. I'll specify a value for this in a separate PR.\r\n\r\n> * Encryption and aad You define (line 718) pt = SerializeCredentials(C) and then (line 723) ct = xor(pt, pseudorandom_pad) which means you are mandating the encryption of all fields in Credentials. I don't think we want to do that. Some people (like Kevin and I got this feedback from AWS too) want to keep pkS unencrypted so we should accommodate that. I also find the text in line 733-736 confusing. Shouldn't the SerializeCredentials get as input an indication of what Credentials fields are included and which are part of pt and which of aad? In particular I don't like to leave this to the application: \"Instantiations of OPAQUE MUST specify how aad is constructed and serialized.\" Shouldn't the OPAQUE client be standardized independently of the applications?\r\n\r\nI don't know of a good way to specify this in the pseudocode without a mess of branches. I think the default case should be to encrypt pkS, and we can specify variants (moving pkS out of Credentials and into aad, for example) in the text. But we can also flip that around and make the default case be to only authenticate pkS, with text suggesting it may optionally be encrypted. Would that work?\r\n\r\n> Is it ok to leave it up to the application? Don't you want to build generic clients? Can't the SerializeCredentials function have as input the encrypted and authenticated elements? \r\n\r\nI'm not sure what you mean here. By leaving it up to applications, we are allowing generic clients to use this as needed.\r\n\r\n> Btw, you use the notation pk(skU) but this is denoted by the simple pkU \r\n\r\nThat works. :-)\r\n\r\n> * Important correction Where it says (line 724): t = HMAC(auth_key, concat(ct, aad)), where aad is application-specific it should be t = HMAC(auth_key, concat(n, ct, aad)), where aad is application-specific the nonce needs to be authenticated (it's my fault, I overlooked it in the text I sent you). \r\n\r\nWhoops -- yes, will fix!\r\n\r\n>* line 896 Abort(): should one define an error message for it?\r\n\r\nI replaced this with \"raise DecryptionError\", to make it a bit more clear.",
          "createdAt": "2020-06-18T02:43:03Z",
          "updatedAt": "2020-06-18T02:43:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw -- I updated this based on your feedback above. Everything should be accounted for, but please let me know if not!",
          "createdAt": "2020-06-18T02:45:31Z",
          "updatedAt": "2020-06-18T02:45:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, I pushed one more update that separates application AAD and the authentication-only data in credentials. Hopefully this is more clear!",
          "createdAt": "2020-06-18T03:08:02Z",
          "updatedAt": "2020-06-18T03:08:02Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "On Wed, Jun 17, 2020 at 10:43 PM Christopher Wood <notifications@github.com>\nwrote:\n\n>\n>    - Question (pure curiosity): What was the functionality of the\n>    \"context\" value what was context\n>\n> It was meant to link requests/responses together. But that's something\n> that can be handled by the instantiation (OPAQUE-EA in this case).\n>\n>\n>    - Line 642: Envelope is defined as an encryption of a Credentials\n>    structure, but encryption is only required for skU. Maybe \"an authenticated\n>    encoding\" instead of encryption, since everything in it requires\n>    authentication. (same appears in line 821)\n>\n> That works for me -- I'll use that text.\n>\n>\n>    - params, the MHF parameters established out of band Shouldn't we\n>    allow for params to be communicated by the server to client (this would be\n>    another potential element of Envelope)\n>\n> I don't think so. Clients can choose to harden the password using whatever\n> parameters they wish, right? Why does the server need to have any input\n> here?\n>\nThe question is how the client knows at login time what parameters it has\nto use. The client machine may be running OPAQUE instances with different\nservers and users that have different parameters. In such a case, the\nserver needs to store these parameters (that were set a password\nregistration phase)  and send them to the client.\n\n\n>    - Calculation of keys using HKDF-Expand (lines 720..., also 891...)\n>    Here is how the calculation should look: pseudorandom_pad =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt)) auth_key =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na) exporter_key =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne) The keywords Key=\n>    and info= are not needed. RFC 5869 defines HKDF-Expand with three\n>    parameters corresponding to key, info and length, so just writing\n>    pseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt)) should be\n>    enough (I write the name of the fields to clarify the semantics but this is\n>    not needed for specification).\n>\n> To be clear, you're just suggesting removing the argument labels (\"key=\"),\n> right? I don't see any difference between concat(nonce, \"Pad\") and\n> concat(\"Pad\", nonce).\n>\nYes, that is what I was suggesting but note that the change from what you\nhad before is much more significant than that. You had\nHKDF-Expand(salt=n, IKM=RwdU, \"Pad\", len(pt))\nwhich uses the nonce as salt, but only HKDF-Extract uses salt, not Expand.\n\nBtw, I prefer \"nonce\" or \"Nonce\" better than n. Also: Is Ne (the length of\n> exporter_key) defined? We can use the same length for auth_key and\n> exporter_key - they should be HashLen where this denotes the output length\n> from the hash underlying HKDF (or HMAC)\n>\n> Yep, Ne is the length of the exporter key. It's a parameter to the\n> functions where it's used. I folded Na and Ne together. I'll specify a\n> value for this in a separate PR.\n>\n>\n>    - Encryption and aad You define (line 718) pt =\n>    SerializeCredentials(C) and then (line 723) ct = xor(pt, pseudorandom_pad)\n>    which means you are mandating the encryption of all fields in Credentials.\n>    I don't think we want to do that. Some people (like Kevin and I got this\n>    feedback from AWS too) want to keep pkS unencrypted so we should\n>    accommodate that. I also find the text in line 733-736 confusing. Shouldn't\n>    the SerializeCredentials get as input an indication of what Credentials\n>    fields are included and which are part of pt and which of aad? In\n>    particular I don't like to leave this to the application: \"Instantiations\n>    of OPAQUE MUST specify how aad is constructed and serialized.\" Shouldn't\n>    the OPAQUE client be standardized independently of the applications?\n>\n> I don't know of a good way to specify this in the pseudocode without a\n> mess of branches. I think the default case should be to encrypt pkS, and we\n> can specify variants (moving pkS out of Credentials and into aad, for\n> example) in the text. But we can also flip that around and make the default\n> case be to only authenticate pkS, with text suggesting it may optionally be\n> encrypted. Would that work?\n>\nWhy can't you have two components in Credentials: pt and aad, and the\napplication chooses which fields to map to each one? I understand that what\nyou propose is simpler but it also requires customizing the client to\ndifferent applications. In the case where the client is \"written\" for a\nspecific application, that's fine, but if you have a situation where the\nsame client interacts with different applications/servers then things\nbecome problematic.\n\nIs it ok to leave it up to the application? Don't you want to build generic\n> clients? Can't the SerializeCredentials function have as input the\n> encrypted and authenticated elements?\n>\n> I'm not sure what you mean here. By leaving it up to applications, we are\n> allowing generic clients to use this as needed.\n>\nI am thinking of a web browser running OPAQUE (as a client) with different\nservers that may have different policies regarding what is\nincluded/encrypted/authenticated. So you want a standardized way for the\nserver to  communicate the structure of the envelope to the browser.\n\n\n> Btw, you use the notation pk(skU) but this is denoted by the simple pkU\n>\n> That works. :-)\n>\n>\n>    - Important correction Where it says (line 724): t = HMAC(auth_key,\n>    concat(ct, aad)), where aad is application-specific it should be t =\n>    HMAC(auth_key, concat(n, ct, aad)), where aad is application-specific the\n>    nonce needs to be authenticated (it's my fault, I overlooked it in the text\n>    I sent you).\n>\n> Whoops -- yes, will fix!\n>\n>\n>    - line 896 Abort(): should one define an error message for it?\n>\n> I replaced this with \"raise DecryptionError\", to make it a bit more clear.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#issuecomment-645735586>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXW5OCWTJT6XD646JTRXF5MHANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T04:29:52Z",
          "updatedAt": "2020-06-18T04:29:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The question is how the client knows at login time what parameters it has to use. The client machine may be running OPAQUE instances with different servers and users that have different parameters. In such a case, the server needs to store these parameters (that were set a password registration phase)  and send them to the client.\r\n\r\nAh, okay, good point. I was assuming the application was \"fixed,\" e.g., a mobile app in which the parameters are baked into the code. But that might not always be the case. I'll just revert this for now.\r\n\r\n> Why can't you have two components in Credentials: pt and aad, and the application chooses which fields to map to each one? I understand that what you propose is simpler but it also requires customizing the client to different applications. In the case where the client is \"written\" for a specific application, that's fine, but if you have a situation where the same client interacts with different applications/servers then things become problematic.\r\n\r\nSent an email to discuss offline!",
          "createdAt": "2020-06-18T05:05:15Z",
          "updatedAt": "2020-06-18T05:05:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the difference in our approaches/expectations is that you think of\nOPAQUE for use inside a standalone application that has full control of the\nclient and I think more about a \"universal\" mechanism, e.g., a standardized\nbrowser-based client.\n\nOn Thu, Jun 18, 2020 at 1:05 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> The question is how the client knows at login time what parameters it has\n> to use. The client machine may be running OPAQUE instances with different\n> servers and users that have different parameters. In such a case, the\n> server needs to store these parameters (that were set a password\n> registration phase) and send them to the client.\n>\n> Ah, okay, good point. I was assuming the application was \"fixed,\" e.g., a\n> mobile app in which the parameters are baked into the code. But that might\n> not always be the case. I'll just revert this for now.\n>\n> Why can't you have two components in Credentials: pt and aad, and the\n> application chooses which fields to map to each one? I understand that what\n> you propose is simpler but it also requires customizing the client to\n> different applications. In the case where the client is \"written\" for a\n> specific application, that's fine, but if you have a situation where the\n> same client interacts with different applications/servers then things\n> become problematic.\n>\n> Sent an email to discuss offline!\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#issuecomment-645774735>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXVWM7BCPBSA5PNEDKTRXGOBPANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T20:26:37Z",
          "updatedAt": "2020-06-18T20:26:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg4MzY5",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:26:41Z",
          "updatedAt": "2020-06-18T22:26:42Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "I prefer OPAQUE credentials than application credentials",
              "createdAt": "2020-06-18T22:26:41Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg5Mjgw",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:28:57Z",
          "updatedAt": "2020-06-18T22:28:58Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I would not call all of them essential, just skU and pkS are.\r\n\r\nDo we want to restrict to just these five or leave further extensibility in case it is needed (e.g., we were discussing the hardening parameters as a possible addition to the envelope).\r\n",
              "createdAt": "2020-06-18T22:28:58Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg5ODYy",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:30:21Z",
          "updatedAt": "2020-06-18T22:30:21Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Applications credentials that require authentication but not secrecy",
              "createdAt": "2020-06-18T22:30:21Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkwNDQ0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:31:50Z",
          "updatedAt": "2020-06-18T22:31:51Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "maybe auth_tag instead of just tag? (not too important)",
              "createdAt": "2020-06-18T22:31:50Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkyMDIz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:36:05Z",
          "updatedAt": "2020-06-18T22:36:05Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I noted that skU and pkS are mandatory. We might want to leave room for other things. The hardening parameters might be one of them, if they aren't transmitted at the application layer.",
              "createdAt": "2020-06-18T22:36:05Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkzNzky",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:40:39Z",
          "updatedAt": "2020-06-18T22:40:39Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "How is server policy (what is encrypted and what is not in the envelope) communicated to the client? DO we need a special message (echoing the credentials structure) for that?",
              "createdAt": "2020-06-18T22:40:39Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk0NDc0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:42:21Z",
          "updatedAt": "2020-06-18T22:42:21Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "what is the use of aad (additional to auth_data)?",
              "createdAt": "2020-06-18T22:42:21Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk0NzQ4",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:43:07Z",
          "updatedAt": "2020-06-18T22:43:07Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "Any AAD specific to the application, really. It's an opaque slot.",
              "createdAt": "2020-06-18T22:43:07Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1MDE0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:43:50Z",
          "updatedAt": "2020-06-18T22:43:51Z",
          "comments": [
            {
              "originalPosition": 407,
              "body": "Do we need aad? If so, where is it transmitted? It is not part of the envelope.",
              "createdAt": "2020-06-18T22:43:50Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1NTYx",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:45:12Z",
          "updatedAt": "2020-06-18T22:45:12Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "I figured it'd be best to omit that from this, since it's an application-specific detail. But we could probably have the server be crystal clear about this inline. ",
              "createdAt": "2020-06-18T22:45:12Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1NjE0",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:45:20Z",
          "updatedAt": "2020-06-18T22:45:20Z",
          "comments": [
            {
              "originalPosition": 407,
              "body": "Yes, I think so.",
              "createdAt": "2020-06-18T22:45:20Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk2MDQ5",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:46:27Z",
          "updatedAt": "2020-06-18T22:46:27Z",
          "comments": [
            {
              "originalPosition": 423,
              "body": "We need to specify that *all* values in EnvU require authentication, only secrecy is optional (except for skU for which it is mandatory)",
              "createdAt": "2020-06-18T22:46:27Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk2MTcy",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:46:47Z",
          "updatedAt": "2020-06-18T22:46:48Z",
          "comments": [
            {
              "originalPosition": 423,
              "body": "I think that's already clear from context, no?",
              "createdAt": "2020-06-18T22:46:48Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk3MDI3",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:49:10Z",
          "updatedAt": "2020-06-18T22:49:10Z",
          "comments": [
            {
              "originalPosition": 535,
              "body": "pkS is a mandatory part of EnvU",
              "createdAt": "2020-06-18T22:49:10Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk4ODI0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:54:01Z",
          "updatedAt": "2020-06-18T22:54:01Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "why tag?",
              "createdAt": "2020-06-18T22:54:01Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk5NTcz",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:56:06Z",
          "updatedAt": "2020-06-18T22:56:06Z",
          "comments": [
            {
              "originalPosition": 402,
              "body": "Make reference to RFC 5869 about the roles of the three inputs to HKDF-Expand, namely, key, info, and output length.",
              "createdAt": "2020-06-18T22:56:06Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwNzMx",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:13Z",
          "updatedAt": "2020-06-18T22:59:14Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "(This list is meant to be extended, basically.)",
              "createdAt": "2020-06-18T22:59:14Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwODYz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:34Z",
          "updatedAt": "2020-06-18T22:59:35Z",
          "comments": [
            {
              "originalPosition": 535,
              "body": "I removed this left-over text.",
              "createdAt": "2020-06-18T22:59:34Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwODk3",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:41Z",
          "updatedAt": "2020-06-18T22:59:41Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "Bug -- fixed!",
              "createdAt": "2020-06-18T22:59:41Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwOTIx",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:45Z",
          "updatedAt": "2020-06-18T22:59:46Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "I guess that aad should be replaced here with cleartext_credentials? ",
              "createdAt": "2020-06-18T22:59:46Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMDAz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:57Z",
          "updatedAt": "2020-06-18T22:59:58Z",
          "comments": [
            {
              "originalPosition": 402,
              "body": "I added a reference at the end of this algorithm.",
              "createdAt": "2020-06-18T22:59:57Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMzA4",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T23:00:44Z",
          "updatedAt": "2020-06-18T23:00:44Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Yep, good catch!",
              "createdAt": "2020-06-18T23:00:44Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMzkw",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I approve this but see the comments I have interleaved in the code",
          "createdAt": "2020-06-18T23:00:57Z",
          "updatedAt": "2020-06-18T23:00:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODEyMzE4",
      "title": "Remove TLS 1.3 integration details.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/38",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #2.\r\n\r\nThis removes TLS 1.3 integration details, but keeps the SIGMA-I content. (TLS 1.3 details will go in the TLS document.)",
      "createdAt": "2020-06-18T23:35:42Z",
      "updatedAt": "2021-04-24T15:11:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "683cb6842f4a9e862cc5982247afdc4ce2526282",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-tls",
      "headRefOid": "2196764fc36b09dbb5719a18760c6d1b8d1ab604",
      "closedAt": "2020-06-19T15:14:46Z",
      "mergedAt": "2020-06-19T15:14:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "13cb903eee61256b31c08b1dadbbabe47d3fcee6"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I love that line :-D",
          "createdAt": "2020-06-19T15:11:58Z",
          "updatedAt": "2020-06-19T15:11:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk5OTUx",
          "commit": {
            "abbreviatedOid": "cfb1c92"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good. I would still have some text pointing to the need to integrate with TLS to achieve user account privacy and to implement the record layer where information is protected by keys generated/authenticated by OPAQUE. \r\n\r\nSomewhat related, I would like to keep this remark (possible re-phrased and shortened): \r\n   Note on user authentication vs. authenticated key exchange. OPAQUE\r\n   provides PAKE (password-based authenticated key exchange)\r\n   functionality in the client-server setting. While in the case of user\r\n   identification, focus is often on the authentication part, we stress\r\n   that the key exchange element is not less crucial. Indeed, in most\r\n   cases user authentication is performed to enforce some policy, and\r\n   the key exchange part is essential for binding this enforcement to\r\n   the authentication step. Skipping the key exchange part is analogous\r\n   to carefully checking a visitor's credential at the door and then \r\n   leaving the door open for others to enter freely.",
          "createdAt": "2020-06-19T04:49:35Z",
          "updatedAt": "2020-06-19T04:49:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODI0NDgy",
      "title": "Move configuration information to separate section.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/39",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This shuffles content around, mostly.",
      "createdAt": "2020-06-19T00:24:24Z",
      "updatedAt": "2021-04-24T15:11:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "12c2440575fd2bb47a3aaaeffc7152806b44d94a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/configurations",
      "headRefOid": "56231a77e51785ee2ba6ec9d55bcf2aa8549facf",
      "closedAt": "2020-06-19T15:06:44Z",
      "mergedAt": "2020-06-19T15:06:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "683cb6842f4a9e862cc5982247afdc4ce2526282"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk3NzA0",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T04:41:06Z",
          "updatedAt": "2020-06-19T04:41:06Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It is TBD how the server does that",
              "createdAt": "2020-06-19T04:41:06Z",
              "updatedAt": "2020-06-19T04:41:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk3Nzc2",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T04:41:24Z",
          "updatedAt": "2020-06-19T04:41:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTUwNTIx",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:06:38Z",
          "updatedAt": "2020-06-19T15:06:39Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Yeah, we'll need to work out a way to do this before revving the draft.",
              "createdAt": "2020-06-19T15:06:38Z",
              "updatedAt": "2020-06-19T15:06:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3MTM3MDYw",
      "title": "Exporter -> export, adding HKDF-Extract around Harden call",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/40",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should wrap the Harden() call with an HKDF-Extract call, since there is no guarantee that Harden will output pseudorandom bits\r\n\r\nAlso changed \"exporter key\" to read simply as \"export key\"",
      "createdAt": "2020-07-09T23:08:17Z",
      "updatedAt": "2020-12-16T09:54:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "120464d640d093ff99da8d8350766aafb5f28974",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_hkdf_extract",
      "headRefOid": "f136373e87fad07782041b9129ff36e73e3b98fb",
      "closedAt": "2020-07-11T00:30:40Z",
      "mergedAt": "2020-07-11T00:30:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "aae69344bcc40290a825b9503540f607e48bcac7"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ",
          "createdAt": "2020-07-10T22:35:47Z",
          "updatedAt": "2020-07-10T22:35:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzU5ODg1",
          "commit": {
            "abbreviatedOid": "f136373"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-07-11T00:30:34Z",
          "updatedAt": "2020-07-11T00:30:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ5NjkyNjU1",
      "title": "Recommend a particular encoding policy for skU, pkS, and IdS.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/41",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @kevinlewi ",
      "createdAt": "2020-07-15T19:41:04Z",
      "updatedAt": "2021-04-24T15:11:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "aae69344bcc40290a825b9503540f607e48bcac7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/recommend-encoding",
      "headRefOid": "d31dd83f56078d8f3c00f19d953668e96cb6cfbf",
      "closedAt": "2020-07-21T16:42:39Z",
      "mergedAt": "2020-07-21T16:42:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "21f45acd09457f120470a946de1f9a9851b74de5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDYyMDY3",
          "commit": {
            "abbreviatedOid": "2de0620"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Regarding: \"to not store redundant encryptions of these (shared) values for each user.\" Reusing pkS with different users is not a must, and in principle even idS could be different for different users. So I would say something like \"to not store redundant encryptions of these values for each user in case the server uses the same values for multiple/all users.\" (Or something like that)\r\n\r\nThe word  '(shared)' with the meaning of \"common to multiple/all users\" may be unclear. Use something else (I couldconfusing as it could be shared with t",
          "createdAt": "2020-07-18T14:55:31Z",
          "updatedAt": "2020-07-18T14:55:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3MDc1NTMw",
      "title": "Fixing length requirement typos for RegistrationResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/44",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- secret_types must contain at least skU\r\n- cleartext_types may be empty\r\n\r\nTherefore, lowering the length requirements of these vectors in RegistrationResponse to be 1 and 0, respectively.\r\n\r\nAlso updating my email and adding a close bracket",
      "createdAt": "2020-08-13T00:27:36Z",
      "updatedAt": "2020-12-16T09:54:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e03a8a3e945193567e99424db5bda83f33219fe9",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "typos_1",
      "headRefOid": "9f6b074d83ba64607fcd735f23f1b76832014057",
      "closedAt": "2020-08-20T19:52:46Z",
      "mergedAt": "2020-08-20T19:52:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f32a22595db939752bd94c51bb2a4cc1c53e24e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxOTM4Nzg1",
          "commit": {
            "abbreviatedOid": "9f6b074"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-20T19:52:42Z",
          "updatedAt": "2020-08-20T19:52:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxNjI4NDQx",
      "title": "Align KE instantiations with the core protocol messages.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This aligns the KE instantiations with the core protocol messages, using them where appropriate instead of OPRF1/OPRF2/EnvU etc directly. ",
      "createdAt": "2020-08-21T13:18:40Z",
      "updatedAt": "2021-04-24T15:11:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f32a22595db939752bd94c51bb2a4cc1c53e24e6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/align-kes",
      "headRefOid": "c3052cc22e44bd9cea52b02f4b947bbcbd7f7d38",
      "closedAt": "2020-08-24T17:31:51Z",
      "mergedAt": "2020-08-24T17:31:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d6fcfaa0ce739c702683cc555b7aa4d1d9cb251a"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated the change based on your comments. Thanks for the feedback! In response to your overall comment:\r\n\r\n> I left multiple comments, most minor. Two important issues to finalize is the derivation of keys for the KE protocols, specifically should we use a single call to HKDF or should we have separate calls for each key (in any case one needs to define the lengths of the individual keys). The other is to finalize some details in the computation of the HMQV key. I owe that to you.\r\n\r\nLet's update the key schedule in a separate PR. I'll await your input for the HMQV key derivation.",
          "createdAt": "2020-08-23T14:28:23Z",
          "updatedAt": "2020-08-23T14:28:45Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok. Just add to the last sentence:\n\nand KE3 provides explicit client authentication and full forward security\n(without it forward secrecy is only achieved against eavesdroppers)\n\nOn Sun, Aug 23, 2020 at 4:59 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* commented on this pull request.\n> ------------------------------\n>\n> In draft-irtf-cfrg-opaque.md\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45#discussion_r475266680>\n> :\n>\n> > @@ -1015,28 +1022,27 @@ login.\n>\n>  # OPAQUE Instantiations {#instantiations}\n>\n> -We present several instantiations of OPAQUE using DH-OPRF\n> -and different KE protocols. For the sake of concreteness we focus on\n> -KE protocols consisting of three messages, denoted KE1, KE2, KE3, and\n> -such that KE1 and KE2 include DH values sent by user and server,\n> -respectively, and KE3 provides explicit user authentication.\n> +This section describes several instantiations of OPAQUE using different KE protocols.\n> +For the sake of concreteness it only includes KE protocols consisting of three messages,\n> +denoted KE1, KE2, KE3, where KE1 and KE2 include DH values sent by client and\n> +server, respectively, and KE3 provides explicit client authentication.\n>\n> I chose to keep this text (since it's not new, only copied). We can fix it\n> in a separate issue if needed.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45#discussion_r475266680>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXSE3V6WRN7YOFAKQUTSCF7K7ANCNFSM4QHI6AMA>\n> .\n>\n",
          "createdAt": "2020-08-23T21:31:12Z",
          "updatedAt": "2020-08-23T21:31:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2MjE3",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T03:28:07Z",
          "updatedAt": "2020-08-23T03:28:08Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I do not like the \"at the end, the client proves the user's knowledge of the password\" as it sounds as if that is a step in the protocol. It is true that for the KE protocol to be successfully authenticated, the client must have possession of the user's password. Maybe you want to rephrase somehow.\r\n",
              "createdAt": "2020-08-23T03:28:07Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2ODIw",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T03:46:23Z",
          "updatedAt": "2020-08-23T03:46:24Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This is existing text, but I\u2019ll see if we can rework it.",
              "createdAt": "2020-08-23T03:46:23Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2Mzg0",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I left multiple comments, most minor. Two important issues to finalize is the derivation of keys for the KE protocols, specifically should we use a single call to HKDF or should we have separate calls for each key (in any case one needs to define the lengths of the individual keys). The other is to finalize some details in the computation of the HMQV key. I owe that to you.",
          "createdAt": "2020-08-23T03:33:12Z",
          "updatedAt": "2020-08-23T05:46:38Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Just to make sure, this error should lead to aborting the session",
              "createdAt": "2020-08-23T03:33:12Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 85,
              "body": "All the protocols we describe provide explicit mutual authentication, so not sure I would single out the explicit authentication of the user, except if you feel the need to say what KE3 is for. Btw, in these protocols, the third message has the essential role of providing \"full forward security\" to the protocol. Without it, the protocol would only have weak forward secrecy which is not enough in general for OPAQUE security.",
              "createdAt": "2020-08-23T03:39:52Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 107,
              "body": "Can we say \"authenticate credential_request and credential_response, resepctively, ...\"?\r\nIt is longer but clearer (to me at least)",
              "createdAt": "2020-08-23T03:44:41Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 114,
              "body": "DH keys are for the HMQV and 3DH cases, not for SIGMA",
              "createdAt": "2020-08-23T03:57:44Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 193,
              "body": "Remove this last remark, it is not entirely correct.",
              "createdAt": "2020-08-23T04:08:01Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 164,
              "body": "Add here (or elsewhere) that  these ephemeral DH values need to be  verified to belong to the correct group (via membership tests or cofactor exponentiation, depending on curve details). The same holds for public keys during the registration phase.",
              "createdAt": "2020-08-23T04:23:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 114,
              "body": "Important: These public keys, exchanged during the registration phase  should be  verified to belong to the correct group (via membership tests or cofactor exponentiation, depending on curve details). ",
              "createdAt": "2020-08-23T04:24:50Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 209,
              "body": "Should we use the derivation style from TLS 1.3 and the rest of this document where each key has its own Expand call (and its own info/label value)? Either way, one needs to define the length of each of these keys (which depend on the MAC and encryption functions in use and whatever length one wants SK to be)",
              "createdAt": "2020-08-23T04:32:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 224,
              "body": "The definition of HMQV needs some care: the values u and s should be mapped to elements mod q where q is the order of the group and one should not use the hash function directly but some RO-like construction, maybe HKDF itself. I need to think about this. Also, the computation of Khmqv by the server (and similarly for the client) should first define the intermediate value  v = (eskS + u\\*skS) mod q and then compute Khmqv = (epkU \\* pkU^u)^v. I need to think about this some more. In particular, I need to check how you deal with some of similar issues, particularly RO hashing, in your definition of OPRF.",
              "createdAt": "2020-08-23T05:28:32Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 246,
              "body": "move nonceU before info1* for uniformity with the other specifications",
              "createdAt": "2020-08-23T05:34:35Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 258,
              "body": "IdU and IdS are defined in the explanation of these fields (appearing first for HMQV/3DH). In particular it is said there that IdU is the  identity used to create credential_request. I don't think it needs to be said here again (and if there is a reason for it, why only define IdU here and not also IdS?)",
              "createdAt": "2020-08-23T05:41:32Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNTEw",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:55:28Z",
          "updatedAt": "2020-08-23T13:55:28Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "I'd be fine with that change. Specifying a key schedule similar to TLS 1.3 seems reasonable. Let me try and put that together.",
              "createdAt": "2020-08-23T13:55:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNTgy",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:56:06Z",
          "updatedAt": "2020-08-23T13:56:06Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "I forgot to revert this -- thanks for flagging it.",
              "createdAt": "2020-08-23T13:56:06Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNzY0",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:58:28Z",
          "updatedAt": "2020-08-23T13:58:28Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I felt it was worth highlighting since otherwise it appears out fo context. I'll just remove it. ",
              "createdAt": "2020-08-23T13:58:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzOTA5",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:00:08Z",
          "updatedAt": "2020-08-23T14:00:09Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Yep!",
              "createdAt": "2020-08-23T14:00:09Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE1Njk2",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:23:16Z",
          "updatedAt": "2020-08-23T14:23:16Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "(I'll do that in a followup change, to keep this diff smaller)",
              "createdAt": "2020-08-23T14:23:16Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE1OTcz",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:26:25Z",
          "updatedAt": "2020-08-23T14:26:26Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "The OPRF document uses hash_to_curve where appropriate: https://tools.ietf.org/html/draft-irtf-cfrg-voprf-04#section-2.1",
              "createdAt": "2020-08-23T14:26:25Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE2MTMz",
          "commit": {
            "abbreviatedOid": "9ddc0a0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:27:51Z",
          "updatedAt": "2020-08-23T14:27:51Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Yep, it does. If this isn't clear, I can add a note as such.",
              "createdAt": "2020-08-23T14:27:51Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDQ1MzE0",
          "commit": {
            "abbreviatedOid": "9ddc0a0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T20:59:15Z",
          "updatedAt": "2020-08-23T20:59:15Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I chose to keep this text (since it's not new, only copied). We can fix it in a separate issue if needed.",
              "createdAt": "2020-08-23T20:59:15Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcyNjczOTgx",
      "title": "Update the HMQV key derivation details. Clean up some presentation bugs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/46",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-24T17:53:03Z",
      "updatedAt": "2021-04-24T15:11:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d6fcfaa0ce739c702683cc555b7aa4d1d9cb251a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hmqv-update",
      "headRefOid": "b3781464f814953b38080ac849589203e09e8ef5",
      "closedAt": "2020-08-24T22:41:28Z",
      "mergedAt": "2020-08-24T22:41:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "63a8acabd6e6420146cb38a0cd8f238688839107"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODIxMzAy",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I approve pending the attached review comments.",
          "createdAt": "2020-08-24T20:11:17Z",
          "updatedAt": "2020-08-24T21:27:24Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "#derive-3dh should be #derive-hmqv  here",
              "createdAt": "2020-08-24T20:11:17Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 51,
              "body": "let's change mod p to mod (len(p)-1)",
              "createdAt": "2020-08-24T20:14:08Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 44,
              "body": "Both client and server need to compute u and s, so it does not work to put the definition of u under the client computation and s under the server computation. They should go together at the beginning, at the end, or both as part of the user computation, and then saying that the server computes them same as the client.",
              "createdAt": "2020-08-24T20:17:18Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 74,
              "body": "change to:\r\nlen(\"server\") || \"server\"",
              "createdAt": "2020-08-24T21:17:02Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 75,
              "body": "change mod p to mod (len(p)-1)",
              "createdAt": "2020-08-24T21:17:57Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 81,
              "body": "remove last line",
              "createdAt": "2020-08-24T21:19:38Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcwMDM4",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:29:13Z",
          "updatedAt": "2020-08-24T21:29:13Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Oops, wrong headers!",
              "createdAt": "2020-08-24T21:29:13Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcwODMz",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:30:40Z",
          "updatedAt": "2020-08-24T21:30:40Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "hah, I thought I copied the right text!",
              "createdAt": "2020-08-24T21:30:40Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcxMzA4",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:31:33Z",
          "updatedAt": "2020-08-24T21:31:34Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Which line?",
              "createdAt": "2020-08-24T21:31:33Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTQyMzQz",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T22:40:57Z",
          "updatedAt": "2020-08-24T22:40:58Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "(I wasn't sure what line you were referring to, so I'll merge now and can clean this up later!)",
              "createdAt": "2020-08-24T22:40:58Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTE3MTAx",
          "commit": {
            "abbreviatedOid": "b378146"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T03:55:48Z",
          "updatedAt": "2020-08-25T03:55:49Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "My bad. I read HMQV instead of HKDF (too many H's :-)",
              "createdAt": "2020-08-25T03:55:49Z",
              "updatedAt": "2020-08-25T03:55:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcyODI5NjIy",
      "title": "Adopt the TLS 1.3 key schedule for better separation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/47",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-24T23:00:22Z",
      "updatedAt": "2021-04-24T15:11:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "63a8acabd6e6420146cb38a0cd8f238688839107",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/key-schedule",
      "headRefOid": "335f4e66c75d6523d85fb16811f0753dd42f4ec5",
      "closedAt": "2020-08-26T12:26:35Z",
      "mergedAt": "2020-08-26T12:26:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "196753132f819990fa1c582995985fbe87ae6de7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTIxMjMy",
          "commit": {
            "abbreviatedOid": "c9f73de"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "See the comments on the key derivation. We need to decide on these (annoying) details",
          "createdAt": "2020-08-25T04:10:03Z",
          "updatedAt": "2020-08-25T04:37:17Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "\"OPAQUE\" instead of \"tls13\" I guess (use upper case OPAQUE to distinguish from the opaque type.",
              "createdAt": "2020-08-25T04:10:03Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            },
            {
              "originalPosition": 25,
              "body": "What I call Ke2, Ke3  is the equivalent of the handshake write keys in TLS 1.3, and Km2, Km3 are the equivalent of Finished keys. What I call SK is a key from which traffic write keys are derived. \r\nSo the equivalent to TLS would be to use  Derive_Secret to output handshake_traffic_secret and application_traffic_secret and then define the write_key derivations as in Section 7.3 of TLS 1.3 and the Finished key derivation as in Section 4.4 and 4.4.4.\r\nIf you want to simplify and keep it the way you defined it now, note that Ke2 and Ke3 cannot use hash.length but would have a length that depends on the ciphersuite's AEAD.\r\n\r\n",
              "createdAt": "2020-08-25T04:34:43Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDUyMDc4",
          "commit": {
            "abbreviatedOid": "c9f73de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T12:56:03Z",
          "updatedAt": "2020-08-25T12:56:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Copy-paste bug :) Will fix!",
              "createdAt": "2020-08-25T12:56:03Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDc0NzYy",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T13:22:27Z",
          "updatedAt": "2020-08-25T13:22:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Ah! Thanks for clarifying. I split the schedule into two parts: one for handshake secrets (Ke2, Ke3, Km2, Km3) and output AKE secrets (SK). All handshake keys, including the encryption and Finished/MAC keys, are derived from the client/server handshake secrets. What do you think?",
              "createdAt": "2020-08-25T13:22:28Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTc3Nzg0",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:24:09Z",
          "updatedAt": "2020-08-25T22:24:09Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Here is a simplification\r\n\r\n  HKDF-Extract(salt=0, IKM) = main_secret\r\n      |\r\n      +--> Derive-Secret(., \"c hs secret\", info) = client_handshake_secret\r\n      |\r\n      +--> Derive-Secret(., \"s hs secret\", info) = server_handshake_secret\r\n      |\r\n      +--> Derive-Secret(., \"c sk secret\", info) = client_session_key\r\n      |\r\n      +--> Derive-Secret(., \"s sk secret\", info) = server_session_key\r\n      |\r\n      v\r\n\r\nAnd it can even be simplified further by deriving a single handshake_secret and single session_key and do the separation client/server in further derivation.\r\n\r\nIt really depends how close to TLS 1.3 you want to be.  For example, do we want to stop at the session_key derivation or also derive the \"write keys\" for the AEAD to protect subsequent traffic as TLS 1.3 does?  \r\n",
              "createdAt": "2020-08-25T22:24:09Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTg5NDI0",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:29:45Z",
          "updatedAt": "2020-08-25T22:29:45Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Btw, getting too close to TLS 1.3 in names (e.g. client_handshake_secret), we may need to add \"OPAQUE\" as a label. Or maybe this is only done when actually integrating with TLS. \r\n",
              "createdAt": "2020-08-25T22:29:45Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MDA5NzE5",
          "commit": {
            "abbreviatedOid": "4525e69"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:39:49Z",
          "updatedAt": "2020-08-25T22:39:49Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yeah, I think it's fine to reuse the names here. I applied the simplification you suggested (compressed to a single handshake and session secret), and then derived all handshake secrets (MAC and enc keys) from the handshake_secret.",
              "createdAt": "2020-08-25T22:39:49Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MTEyODk0",
          "commit": {
            "abbreviatedOid": "5c0b90e"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Look good! One nit: Change labels \"client auth\" to \"client mac\" (same for server)",
          "createdAt": "2020-08-26T02:46:09Z",
          "updatedAt": "2020-08-26T02:46:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc0OTk3NjI0",
      "title": "Fix the nonce length (Nn) to 32 bytes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Making this a parameter seems like too much flexibility, so I suggest we be opinionated and remove it. ",
      "createdAt": "2020-08-27T23:11:34Z",
      "updatedAt": "2021-04-24T15:11:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "196753132f819990fa1c582995985fbe87ae6de7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fix-nonce",
      "headRefOid": "9fd53b3663bfb8bc871e3556ccd135df6a303242",
      "closedAt": "2020-08-28T17:07:59Z",
      "mergedAt": "2020-08-28T17:07:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a7d1e6cc3f87c7e4a1c4ed02aa633650191ea074"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> that in the future someone will want to steal a few bytes here and there from the nonce and then... :- )\r\n\r\nHah! :-)\r\n\r\n> Anyway, I would keep the Nn but I am ok if you feel strongly about getting rid of it.\r\n\r\nMy take is that an OPAQUE configuration can simply specify an OPRF, hash function (for HMAC and HKDF), and MHF, without any additional parameters. \r\n\r\nHow about I merge this with a note saying we could make this a parameter if flexibility is desired, and then as the larger group for feedback?",
          "createdAt": "2020-08-28T00:00:30Z",
          "updatedAt": "2020-08-28T00:00:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with the 32 bytes. There is enough room to steal from it if needed. I can see it as more probable that someone will want to save in EnvU size than that 32 bytes will not be enough.\r\nBtw, you also need an AKE to specify OPAQUE in addition to the components you mention. ",
          "createdAt": "2020-08-28T00:52:55Z",
          "updatedAt": "2020-08-28T00:52:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Btw, you also need an AKE to specify OPAQUE in addition to the components you mention.\r\n\r\nYep!",
          "createdAt": "2020-08-28T17:07:55Z",
          "updatedAt": "2020-08-28T17:07:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTU3Mjgy",
          "commit": {
            "abbreviatedOid": "e0622f3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't feel strongly about this but I don't see why with all parameters that are there, we need to remove just this one. One can imagine, in a very hypothetical way, that in the future someone will want to steal a few bytes here and there from the nonce and then... :- )\r\nIt also works in the other direction, for example for the envelope nonces 32 bytes is quite overkill as all one needs is that it does not repeat for a number of uses that is upper bound by the number of times the user changes his password over the history of his account. A 64-bit nonce would probably ok a 128-bit for sure. \r\nAnyway, I would keep the Nn but I am ok if you feel strongly about getting rid of it.\r\nYour call, I approve it anyway.",
          "createdAt": "2020-08-27T23:54:35Z",
          "updatedAt": "2020-08-27T23:54:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1NTM5MzQy",
      "title": "Add a hash function dependency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/49",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And use it to control the auth_key and exporter_key size(s). ",
      "createdAt": "2020-08-28T17:21:45Z",
      "updatedAt": "2021-04-24T15:11:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a7d1e6cc3f87c7e4a1c4ed02aa633650191ea074",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hash",
      "headRefOid": "23077ece157fe3da3a8a59b93b5f55814d52a337",
      "closedAt": "2020-08-30T16:20:07Z",
      "mergedAt": "2020-08-30T16:20:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7065e8d74c16275d98131340d3d197ee17cdf4b5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I agree that it's overkill. I'll mark this as an OPEN ISSUE to consider fixing in the OPRF draft. (There was no reason to use SHA-512, other than being conservative, I think.)",
          "createdAt": "2020-08-30T16:18:48Z",
          "updatedAt": "2020-08-30T16:18:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDk4MDA5",
          "commit": {
            "abbreviatedOid": "c238558"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am ok with the changes. SHA-512 is overkill for most keys derived in the protocol (256 bits are more than enough) but I guess we inherit the 512 from the OPRF ciphersuites.  Was there a special reason to use SHA-512 with 256-bit curves (P256 and 25519)? \r\n",
          "createdAt": "2020-08-29T04:44:43Z",
          "updatedAt": "2020-08-29T04:44:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1OTMyNTc3",
      "title": "Require that the envelope export_key HMAC is checked before using the key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/50",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #30.",
      "createdAt": "2020-08-30T16:25:31Z",
      "updatedAt": "2021-04-24T15:11:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7065e8d74c16275d98131340d3d197ee17cdf4b5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/export-key-check",
      "headRefOid": "3914250e1bead6a4deef2f124b1ee8e0268d42c0",
      "closedAt": "2020-08-31T14:25:21Z",
      "mergedAt": "2020-08-31T14:25:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "48ad199022ca5fdaa6e99a45a08c4adc4a3b7cb8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MzAzNTU1",
          "commit": {
            "abbreviatedOid": "3914250"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-31T04:46:39Z",
          "updatedAt": "2020-08-31T04:46:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4Mjg0Njc4",
      "title": "Restructure the document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This shuffles text around and fixes some lingering issues. I'll do a full pass over the text after we merge this (or some variant of it)!",
      "createdAt": "2020-09-03T01:35:51Z",
      "updatedAt": "2021-04-24T15:11:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "48ad199022ca5fdaa6e99a45a08c4adc4a3b7cb8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/restructure",
      "headRefOid": "ef79a5b6b1cfe7d0e2d5d0bd3239d7d1f19cb25c",
      "closedAt": "2020-09-05T00:15:22Z",
      "mergedAt": "2020-09-05T00:15:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e1ff2f58342b48bb881538e3f80fa77e9af85096"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Chris, how do I edit the text in the pull request? This includes edits to\nparts you changed and also to text that existed before.\n\nOn Wed, Sep 2, 2020 at 9:36 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @chris-wood <https://github.com/chris-wood> requested your review on: #52\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52> Restructure the\n> document.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52#event-3722484022>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXZ7SDU72CEZFQ2NDDSD3XIJANCNFSM4QUC3XTQ>\n> .\n>\n",
          "createdAt": "2020-09-04T19:54:46Z",
          "updatedAt": "2020-09-04T19:54:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMDA1NzQz",
          "commit": {
            "abbreviatedOid": "ef79a5b"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Ready for last round before 00!",
          "createdAt": "2020-09-04T23:20:17Z",
          "updatedAt": "2020-09-04T23:20:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg3OTc5MzUz",
      "title": "Address Eric Crockett's review comments.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/56",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @crockeea",
      "createdAt": "2020-09-16T13:12:00Z",
      "updatedAt": "2021-04-24T15:11:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "eb5855c74d8068fdcd6267bc8beeb7865e8132b8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/eric-review",
      "headRefOid": "7e61839c338a8224d277b985c79d909a7ffff813",
      "closedAt": "2020-09-22T01:56:40Z",
      "mergedAt": "2020-09-22T01:56:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "33e5132a3e7d20f0ef33cb4a1682a3eb490e9540"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw this PR should be good to go!",
          "createdAt": "2020-09-18T12:59:46Z",
          "updatedAt": "2020-09-18T12:59:46Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am afraid that I did not pushed  my comments (which I wrote them a couple of days ago) before for you to see.  Sorry for that. Eric also asked for a couple of clarifications to add (on the need of forward secrecy and something else). If you need text from me let me know.",
          "createdAt": "2020-09-19T00:57:30Z",
          "updatedAt": "2020-09-19T00:57:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw Thanks for the feedback -- I incorporated your comments. I also added some additional changes on top. Namely:\r\n\r\n- Fix the auth_tag size to the output of HMAC. (One less variable-length thing to worry about.)\r\n- Change how the auth_tag is computed. Previously, it did not include the length of the ciphertext or auth_data, which was worrisome. Now it's computed over the structure:\r\n\r\n```\r\nstruct {\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n  opaque auth_data<0..2^16-1>;\r\n} InnerEnvelope;\r\n```\r\n\r\nwhich includes the length of `ct` and `auth_data`.\r\n\r\nPlease let me know what you think!",
          "createdAt": "2020-09-19T12:25:59Z",
          "updatedAt": "2020-09-19T12:25:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, friendly bump! Please feel free to edit the PR directly if that's easier for you. :-)",
          "createdAt": "2020-09-21T23:51:53Z",
          "updatedAt": "2020-09-21T23:51:53Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay in responding to the latest changes. I was busy welcoming my second grandson... :-)",
          "createdAt": "2020-09-22T00:45:50Z",
          "updatedAt": "2020-09-22T00:45:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODU2OTM5",
          "commit": {
            "abbreviatedOid": "7d6ffa3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-16T17:46:27Z",
          "updatedAt": "2020-09-19T00:54:26Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "You say AKE is out-of-scope but then we define several instantiations. I'm confused.",
              "createdAt": "2020-09-16T17:46:27Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 82,
              "body": "Shouldn't this (keygen for OPRF) be part of the above specification of the elements related to OPRF?",
              "createdAt": "2020-09-16T18:00:03Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 264,
              "body": "Simplify this sentence as:\r\nApplications may optionally include pkU, idU, or IdS in the Credentials.cleartext_credentials structure, or in envelopeCredentials.secret if secrecy of these values is desired. ",
              "createdAt": "2020-09-16T18:16:24Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 264,
              "body": "There is a sentence following this paragraph about server identity but the identity issues are discussed elsewhere A\r\n\r\nAlso: IdS uses capital I (also in other instances). It seems you skipped IdS in the global change to idS.",
              "createdAt": "2020-09-16T18:20:28Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 305,
              "body": "change 'authenticate stage' to \"authenticated key exchange stage\"",
              "createdAt": "2020-09-16T18:23:03Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 401,
              "body": "It is not clear what it means that \"applications must authenticate pkS\". This value is authenticated by the HMAC computation on the whole envelope so I don't think we need to single out this authentication as a separate/additional step.  Did you mean something different with this sentence?\r\n\r\nThe following text:\r\n\"If an application requires secrecy of pkS, this value SHOULD be omitted from auth_data (step 9).\"\r\nseems to belong to registration where the envelope is created not here.\r\nIf needed, let me know why (btw, the auth_data is now step 10)",
              "createdAt": "2020-09-16T18:32:06Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 438,
              "body": "I would not include this sentence about KCI here as it may be distracting. \r\nIf you think it should be there, I would say\r\nThis section describes several instantiations of OPAQUE using different AKE protocols (all of which satisfy the forward secrecy and KCI properties discussed in {{security-considerations}}).",
              "createdAt": "2020-09-16T18:36:41Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 472,
              "body": "It needs to be KCI resistant and also forward secure. Also, PQ AKE is not enough to PQ-protect data, also the data encryption scheme needs to be PQ secure.",
              "createdAt": "2020-09-16T18:41:23Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 792,
              "body": "Two comments on other parts of the specification:\r\n- Please add Greg Rubin to the list of Acknowledgments \r\n- I would change the following sentence:\r\nNote that this does not prevent a malicious server from conducting a dictionary attack on inputs provided by the client. OPAQUE assumes the server is honest, and only guarantees safeguards against parties who may later compromise the server and any stored user account information.\r\ninto:\r\nNote that a corrupted server can run an exhaustive offline dictionary attack to validate guesses for the user's password; this is inevitable in any aPAKE protocol. (OPAQUE enables a defense against such offline dictionary attacks by distributing the server so that an offline attack is only possible if all - or a minimal number of - servers are compromised.)\r\n",
              "createdAt": "2020-09-16T19:04:52Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTkzOTM0",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:52:58Z",
          "updatedAt": "2020-09-19T11:52:58Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "It's currently not part of the OPRF API, so I left it off the list above. If the OPRF draft changes, we can change this too.",
              "createdAt": "2020-09-19T11:52:58Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTkzOTYz",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:53:37Z",
          "updatedAt": "2020-09-19T11:53:38Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "What I meant is that this document doesn't intend to specify, describe, etc *new* AKEs, but I see how this is confusing. I'll just remove it.",
              "createdAt": "2020-09-19T11:53:37Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk0MDE4",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:54:51Z",
          "updatedAt": "2020-09-19T11:54:51Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "I think this entire paragraph is probably obsolete. I'll just remove it.",
              "createdAt": "2020-09-19T11:54:51Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk0MDYw",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:55:34Z",
          "updatedAt": "2020-09-19T11:55:35Z",
          "comments": [
            {
              "originalPosition": 438,
              "body": "That's a nice rewrite -- I'll take it!",
              "createdAt": "2020-09-19T11:55:34Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk1NDM2",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T12:23:49Z",
          "updatedAt": "2020-09-19T12:23:49Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Fixed!",
              "createdAt": "2020-09-19T12:23:49Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk1NDQ0",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T12:23:54Z",
          "updatedAt": "2020-09-19T12:23:54Z",
          "comments": [
            {
              "originalPosition": 305,
              "body": "Fixed!",
              "createdAt": "2020-09-19T12:23:54Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDY5MDU3",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T00:44:07Z",
          "updatedAt": "2020-09-22T00:44:08Z",
          "comments": [
            {
              "originalPosition": 874,
              "body": "Add a reference to the OPAQUE paper at the end of the parentheses",
              "createdAt": "2020-09-22T00:44:07Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDY5MTE2",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T00:44:21Z",
          "updatedAt": "2020-09-22T00:44:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MzAxNTY3",
      "title": "Clarify that keys must be unique per account.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/57",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can address private key possession proofs and WebAuthn in a future change!",
      "createdAt": "2020-09-16T23:36:25Z",
      "updatedAt": "2021-04-24T15:11:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e1ff2f58342b48bb881538e3f80fa77e9af85096",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/key-reuse",
      "headRefOid": "baf190fd07fbe640d60dd0cbf99ef7e0d6ad7ee0",
      "closedAt": "2020-09-18T12:40:32Z",
      "mergedAt": "2020-09-18T12:40:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "eb5855c74d8068fdcd6267bc8beeb7865e8132b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMTE3ODMx",
          "commit": {
            "abbreviatedOid": "baf190f"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T03:02:01Z",
          "updatedAt": "2020-09-18T03:02:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkzNzk2NDI5",
      "title": "Update draft-irtf-cfrg-opaque.md",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/61",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I made some minir edits, nothing worth highlighting I think.\r\nTwo issues that we may want to address before submitting are:\r\n\r\n1. We say IBM has a patent on HMQV. Is that enough (for now at least) or do we need to have some formal IP notice?\r\n\r\n2. Section 6.3 (called from section 3.2 and 4.2.1) refers to SP800-56A Sec 5.6.2.3.4 which seems to be phrased for ephemeral keys while in the context of Sec 3.2 we talk about static ones. More importantly, the NIST document omits any tests of membership as they assume/require cofactor clearing. Is this something we want to assume/require ourselves? I thought we would \"outsource\" these issues to documents describing the curves themselves as the choice between explicit membership tests, prime order tests, cofactor operations, etc. may depend on the specific curve. If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3. \r\n\r\nOnce we are done with these two issues, we can submit.\r\n",
      "createdAt": "2020-09-27T23:32:55Z",
      "updatedAt": "2021-04-24T15:11:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "13b1c0dcf6489faf7ca72b102358eda7168bee31",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "hugokraw-patch-1",
      "headRefOid": "e3e25988db565e6c8d2eeb16fad92ca0e165d94c",
      "closedAt": "2020-09-28T18:33:11Z",
      "mergedAt": "2020-09-28T18:33:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3c9462c70a3f2966d0b2ab3cfd8dafc805fae563"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> We say IBM has a patent on HMQV. Is that enough (for now at least) or do we need to have some formal IP notice?\r\n\r\nI think you can submit IPR here: https://datatracker.ietf.org/ipr/\r\n\r\n> If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3.\r\n\r\nI think this is covered by \"MUST validate the other party's public key(s) used for the execution of OPAQUE\", no? If not, what would you change?",
          "createdAt": "2020-09-28T14:31:58Z",
          "updatedAt": "2020-09-28T14:31:58Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding:\r\n\r\n> >If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3.\r\n\r\n> I think this is covered by \"MUST validate the other party's public key(s) used for the execution of OPAQUE\", no? If not, what would you change?\r\n\r\nThe problem is that we refer to the NIST document that does not include membership tests as they assume cofactor clearing which we don't assume. \r\nNote that we say explicitly:\r\n\r\nepkU, epkS are Diffie-Hellman ephemeral public keys chosen by user and server, respectively, which MUST be validated to be in the correct group (see {{validation}});\r\n\r\nbut then the membership test is lost in the reference to NIST.\r\n",
          "createdAt": "2020-09-28T16:55:28Z",
          "updatedAt": "2020-09-28T16:55:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The NIST document pertains only to the NIST curves, which don't require cofactor clearing (h=1). The other curves may involve cofactor clearing, but I think that's covered by the public key validation text. ",
          "createdAt": "2020-09-28T17:24:15Z",
          "updatedAt": "2020-09-28T17:24:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh. Ok. I missed the (clear) point that this is an example that only pertains to the NIST curves. Sorry for the confusion. You can go ahead and submit. Thanks.",
          "createdAt": "2020-09-28T18:25:38Z",
          "updatedAt": "2020-09-28T18:25:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Perfect -- thanks!",
          "createdAt": "2020-09-28T18:33:08Z",
          "updatedAt": "2020-09-28T18:33:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3NTQ0MTQ2",
      "title": "Fixing typo in CredentialExtension definition and updating affiliation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/64",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I believe the type of the parameter `data` in `CredentialExtension` should be `opaque`, since there is no `CredentialData` defined anywhere.\r\n\r\nAlso updating my affiliation",
      "createdAt": "2020-10-05T02:21:20Z",
      "updatedAt": "2020-12-16T09:54:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3c9462c70a3f2966d0b2ab3cfd8dafc805fae563",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_typo_1",
      "headRefOid": "405d25a53e81a3a3e51207f543712330b37969e3",
      "closedAt": "2020-10-19T18:29:41Z",
      "mergedAt": "2020-10-19T18:29:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "225bc77bec4a91c86519858ac20671fc6cd82aab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDQ2NzE1",
          "commit": {
            "abbreviatedOid": "405d25a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-19T18:29:35Z",
          "updatedAt": "2020-10-19T18:29:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2MjE2MTYw",
      "title": "Changing envelope representation in CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/66",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #62 ",
      "createdAt": "2020-10-19T19:07:37Z",
      "updatedAt": "2020-12-16T09:54:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "225bc77bec4a91c86519858ac20671fc6cd82aab",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_62",
      "headRefOid": "05d229212a21eb826abe1c9c7e29bff26d86b52b",
      "closedAt": "2020-10-20T00:47:33Z",
      "mergedAt": "2020-10-20T00:47:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "550c550ecdc86ce362d613afebad67ce186cae73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjU0OTc4",
          "commit": {
            "abbreviatedOid": "05d2292"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T00:47:29Z",
          "updatedAt": "2020-10-20T00:47:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3ODgyNjY4",
      "title": "Add a preliminary Sage implementation with many TODOs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/70",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This gets us started towards test vectors, with something that's \"as close\" to the specification as possible. There's definitely lots of ways this can be improved, including adding proper configuration and agility support, supporting different credentials in client and server, implementing a proper password file, etc. If this generally seems useful, we can add these missing pieces and then wrap it with code that generates test vectors from a variety of flows. \r\n\r\nNote that this *does not* have AKE integration. It only implements the OPAQUE core protocol. For the specification, I wonder if it makes sense to include test vectors for both the core protocol and AKE instantiations. \r\n\r\n@kevinlewi, please have a look!",
      "createdAt": "2020-10-21T21:47:26Z",
      "updatedAt": "2020-10-28T01:21:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "550c550ecdc86ce362d613afebad67ce186cae73",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ref-impl",
      "headRefOid": "dbfb4c2d52519f01ed14fc440e28858c9a9485c8",
      "closedAt": "2020-10-28T01:21:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now -- I'll re-open when the 3DH implementation is in place.",
          "createdAt": "2020-10-28T01:21:43Z",
          "updatedAt": "2020-10-28T01:21:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTU3MDY4",
      "title": "Remove pkS from CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/71",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #63 ",
      "createdAt": "2020-10-22T01:42:06Z",
      "updatedAt": "2020-12-16T09:54:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "550c550ecdc86ce362d613afebad67ce186cae73",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_63",
      "headRefOid": "dddf8300098fcd9aa71c4c54b0fa5e801008553d",
      "closedAt": "2020-10-23T21:04:20Z",
      "mergedAt": "2020-10-23T21:04:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "630173e46eaff00862dbb8446aa8a3c0b0bed8d1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDA5NTEz",
          "commit": {
            "abbreviatedOid": "dddf830"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T21:04:16Z",
          "updatedAt": "2020-10-23T21:04:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTcxMjYz",
      "title": "Omitting idU from RegistrationRequest and CredentialRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/73",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the inclusion of idU from RegistrationRequest and CredentialRequest (see #65)\r\n\r\nI also noticed that the functions `RecoverCredentials` and `FinalizeRequest` should either not take idU, or should take idU, idS, and pkU as parameters. In this PR I simply made RecoverCredentials also take idU as a parameter, but I opened #72 to discuss this further.",
      "createdAt": "2020-10-22T02:33:22Z",
      "updatedAt": "2020-12-16T09:54:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "630173e46eaff00862dbb8446aa8a3c0b0bed8d1",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_65",
      "headRefOid": "7b76e78abfaa2a6a5f37f2b83438928d774b9412",
      "closedAt": "2020-10-27T22:59:30Z",
      "mergedAt": "2020-10-27T22:59:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b775d13311dcc73bbf9eefad1b00453c9ba1bb2f"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood : This should be ready to review",
          "createdAt": "2020-10-27T03:27:32Z",
          "updatedAt": "2020-10-27T03:27:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjEyMzE1",
          "commit": {
            "abbreviatedOid": "7b76e78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-27T22:59:25Z",
          "updatedAt": "2020-10-27T22:59:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExNTMzNjQ5",
      "title": "Remove the performance considerations section.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/76",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #5.\r\n\r\nIt was somewhat stale, and I'm not sure it adds much to the document.\r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-10-28T13:08:34Z",
      "updatedAt": "2021-04-24T15:12:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "30a4a795bf17e7352a4c197d621dd4ede1db8101",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-perf-section",
      "headRefOid": "85366a81b2bcfe89beb2c4b6dd8c874146538602",
      "closedAt": "2020-11-02T22:18:22Z",
      "mergedAt": "2020-11-02T22:18:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a41ef961ea49207c1ad256b1457631b673e5d198"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": " This is fine by me",
          "createdAt": "2020-10-28T19:13:20Z",
          "updatedAt": "2020-10-28T19:13:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MzkxOTE1",
      "title": "Swap labels, and adopt new OPRF suites.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/78",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @kevinlewi, I'll target submission today!",
      "createdAt": "2020-11-02T23:28:48Z",
      "updatedAt": "2021-04-24T15:12:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a41ef961ea49207c1ad256b1457631b673e5d198",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/align-with-oprf",
      "headRefOid": "88c7e056eb21ae40766714d5add629e8c55ba81d",
      "closedAt": "2020-11-02T23:35:46Z",
      "mergedAt": "2020-11-02T23:35:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "25c0a16c4983d50ae4a75b415651034092ada78b"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Great!",
          "createdAt": "2020-11-02T23:34:33Z",
          "updatedAt": "2020-11-02T23:34:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE3NDU2Mzk3",
      "title": "Clarify base mode variant usage of voprf",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/80",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #79 ",
      "createdAt": "2020-11-09T04:22:23Z",
      "updatedAt": "2020-12-16T09:54:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "25c0a16c4983d50ae4a75b415651034092ada78b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "clarify_base_mode_voprf",
      "headRefOid": "76c1112254a38e287019dc7d5ed14d8c1c96bbb8",
      "closedAt": "2020-11-09T16:31:46Z",
      "mergedAt": "2020-11-09T16:31:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dd8581b6ac1d884673c017bd3666c6783f70baee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NDMzNjMy",
          "commit": {
            "abbreviatedOid": "76c1112"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-09T16:31:35Z",
          "updatedAt": "2020-11-09T16:31:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4ODI2NjI0",
      "title": "Defining idU and idS in AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/81",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Points mentioned after discussion from #74 \r\n\r\n- Removes the sending of idU in KE1\r\n- Adds clarification text around what idU and idS refers to in the AKE key derivation. By default, they will be taken from the idU and idS specified in the envelope. If they are not specified, then they are taken to be equal to pkU and pkS.\r\n- Also clarify that if pkU is not in the envelope, then it must be computed from skU.",
      "createdAt": "2020-11-10T23:32:21Z",
      "updatedAt": "2020-12-16T09:54:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dd8581b6ac1d884673c017bd3666c6783f70baee",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "ake_ids",
      "headRefOid": "73e04f431366c4f5275d5ff7fd311976be41d0de",
      "closedAt": "2020-11-12T23:32:13Z",
      "mergedAt": "2020-11-12T23:32:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "deeeead3207280710202773f68edb85c8171704b"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am ok with these changes, they reflect the conclusions of our discussion. \r\nI have a feeling that people will wonder about why are pkU, pkS set as default identities and in what cases they should or should not set different values for idU and idS.  Answering these question would require iterating some of the issues discussed in our thread (why identities are needed at all, what's their roles, etc.). Do you think there is some text you could write to explain some of these things and preempt some of the confusion? I would not dare to write such text myself :-)",
          "createdAt": "2020-11-11T04:11:33Z",
          "updatedAt": "2020-11-11T04:11:33Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am ok with these changes, they reflect the conclusions of our discussion.\r\n> I have a feeling that people will wonder about why are pkU, pkS set as default identities and in what cases they should or should not set different values for idU and idS. Answering these question would require iterating some of the issues discussed in our thread (why identities are needed at all, what's their roles, etc.). Do you think there is some text you could write to explain some of these things and preempt some of the confusion? I would not dare to write such text myself :-)\r\n\r\n@hugokraw Please take a look at the text that I have added to the \"Security Considerations\" section, also copied below:\r\n\r\n```\r\n## User and server identities\r\n\r\nThe user identity (idU) and server identity (idS) are optional parameters\r\nwhich are left to the application to designate as monikers for the client\r\nand server. If the application layer does not supply values for these\r\nparameters, then they will be omitted from the creation of the envelope\r\nduring the registration stage. Furthermore, they will be substituted with\r\nidU = pkU and idS = pkS during the authenticated key exchange stage.\r\n\r\nThe advantage to supplying a custom idU and idS (instead of simply relying\r\non a fallback to pkU and pkS) is that the client can then ensure that any\r\nmappings between idU and pkU (and idS and pkS) are protected by the\r\nauthentication from the envelope. Then, the client can attempt to verify\r\nthat the idU and idS contained in its envelope matches the idU and idS\r\nsupplied by the server.\r\n\r\nHowever, if this extra layer of verification is unnecessary for the\r\napplication, then simply leaving idU and idS unspecified is acceptable.\r\n```\r\n---\r\n\r\nLet me know if you think we should edit this.",
          "createdAt": "2020-11-12T22:17:38Z",
          "updatedAt": "2020-11-12T22:17:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I like it. Two edits:\r\n- remove \"attempt to\"\r\n- edit last sentence to: then simply leaving idU and idS unspecified, and using pkU and pkS instead, is acceptable.",
          "createdAt": "2020-11-12T22:58:28Z",
          "updatedAt": "2020-11-12T22:58:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Done. Thanks!",
          "createdAt": "2020-11-12T23:13:24Z",
          "updatedAt": "2020-11-12T23:13:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjkzNDc3",
          "commit": {
            "abbreviatedOid": "65b3353"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This matches my understanding. @hugokraw, can you please have a look?",
          "createdAt": "2020-11-10T23:36:27Z",
          "updatedAt": "2020-11-10T23:36:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxOTI3NTQ5",
      "title": "Remove protocol messages.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/86",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #85. \r\n\r\ncc @kevinlewi, @stef",
      "createdAt": "2020-11-16T20:21:12Z",
      "updatedAt": "2021-04-24T15:12:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "deeeead3207280710202773f68edb85c8171704b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-protocol-messages",
      "headRefOid": "dc89d10a1c38b16fba682c0c61a0b7f31203a4a6",
      "closedAt": "2020-11-16T20:31:56Z",
      "mergedAt": "2020-11-16T20:31:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0e1da280c97f4402d4f2fd56d4ef4451b9d46ac1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNzIxMDg5",
          "commit": {
            "abbreviatedOid": "a274e8e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T20:29:37Z",
          "updatedAt": "2020-11-16T20:30:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Perhaps we want to keep this sentence:\r\n\r\n> This section specifies the structure of these protocol\r\nmessages using TLS notation (see {{RFC8446}}, Section 3).\r\n\r\nSince it still applies for the remainder of the document",
              "createdAt": "2020-11-16T20:29:37Z",
              "updatedAt": "2020-11-16T20:31:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4Nzg1NjQ5",
      "title": "Update to some minor details of the current VOPRF draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/92",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @chris-wood ",
      "createdAt": "2020-11-27T20:56:26Z",
      "updatedAt": "2020-12-01T15:40:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0e1da280c97f4402d4f2fd56d4ef4451b9d46ac1",
      "headRepository": "claucece/draft-irtf-cfrg-opaque",
      "headRefName": "master",
      "headRefOid": "19de398f26ef20e44ac7dceb1bb165b9c2013043",
      "closedAt": "2020-12-01T15:40:33Z",
      "mergedAt": "2020-12-01T15:40:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8894db3c031a56873bbd536f7fe3eaf4dc1e4ad6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwOTgyNDMy",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks! I've been meaning to get around to this. I think some things regressed, which I've noted. Otherwise, this is good.",
          "createdAt": "2020-11-30T14:52:49Z",
          "updatedAt": "2020-11-30T15:01:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Can we please revert this? `KeyGen` returns a public and private key pair. It just so happens that OPAQUE ignores the public key for per-user keys. \r\n\r\nAlternatively, we can change `KeyGen` notation in pseudocode below.",
              "createdAt": "2020-11-30T14:52:49Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 38,
              "body": "Why did we remove this clarifying text?",
              "createdAt": "2020-11-30T14:53:21Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 71,
              "body": "Perhaps we should use notation `SerializeScalar`?",
              "createdAt": "2020-11-30T14:55:39Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 149,
              "body": "Please revert this change.",
              "createdAt": "2020-11-30T14:59:12Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 262,
              "body": "This should be reverted. It's the server that looks up envU using idU.",
              "createdAt": "2020-11-30T14:59:52Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMyNDg4",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:43:01Z",
          "updatedAt": "2020-11-30T15:43:02Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'll revert it ;)",
              "createdAt": "2020-11-30T15:43:02Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMzMDI1",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:43:37Z",
          "updatedAt": "2020-11-30T15:43:37Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The data returned from the OPRF functions is always already encoded/serialized, so no need to specify how to encode.",
              "createdAt": "2020-11-30T15:43:37Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMzNDMy",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:44:04Z",
          "updatedAt": "2020-11-30T15:44:04Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Ah, ok. Reverting this.",
              "createdAt": "2020-11-30T15:44:04Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDM0OTI3",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:45:36Z",
          "updatedAt": "2020-11-30T15:45:36Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Except for the scalar that is returned from `blind`.",
              "createdAt": "2020-11-30T15:45:36Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDM1ODI5",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:46:30Z",
          "updatedAt": "2020-11-30T15:46:30Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Agreed ;)",
              "createdAt": "2020-11-30T15:46:30Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDUwMjU2",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T16:00:49Z",
          "updatedAt": "2020-11-30T16:00:50Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Done.",
              "createdAt": "2020-11-30T16:00:49Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgxNzg4",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-01T14:56:02Z",
          "updatedAt": "2020-12-01T14:56:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-12-01T14:56:03Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgyMDQx",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-01T14:56:17Z",
          "updatedAt": "2020-12-01T14:56:17Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-12-01T14:56:17Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgyNTE2",
          "commit": {
            "abbreviatedOid": "19de398"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-01T14:56:42Z",
          "updatedAt": "2020-12-01T14:56:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwMzYyMDYy",
      "title": "Move idU to CreateCredentialResponse parameter.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/93",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The OPAQUE wrapper protocol is responsible for transmitting idU from\r\nclient to server. OPAQUE does not use it for anything other than password\r\nfile lookup.\r\n\r\nCloses #88.\r\n\r\ncc @kevinlewi, @stef",
      "createdAt": "2020-12-01T14:55:31Z",
      "updatedAt": "2021-04-24T15:12:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "8894db3c031a56873bbd536f7fe3eaf4dc1e4ad6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/move-idU-to-parameter",
      "headRefOid": "8d779da370c0ba14e5f35a4539a920a303fb5a8f",
      "closedAt": "2020-12-02T03:15:07Z",
      "mergedAt": "2020-12-02T03:15:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "455538b2043587ea9e455e4f64b111a012dacee7"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good, but I do have a general comment that maybe we can move to discussion in an issue:\r\n\r\nWould it make more sense to perhaps make kU, envU, pkU parameters to CreateCredentialResponse? The reason is because \"LookupUserRecord\" is not actually defined anywhere, and is only run in the wrapper protocol, so it may cause confusion.\r\n\r\n",
          "createdAt": "2020-12-02T02:14:32Z",
          "updatedAt": "2020-12-02T02:14:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would it make more sense to perhaps make kU, envU, pkU parameters to CreateCredentialResponse? The reason is because \"LookupUserRecord\" is not actually defined anywhere, and is only run in the wrapper protocol, so it may cause confusion.\r\n\r\nYeah, I like that suggestion. Stand by while I make the change!",
          "createdAt": "2020-12-02T02:23:00Z",
          "updatedAt": "2020-12-02T02:23:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi fixed!",
          "createdAt": "2020-12-02T02:25:54Z",
          "updatedAt": "2020-12-02T02:25:54Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool, looks! Minor nit: Shouldn't kU, envU, pkU be listed in the Input, not the Parameters (and also following an update to read as: \"CreateCredentialResponse(request)\" -> \"CreateCredentialResponse(request, kU, envU, pkU))",
          "createdAt": "2020-12-02T02:27:03Z",
          "updatedAt": "2020-12-02T02:27:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I opted to keep them as parameters since they're handled by the wrapper protocol and provided by context. Would it be more clear if they were inputs?",
          "createdAt": "2020-12-02T02:58:41Z",
          "updatedAt": "2020-12-02T02:58:41Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "We can leave it to a separate change since it is probably a separate discussion, but I also noted that for \"CreateRegistrationResponse\", pkS is an input instead of a parameter. Not sure if that should change, but it seems like they should both be parameters or both be inputs.\r\n\r\nAnyway, not a big deal either way, at least for now!",
          "createdAt": "2020-12-02T03:01:29Z",
          "updatedAt": "2020-12-02T03:01:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch -- moved to inputs!",
          "createdAt": "2020-12-02T03:08:23Z",
          "updatedAt": "2020-12-02T03:08:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent",
          "createdAt": "2020-12-02T03:14:39Z",
          "updatedAt": "2020-12-02T03:14:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxNDM3MjM4",
      "title": "Remove wrapper RequestMetadata type.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/95",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #94.\r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-12-03T03:55:58Z",
      "updatedAt": "2021-04-24T15:12:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "455538b2043587ea9e455e4f64b111a012dacee7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-metadata-wrapper",
      "headRefOid": "fe4625c9650c5added4c1b4ea1105707886a6c7b",
      "closedAt": "2020-12-03T04:14:20Z",
      "mergedAt": "2020-12-03T04:14:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c4246341b42614facba070e74733cd6391a6bc80"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI0OTA0",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T03:58:22Z",
          "updatedAt": "2020-12-03T03:58:23Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "\"a RequestMetadata structure\" should be replaced with \"an OPRF Scalar value\"",
              "createdAt": "2020-12-03T03:58:23Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI1Mzk1",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T03:59:48Z",
          "updatedAt": "2020-12-03T03:59:48Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Where is SerializedElement defined? Perhaps a reference to an RFC #?",
              "createdAt": "2020-12-03T03:59:48Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI3NDEw",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T04:06:07Z",
          "updatedAt": "2020-12-03T04:06:07Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Missed this one -- thanks!",
              "createdAt": "2020-12-03T04:06:07Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI3ODIy",
          "commit": {
            "abbreviatedOid": "fe4625c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T04:07:25Z",
          "updatedAt": "2020-12-03T04:07:26Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I clarified that this is an alias for a serialized group element, i.e., output of `Serialize()`.",
              "createdAt": "2020-12-03T04:07:26Z",
              "updatedAt": "2020-12-03T04:07:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI5Mzkz",
          "commit": {
            "abbreviatedOid": "fe4625c"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2020-12-03T04:12:18Z",
          "updatedAt": "2020-12-03T04:12:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxNTUyNzM1",
      "title": "Reference \"Partitioning Oracle Attacks\" paper.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/101",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #100.\r\n\r\ncc @hugokraw, @stef",
      "createdAt": "2020-12-17T02:10:12Z",
      "updatedAt": "2021-04-24T15:12:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "c4246341b42614facba070e74733cd6391a6bc80",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ref-partition-oracles",
      "headRefOid": "baa0242e64db498dbdea171d3de227a39cdf9486",
      "closedAt": "2020-12-21T16:42:15Z",
      "mergedAt": "2020-12-21T16:42:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d7cb97511bbfa2a55c29b44600be11d0cb5ae3cc"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In this case we would say that while the paper requires it, this specification does not (in particular, partition attacks as those described in the Julia et al paper are irrelevant to this specification).\r\n\r\nSo, to be clear, would you just drop the reference from this PR? If so, we lose a pointer to the RKR definition, which I was hoping to outsource to somewhere else. ",
          "createdAt": "2020-12-19T15:28:32Z",
          "updatedAt": "2020-12-19T15:28:32Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the following text in the security considerations addresses this issue.\r\n\r\nWe note that the analysis of OPAQUE from {{OPAQUE}} requires the authenticated encryption scheme used to produce envU to have a special property called random key-robustness (or key-committing). This specification enforces this property by utilizing encryption-then-hmac in the construction of envU. There is no option to use another authenticated-encryption scheme with this specification.  (Deviating from the key-robustness requirement may open the protocol to attacks, e.g., {{Len}}.) We remark that export_key for authentication and/or encryption requires no special properties from the authentication/encryption schemes as long as exporter_key is used only after the EnvU is validated (i.e., after the HMAC in RecoverCredentials passes verification).",
          "createdAt": "2020-12-20T22:09:31Z",
          "updatedAt": "2020-12-20T22:09:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's much better. I'll update this PR with that suggestion and then close out this issue. ",
          "createdAt": "2020-12-21T16:34:27Z",
          "updatedAt": "2020-12-21T16:34:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzA4MTgx",
          "commit": {
            "abbreviatedOid": "03b08db"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Wait with this reference. Not sure if we need to touch on this point at all as there is no key robustness requirement for this specification. At most, it could be discussed in the security considerations just because the OPAQUE paper requires it. In this case we would say that while the paper requires it, this specification does not (in particular, partition attacks as those described in the Julia et al paper are irrelevant to this specification).  ",
          "createdAt": "2020-12-17T06:21:27Z",
          "updatedAt": "2020-12-17T06:21:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQyNDc4ODY3",
      "title": "Changing envelope definition to  support two fixed modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/102",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #99.\r\n\r\nThis defines two modes, `base` and `customIdentifier` for the envelope. The credentials are incorporated in the `SecretCredentials` and `CleartextCredentials` structs,\r\ndepending on the mode set by the value of `EnvelopeMode`:\r\n\r\n```\r\nenum {\r\n  base(1),\r\n  customIdentifier(2),\r\n  (255)\r\n} EnvelopeMode;\r\n```\r\n\r\nThe `base` mode defines `SecretCredentials` and `CleartextCredentials` as follows:\r\n\r\n```\r\nstruct {\r\n  opaque skU<1..2^16-1>;\r\n} SecretCredentials;\r\n\r\nstruct {\r\n  opaque pkS<1..2^16-1>;\r\n} CleartextCredentials;\r\n```\r\n\r\nThe `customIdentifier` mode defines `SecretCredentials` and `CleartextCredentials` as follows:\r\n\r\n```\r\nstruct {\r\n  opaque skU<1..2^16-1>;\r\n} SecretCredentials;\r\n\r\nstruct {\r\n  opaque pkS<1..2^16-1>;\r\n  opaque idU<0..2^16-1>;\r\n  opaque idS<0..2^16-1>;\r\n} CleartextCredentials;\r\n```\r\n\r\nThese credentials are embedded into the following `Envelope` structure with\r\nencryption and authentication.\r\n\r\n```\r\nstruct {\r\n  InnerEnvelopeMode mode;\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n} InnerEnvelope;\r\n\r\nstruct {\r\n  InnerEnvelope contents;\r\n  opaque auth_tag[Nh];\r\n} Envelope;\r\n```\r\n\r\nAlso updated the `FinalizeRequest` and `RecoverCredentials` procedures accordingly. Also updated the fixed string to read `OPAQUE01` instead of `OPAQUE00`.",
      "createdAt": "2020-12-18T11:16:37Z",
      "updatedAt": "2021-01-04T19:27:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "af3cd96b76fd8aaa1bf83f290f7714973ab8e64b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "dual_mode_envelope",
      "headRefOid": "56a30f30e70f824e4ad9ad42497126c6103a14bd",
      "closedAt": "2021-01-04T19:27:56Z",
      "mergedAt": "2021-01-04T19:27:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0e39200d483f37d5b1be63a5fecc0b94017ccc96"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "* I added a note in the configurations section: \"The EnvelopeMode value is defined in {{data-types}} and must also be agreed upon between the client and server.\"\r\n* Thanks, good catch. Removed!\r\n* The expectation is that idS should come from the wrapper protocol. I think it is unnecessary to include idS in `RegistrationResponse`, regardless of the mode. Therefore, I think it is unnecessary to change anything here regarding this point. What do you think?",
          "createdAt": "2020-12-21T04:04:24Z",
          "updatedAt": "2020-12-21T04:04:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The expectation is that idS should come from the wrapper protocol. I think it is unnecessary to include idS in RegistrationResponse, regardless of the mode. Therefore, I think it is unnecessary to change anything here regarding this point. What do you think?\r\n\r\nI think that's fine, but I would make things more explicit. If the wrapper protocol provides them, then it might as well also supply them to the relevant procedures for constructing the envelope. Then we could replace this:\r\n\r\n\"Create cleartext_credentials with credentials matching those needed to construct the `CleartextCredentials` structure\"\r\n\r\nwith something like:\r\n\r\n\"Create `CleartextCredentials` structure cleartext_credentials where cleartext_credentials.idU = idU, cleartext_credentials.idS = idS, cleartext_credentials.pkS = pkS.\"",
          "createdAt": "2020-12-21T15:27:39Z",
          "updatedAt": "2020-12-21T15:27:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Following up on the comment above, we might simplify things by delegating the \"credential construction\" logic to the wrapper protocol, which (a) knows the mode and (b) has the relevant information (skU, idU, pkS, idS, etc). That would make the interface to `FinalizeRequest` something like so:\r\n\r\n```\r\nFinalizeRequest(pwdU, creds, blind, response)\r\n```\r\n\r\nWhere `creds` contains the `secret_credentials` and `cleartext_credentials`, already in wire format form, to use when creating the envelope. ",
          "createdAt": "2020-12-22T19:01:10Z",
          "updatedAt": "2020-12-22T19:01:10Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed comments, ready for a re-review",
          "createdAt": "2020-12-25T03:20:56Z",
          "updatedAt": "2020-12-25T03:20:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDI3MTA3",
          "commit": {
            "abbreviatedOid": "b627ad5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like this :) I have a couple questions that I hope we can resolve moving forward:\r\n\r\n- The mode is currently implicit in registration and login. I assume the expectation is that configurations specify the mode so that it's known to both peers. We should probably say that somewhere. I left a suggestion to include this note, but we probably ought to expand upon it in the configuration section.\r\n- The `RegistrationResponse` definition still includes a list of secret and cleartext credential types. This can be removed given that these are dependent on the mode. \r\n- Credential construction is somewhat vague in the current description, especially since idU and idS are not passed as parameters to the main registration and login routines. As an implementor, is the expectation that idS comes from the client's wrapper protocol, or is it sent from server to client as part of the registration response? (My understanding is the latter.) Since there are only two modes, we might, for example, define two mode-specific `FinalizeRequest` variants, each of which takes the appropriate parameters. (The base mode variant includes what is currently there now, whereas the custom-mode variant might also include idU (and idS depending on the answer to the previous question).)\r\n\r\nObviously, we can work on these things incrementally and merge in pieces, but I wanted to flag these questions to start.",
          "createdAt": "2020-12-20T15:24:41Z",
          "updatedAt": "2020-12-20T15:44:19Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\ncovering `InnerEnvelope` and `CleartextCredentials`.\r\n```",
              "createdAt": "2020-12-20T15:24:42Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            },
            {
              "originalPosition": 278,
              "body": "```suggestion\r\nthen these values (independently) default to pkU and pkS instead.\r\n```",
              "createdAt": "2020-12-20T15:32:58Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n`SecretCredentials` and `CleartextCredentials` is described in {{finalize-request}}.\r\n\r\nThe `EnvelopeMode` value is specified as part of a configuration. \r\n```",
              "createdAt": "2020-12-20T15:33:13Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDYxNDAz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-21T15:27:26Z",
          "updatedAt": "2020-12-21T15:27:27Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "This implies (to me) some sort of negotiation. Since the EnvelopeMode is already in the tuple above, I'd drop that bit:\r\n\r\n```suggestion\r\nThe EnvelopeMode value is defined in {{data-types}}.\r\n```",
              "createdAt": "2020-12-21T15:27:26Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MjgzNzUz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T18:31:25Z",
          "updatedAt": "2020-12-22T18:31:26Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Unrelated: should we lift `pkU` to the wrapper protocol, too? Specifically, perhaps `FinalizeRequest` should produce an envelope and export key, and the wrapper protocol is then responsible for sending the envelope and `pkU` to the server.",
              "createdAt": "2020-12-22T18:31:26Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mjk4ODcw",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T18:59:13Z",
          "updatedAt": "2020-12-22T18:59:14Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Also unrelated, but we can remove `request` here, as it's not used.",
              "createdAt": "2020-12-22T18:59:13Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NzkzODUz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T10:53:23Z",
          "updatedAt": "2020-12-23T10:53:24Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "If SecretCredentials is always equal to the client secret, wouldn't it be more straightforward to put `pt = Serialize(secret)` ?",
              "createdAt": "2020-12-23T10:53:24Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Nzk1Mjg1",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T10:56:19Z",
          "updatedAt": "2020-12-23T10:56:19Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "If I'm not mistaken, the InnerEnvelope should also specify the InnerEnvelopeMode, doesn't it?",
              "createdAt": "2020-12-23T10:56:19Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4MjI2NTU0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T21:00:06Z",
          "updatedAt": "2020-12-23T21:00:06Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "It is used in line 468:\r\n\r\n```\r\nThe full procedure for constructing `Envelope` and `InnerEnvelope` from\r\n`SecretCredentials` and `CleartextCredentials` is described in {{finalize-request}}.\r\n```",
              "createdAt": "2020-12-23T21:00:06Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQzODc0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:13:01Z",
          "updatedAt": "2020-12-25T03:13:01Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "As discussed offline, let's address this API change separately.",
              "createdAt": "2020-12-25T03:13:01Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQ0Mzc2",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:17:17Z",
          "updatedAt": "2020-12-25T03:17:18Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I think it may be beneficial to keep this level of generality here in case we add support for other modes that set SecretCredentials to something else in the future. This will hopefully also coincide with the changes that will be made in #105 which will pass in a generic credentials parameter.",
              "createdAt": "2020-12-25T03:17:18Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQ0NjY0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:19:54Z",
          "updatedAt": "2020-12-25T03:19:55Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Good catch, thank you! Added to parameters.",
              "createdAt": "2020-12-25T03:19:54Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjgyNTYw",
          "commit": {
            "abbreviatedOid": "56a30f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-04T19:27:17Z",
          "updatedAt": "2021-01-04T19:27:17Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I'll address this in a separate PR, since it seems related to the module boundary we discussed.",
              "createdAt": "2021-01-04T19:27:17Z",
              "updatedAt": "2021-01-04T19:27:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjgyODg5",
          "commit": {
            "abbreviatedOid": "56a30f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T19:27:46Z",
          "updatedAt": "2021-01-04T19:27:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4NTcyMTAw",
      "title": "Separate the core and wrapper protocol",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/106",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Lift wrapper-specific pieces, such as credential information and key material, out of the core protocol, where they are not used. Update the reference implementation to match.\r\n\r\nI might ignore the reference implementation for the time being, since it's kind of sloppy. But if you wanted to check it for consistency against the core module API boundary, that would be useful. \r\n\r\nCloses #105.",
      "createdAt": "2021-01-05T01:24:29Z",
      "updatedAt": "2021-04-24T15:12:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0e39200d483f37d5b1be63a5fecc0b94017ccc96",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/core-separation",
      "headRefOid": "f4bb5b809a7a1786091f07e346c293d19319640d",
      "closedAt": "2021-01-06T21:48:01Z",
      "mergedAt": "2021-01-06T21:48:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "758c8a0314775f16f3c02c7741bf282de321f0cb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjg2NzY5",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T02:37:17Z",
          "updatedAt": "2021-01-06T02:48:55Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Why doesn't the client just send an instance of the `RegistrationUpload` function, which includes `pkU` and `envU`? It doesn't need to send `idU` since that is taken care of in the application layer and not necessary for the OPAQUE protocol",
              "createdAt": "2021-01-06T02:37:17Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            },
            {
              "originalPosition": 35,
              "body": "I think this should be an instance of the `RegistrationUpload` structure, not `envU`",
              "createdAt": "2021-01-06T02:37:40Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            },
            {
              "originalPosition": 200,
              "body": "Line 806 should output an instance of `Credentials`, then, right? (Currently it outputs a secret_credentials)",
              "createdAt": "2021-01-06T02:46:13Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            },
            {
              "originalPosition": 12,
              "body": "I believe this will be the only instance of a struct that we define in this document which never gets serialized. Why not just replace all instances with a tuple of (mode, secret_credentials, cleartext_credentials)? And note that the RecoverCredentials function doesn't actually need to return the cleartext_credentials or the mode...",
              "createdAt": "2021-01-06T02:48:19Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjkxOTI2",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T02:55:02Z",
          "updatedAt": "2021-01-06T02:55:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "You could, yeah. This is just a helper type to wrap up everything in that tuple. ",
              "createdAt": "2021-01-06T02:55:02Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjkyMTc0",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T02:55:49Z",
          "updatedAt": "2021-01-06T02:55:50Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "Hmm, it is nice if it just returns a `Credentials` type. I'll make the change!",
              "createdAt": "2021-01-06T02:55:49Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMzAyNjA5",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T03:26:19Z",
          "updatedAt": "2021-01-06T03:26:20Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I intentionally reverted this so that the wrapper could construct `RegistrationUpload`, but on reflection that's probably not best. I'll revert this bit.",
              "createdAt": "2021-01-06T03:26:20Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyNDM5MDAy",
          "commit": {
            "abbreviatedOid": "83a1fb0"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry, I think I missed this with my first pass, but pkS needs to be a part of CredentialResponse (so I would add back pkS everywhere). Other than that, looks good!",
          "createdAt": "2021-01-06T09:21:46Z",
          "updatedAt": "2021-01-06T09:23:38Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "pkS should not be removed -- see my last comment on #63 . The problem is that the pkS is no longer included in the envelope.",
              "createdAt": "2021-01-06T09:21:46Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDE5MTQy",
          "commit": {
            "abbreviatedOid": "f4bb5b8"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2021-01-06T20:31:54Z",
          "updatedAt": "2021-01-06T20:31:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 107,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUwNjk2NDQ0",
      "title": "Pin envelope mode to base or customIdentifier.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/107",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I chose to leave the enumeration and restrict its values to in the text. \r\n\r\nAs discussed, this also makes pkU/pkS mandatory in the core OPAQUE messages.",
      "createdAt": "2021-01-06T22:03:34Z",
      "updatedAt": "2021-04-24T15:12:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "758c8a0314775f16f3c02c7741bf282de321f0cb",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/pin-modes",
      "headRefOid": "db59aa3ac9999cd2f3c340886d522c30e7749942",
      "closedAt": "2021-01-08T03:25:18Z",
      "mergedAt": "2021-01-08T03:25:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dca52275f12704ef4b90aa8bbd48331007ffb9c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzODkzNDI5",
          "commit": {
            "abbreviatedOid": "db59aa3"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great!",
          "createdAt": "2021-01-07T23:05:56Z",
          "updatedAt": "2021-01-07T23:05:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 110,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUyMDUyOTkw",
      "title": "Remove a dead link and in the \"User enumeration\" section, update variable names.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/110",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-09T04:29:53Z",
      "updatedAt": "2021-01-13T02:34:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dca52275f12704ef4b90aa8bbd48331007ffb9c5",
      "headRepository": null,
      "headRefName": "dead-link-and-variable-names",
      "headRefOid": "90d5a7a734734de2bf13ad2ea6880c00afa3a6c8",
      "closedAt": "2021-01-11T15:06:53Z",
      "mergedAt": "2021-01-11T15:06:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "268ec3d685b1d57091ba40eb3bdfce1507e09cfc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NDMyNTMx",
          "commit": {
            "abbreviatedOid": "8c55239"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-11T14:58:51Z",
          "updatedAt": "2021-01-11T15:03:50Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nsimulating a CredentialResponse for non-existing users.\r\n```",
              "createdAt": "2021-01-11T14:58:51Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nNote that if the same CredentialRequest is received\r\n```",
              "createdAt": "2021-01-11T14:59:55Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nthe construction of envU to all the key material in envU.\r\n```",
              "createdAt": "2021-01-11T15:00:53Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-01-11T15:01:00Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nUpon receiving a CredentialRequest for a non-existing\r\n```",
              "createdAt": "2021-01-11T15:01:18Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nCredentialResponse carrying Z=M^kU and envU, where the latter is computed as follows.\r\nrwdU is set to kU' and secret_creds is set to the all-zero string (of the\r\n```",
              "createdAt": "2021-01-11T15:03:07Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nAn attacker that attempts authentication with the same CredentialRequest twice and receives\r\n```",
              "createdAt": "2021-01-11T15:03:46Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NDM4NzE2",
          "commit": {
            "abbreviatedOid": "e249729"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T15:05:13Z",
          "updatedAt": "2021-01-11T15:05:13Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nAn attacker that attempts authentication with the same CredentialRequest twice and receives\r\n```",
              "createdAt": "2021-01-11T15:05:13Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 113,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzOTk2MDgz",
      "title": "Make process diagrams match function definitions. ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/113",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There were some inconsistencies in the process diagrams and function definitions.\r\n\r\n-----\r\n\r\nFor example, before this change, the output of CreateCredentialRequest in the process diagram\r\n```\r\nrequest, blind = CreateCredentialRequest(pwdU)\r\n```\r\ndid not match the output of CreateCredentialRequest's function definition:\r\n```\r\nOutput:\r\n- request, an CredentialRequest structure\r\n- r, an OPRF Scalar value\r\n```\r\n`r` should be `blind`, which FinalizeRequest takes as input.\r\n\r\n-----\r\n\r\nIn another example, the output of FinalizeRequest in the process diagram\r\n```\r\nrecord, export_key = FinalizeRequest(pwdU, creds, blind, response)\r\n```\r\ndid not match the output of FinalizeRequest's function definition:\r\n```\r\nOutput:\r\n- envU, the user's Envelope structure\r\n- export_key, an additional key\r\n```",
      "createdAt": "2021-01-13T07:55:47Z",
      "updatedAt": "2021-01-13T14:30:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "268ec3d685b1d57091ba40eb3bdfce1507e09cfc",
      "headRepository": null,
      "headRefName": "consistency",
      "headRefOid": "4c97670a8968ba26a75ebed49841b09fd9c6b7cf",
      "closedAt": "2021-01-13T14:12:27Z",
      "mergedAt": "2021-01-13T14:12:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5956b66d1b851ef76b79219d7463851e2c74b1c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MjU4MDgx",
          "commit": {
            "abbreviatedOid": "4c97670"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-13T14:12:22Z",
          "updatedAt": "2021-01-13T14:12:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU0MzI2NDU4",
      "title": "Adding serialization format for credential file",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/114",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Defines the serialization for the \"credential file\" (the object that is stored server-side and acts as the user's password file).\r\n\r\nCloses #89.",
      "createdAt": "2021-01-13T16:54:31Z",
      "updatedAt": "2021-01-14T16:08:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5956b66d1b851ef76b79219d7463851e2c74b1c4",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "credential_file",
      "headRefOid": "87a13127aa3cf0e0ea1d23a9640f06eb18d925fb",
      "closedAt": "2021-01-13T22:39:41Z",
      "mergedAt": "2021-01-13T22:39:41Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "7fc5de0c5625665e18e017bb9eddd35090a19f31"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should leave it up to a wrapper implementation to add a version around the bytes of the `CredentialFile`, no?",
          "createdAt": "2021-01-13T20:56:38Z",
          "updatedAt": "2021-01-13T20:56:38Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments addressed -- ready to merge",
          "createdAt": "2021-01-13T22:22:43Z",
          "updatedAt": "2021-01-13T22:22:43Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I have a specific question here, but may I share my thoughts on the subject?\r\n\r\nI have been playing with different ideas on my side, and found that due to the different variable parameters at play it is a quite complex subject to optimize.\r\n\r\n- **Envelope Mode**\r\nIf the envelope is serialized and opaque, the server still needs a way to know the EnvelopeMode to communicate the correct \"Credentials\" structure to the client.\r\n\r\n- **OPRF key**\r\nAs @chris-wood pointed out, the encoding of an OPRF key is tied to the suite and is not encoded into the key itself. Hence, the most straightforward thing to do is to have another field specifying the suite the key belongs to. It's a single byte, and can't hurt that much, I believe.\r\nIf one wants to separate kU from the envelope and store it elsewhere, keys belonging to the same group could be stored in the same table. Thus, the user record only references the kU in another table and doesn't care about the suite.\r\n\r\n- **AKE keys**\r\nGiven a complex environment with different conditions that open the possibility that different AKEs are used, the user record might need to keep track of that as well. Either a reference to the key pair and their type (group and AKE) or stored in a \"table\" dedicated to that key pair.\r\n\r\n- **MHF Params**\r\nThe key derivation functions have different impacts on different platforms and may impact the user experience if the login takes too long due to unsuited parameters. From what I understand, this hasn't been thoroughly discussed, yet (and rightfully so). But if different configurations were to be used for different clients, they have to be saved with the user record.\r\n\r\n\r\nA \"naive\" version of my implementation sees the complete information tied to a user record grow quite rapidly:\r\n```\r\nUserRecord {\r\n    HumanUserID  // Human-memorizable, modifiable user identifier\r\n    UUID               // Unique long-term user identifier, or idu\r\n    UserPublicKey\r\n    EnvelopeMode \r\n    Envelope     \r\n    ServerID     \r\n    OprfSecret   \r\n    ServerAkeID  \r\n    Parameters {\r\n        Ciphersuite\r\n        Hash\r\n        AKE\r\n        MHFParams {\r\n            AlgoID\r\n            time, memory, threads\r\n            KeyLength\r\n        }\r\n    }\r\n}\r\n\r\nServerAke {\r\n    ID             // unique ID for this key pair\r\n    Ake          // the AKE protocol they are used in\r\n    Group    \r\n    Hash     \r\n    SecretKey\r\n    PublicKey\r\n}\r\n```",
          "createdAt": "2021-01-13T23:28:01Z",
          "updatedAt": "2021-01-13T23:28:01Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'm not sure this is a good idea, different use-cases might not need all the bells and whistles. i think i asked in an issue if this is about the standardization of the protocol or it goes beyond that and standardizes also serialization of all kind of wire and storage elements. in implementations using only one instantiation of the protocol the parameters are fixed, and don't need to be stored. if an implementation does not follow the spec and does not store this redundant info in that case, will it still be standards compliant? also some implementations might want to go beyond the currently specified two envelope setups and may want to make all credential extensions configurable, i can see reasons for all configurations. i think there should be a limit of what is part of the standard, and what is free for implementations to decide themselves, and again depending on different configurations of how credential extensions are created this can lead to very different storage formats. my take is to not specify neither the storage format of the record, nor actually the configuration of the envelope. test vectors can still be provided for the protocol, especially if serialization is not fixed, in that case the test vectors can be provided as results of the various steps of the protocol, there is no combinatoric explosion.",
          "createdAt": "2021-01-14T01:53:47Z",
          "updatedAt": "2021-01-14T01:53:47Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "to quote Antoine de Saint-Exupery:\r\n> Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away .",
          "createdAt": "2021-01-14T02:00:28Z",
          "updatedAt": "2021-01-14T02:00:28Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "imagine an implementation that stores (parts of) the record in a smartcard, a cortex m[034], a cars ECU, or a yubikey. an implementation that has one pkS and one that has separate pkS for each user. it makes sense to have different implementations to be interoperable with each other on the protocol level, a client and a server running different implementations. but the records, do not need to be specified.",
          "createdAt": "2021-01-14T12:31:58Z",
          "updatedAt": "2021-01-14T12:31:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The standard needs to specify ways to interpret envelopes for the sake of security and interoperability. (What's included in the envelope is critical to the overall security of OPAQUE.) \r\n\r\nThe `mode` parameter was introduced precisely to allow the sort of extensibility you're after. For example, if neither of the envelope formats work for your use case, you may pick a new mode and its corresponding envelope structure. The existing modes were chosen because we believe they represent the minimal information needed for most applications.\r\n\r\nRegarding the CredentialFile format, this change describes the structure and format of what minimally needs to be *associated* with a given user's record. It does not mandate how server implementations store this information. ",
          "createdAt": "2021-01-14T13:41:38Z",
          "updatedAt": "2021-01-14T13:41:38Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello Stefan,\r\n\r\nmy point wasn't to say \"hey, this is how I think we should do it, let's put everything in there to have a perfect thingy\" :)\r\nAs I said, this is the naive structure for my proof-of-concept, and, believe me, I don't want to keep it like this.\r\n\r\nI'm aligned with you, and I think we all agree. I believe that there is a _sweet spot_ that OPAQUE is reaching, a balance between the core necessities and minimize implementation pitfalls that might introduce vulnerabilities in the usage of OPAQUE.",
          "createdAt": "2021-01-14T13:47:18Z",
          "updatedAt": "2021-01-14T13:47:43Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The standard needs to specify ways to interpret envelopes for the sake of security and interoperability. (What's included in the envelope is critical to the overall security of OPAQUE.)\r\n\r\nagreed. security and interop are the goals of an opaque standard.\r\n\r\n> The `mode` parameter was introduced precisely to allow the sort of extensibility you're after.\r\n> For example, if neither of the envelope formats work for your use case, you may pick a new mode and its corresponding envelope structure. \r\n\r\noh? i guess i missed the part where it says that this is an optional extensible parameter, and not necessary to be conformant with the spec. i guess i suffer from patch reading fatigue trying to keep up with all the changes, sorry for that.\r\n\r\n> The existing modes were chosen because we believe they represent the minimal information needed for most applications.\r\n\r\nis there any documentation on how this belief was established? for example why not chose the minimal envelope, with 0 credentialextensions as a base mode isn't that the minimal information already needed for most applications?\r\n \r\n> Regarding the CredentialFile format, this change describes the structure and format of what minimally needs to be _associated_ with a given user's record. It does not mandate how server implementations store this information.\r\n\r\nmaybe calling it a file is misguiding then, perhaps it might make sense to change it to something like:\r\nThe following values need to be stored by the server indexed by the idU: kU, envU, pkU.\r\ni do disagree with the part: \r\n\r\n> describes the structure and format\r\n\r\nwhat if i want to store kU in a secure element, or sgx (trying not to laugh hard...) while the rest can be stored outside of it? or alternatively, if there is cleartext elements in the envelope that can be deduped in some way, why store them in the envelope, pkS and idS are some simple candidates to have not stored in the envU, but only reassembled before sending of the CreateCredentialResponse response.",
          "createdAt": "2021-01-14T14:38:54Z",
          "updatedAt": "2021-01-14T14:39:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> is there any documentation on how this belief was established? for example why not chose the minimal envelope, with 0 credentialextensions as a base mode isn't that the minimal information already needed for most applications?\r\n\r\nThere are no more extensions, so I think this is already addressed :) Please have a look at the latest version of the draft here. (Sorry, many things are changing, and I understand it's hard to follow!)\r\n\r\n> maybe calling it a file is misguiding then, perhaps it might make sense to change it to something like:\r\n\r\nWe have a structure for applications which do not want to store things in some special way, i.e., they want to write the \"file\" as presented directly to storage.\r\n\r\n> what if i want to store kU in a secure element, or sgx (trying not to laugh hard...) while the rest can be stored outside of it? or alternatively, if there is cleartext elements in the envelope that can be deduped in some way, why store them in the envelope, pkS and idS are some simple candidates to have not stored in the envU, but only reassembled before sending of the CreateCredentialResponse response.\r\n\r\nAs above, the file format *does not* preclude implementation- or application-specific storage for these things. I recommend having a look at the latest version of the spec to see how things are described. \r\n\r\nAlternatively, if it would help, I'd be happy to hop on a call to discuss these issues in more depth. :-) ",
          "createdAt": "2021-01-14T16:08:08Z",
          "updatedAt": "2021-01-14T16:08:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NTA5OTgw",
          "commit": {
            "abbreviatedOid": "4008fe1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Since `CredentialFile` is meant to be opaque storage handled by OPAQUE, I think everything in the envelope ought to be serialized. Since the serialized format of a `Scalar` depends on the OPRF group, this does assume that the OPAQUE configuration (and OPRF suite) is known. What prevents a `CredentialFile` from one configuration being used in another configuration? ",
          "createdAt": "2021-01-13T18:34:04Z",
          "updatedAt": "2021-01-13T18:39:29Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n    SerializedScalar kU;\r\n```",
              "createdAt": "2021-01-13T18:34:04Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            },
            {
              "originalPosition": 42,
              "body": "I assume we want this to be serialized for storage, right?",
              "createdAt": "2021-01-13T18:34:28Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            },
            {
              "originalPosition": 79,
              "body": "Assuming you take the suggestion above, I'd then deserialize `kU` before use.",
              "createdAt": "2021-01-13T18:34:50Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NjIwMjYx",
          "commit": {
            "abbreviatedOid": "4008fe1"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-13T20:55:58Z",
          "updatedAt": "2021-01-13T20:55:59Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I could not find \"SerializedScalar\" in the VOPRF doc. Is there a definition for this somewhere?\r\n\r\nEdit: After discussion, found it :) ",
              "createdAt": "2021-01-13T20:55:58Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU0NjMxMTE0",
      "title": "Make the online-phase process diagram match function definitions.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/115",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "87a13127aa3cf0e0ea1d23a9640f06eb18d925fb changed the signature of\r\n`CreateCredentialResponse`.\r\n\r\nI also improved upon @kevinlewi's update.\r\n\r\nI took the definitions of the OPRF functions and types from\r\nhttps://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html .\r\nI modified them some. Here is the original text for reference:\r\n- SerializedElement and SerializedScalar are serialized representations of\r\n  Element and Scalar types of length Ne and Ns, respectively\r\n- SerializeElement(A): A member function of GG that maps a group element A to\r\n  a unique byte array buf of fixed length Ne.\r\n- DeserializeElement(buf): A member\r\n  function of GG that maps a byte array buf to a group element A, or fails if\r\n  the input is not a valid byte representation of an element.\r\n\r\nI removed the references to `SerializeElement` and `DeserializeElement` since\r\nthey were not referenced anywhere in the draft.\r\n\r\nThere was also no mention of `SerializeScalar`. I added\r\n\"`kU` is serialized using `SerializeScalar`\" to make its usage explicit.\r\n\r\nI changed `CredentialRequest` and `CredentialResponse` to use\r\n`SerializedElement` to match `RegistrationRequest` and `RegistrationResponse`.\r\n\r\nIn `RegistrationUpload` I moved `Envelope` to the end of the struct to be\r\nconsistent with the `Envelope`'s position in other structs:\r\n```\r\nstruct {\r\n    SerializedScalar kU;\r\n    opaque pkU<1..2^16-1>;\r\n    Envelope envU;\r\n} CredentialFile;\r\n\r\nstruct {\r\n    SerializedElement data;\r\n    opaque pkS<1..2^16-1>;\r\n    Envelope envU;\r\n} CredentialResponse;\r\n```\r\nAlso, `Envelope` is of variable length.",
      "createdAt": "2021-01-14T04:17:43Z",
      "updatedAt": "2021-01-14T14:07:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7fc5de0c5625665e18e017bb9eddd35090a19f31",
      "headRepository": null,
      "headRefName": "consistency",
      "headRefOid": "ceadc91bdaa0fc296c748e571a05c2c7014578aa",
      "closedAt": "2021-01-14T13:48:39Z",
      "mergedAt": "2021-01-14T13:48:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "788a5a3817eddd0052c9576cf27a8f3970530058"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MjQ3MjU3",
          "commit": {
            "abbreviatedOid": "ceadc91"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-14T13:48:35Z",
          "updatedAt": "2021-01-14T13:48:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1MzI1NTA2",
      "title": "Update headings and hyphenation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/116",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I also tackled two suggestions in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112.",
      "createdAt": "2021-01-15T01:22:48Z",
      "updatedAt": "2021-01-15T01:57:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "788a5a3817eddd0052c9576cf27a8f3970530058",
      "headRepository": null,
      "headRefName": "consistency",
      "headRefOid": "a0cce2da3aafc5392f422738a84fef8e4781964c",
      "closedAt": "2021-01-15T01:52:54Z",
      "mergedAt": "2021-01-15T01:52:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7539e8665bae01e8c96f79b8f378f56dcbb8bab7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NzYyNjUw",
          "commit": {
            "abbreviatedOid": "064c1dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T01:52:28Z",
          "updatedAt": "2021-01-15T01:52:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n(PKI-free) aPAKE protocols, none of these protocols are secure against\r\n```",
              "createdAt": "2021-01-15T01:52:29Z",
              "updatedAt": "2021-01-15T01:52:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NzYyNzQ1",
          "commit": {
            "abbreviatedOid": "064c1dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2021-01-15T01:52:47Z",
          "updatedAt": "2021-01-15T01:52:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 117,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1MzQxMzE4",
      "title": "Surround multiple output params with parentheses in process diagrams.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/117",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the steps for functions, we surround multiple output params with\r\nparentheses:\r\n```\r\nSteps:\r\n1. (blind, M) = Blind(pwdU)\r\n2. Create RegistrationRequest request with M\r\n3. Output (request, blind)\r\n```\r\n\r\n@crockeea pointed out that we should be consistent. From\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112#issuecomment-760522234,\r\n\"Be consistent about the use of parens for functions which output multiple\r\nvalues (see protocol diagrams at top of section 3.2 and at the top of 3.3)\".",
      "createdAt": "2021-01-15T02:19:51Z",
      "updatedAt": "2021-01-30T17:26:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7539e8665bae01e8c96f79b8f378f56dcbb8bab7",
      "headRepository": null,
      "headRefName": "consistency",
      "headRefOid": "4bcdd6bbe5f0100adcfba25d0308fe2a755513af",
      "closedAt": "2021-01-22T23:51:39Z",
      "mergedAt": "2021-01-22T23:51:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ac3192db44619e394344a4bff648711ffd827c4b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0Njk5NDIw",
          "commit": {
            "abbreviatedOid": "4bcdd6b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-22T23:51:34Z",
          "updatedAt": "2021-01-22T23:51:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYwMjgwOTA4",
      "title": "Minor updates",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/123",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses most small things in @crockeea's review. I'll add the updated protocol descriptions after the structural refactor, @kevinlewi!",
      "createdAt": "2021-01-23T00:28:43Z",
      "updatedAt": "2021-04-24T15:12:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ac3192db44619e394344a4bff648711ffd827c4b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/minor-updates",
      "headRefOid": "35e3fe0418968fb7773bc8cb5c4b3090ad9464b3",
      "closedAt": "2021-01-25T15:54:01Z",
      "mergedAt": "2021-01-25T15:54:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "50b3ce795fe0ec19b74e98dcfcf482992b9bb692"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1MDg5NTY0",
          "commit": {
            "abbreviatedOid": "35e3fe0"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks great!!",
          "createdAt": "2021-01-25T06:14:12Z",
          "updatedAt": "2021-01-25T06:14:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxNzk0MDU4",
      "title": "Structural refactor",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/125",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a pretty invasive change that tries to better organize the document and protocol description into its two steps: registration and authentication. It also includes more wire format details for the 3DH instantiation, and removes HMQV and SIGMA-I in the process. (We can bring them back in a future change as needed.) The outline now looks like so:\r\n\r\n```\r\n   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\r\n     1.1.  Requirements Notation . . . . . . . . . . . . . . . . . .   5\r\n     1.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .   5\r\n   2.  Cryptographic Protocol and Algorithm Dependencies . . . . . .   6\r\n   3.  Offline Registration  . . . . . . . . . . . . . . . . . . . .   7\r\n     3.1.  Credential Storage  . . . . . . . . . . . . . . . . . . .   8\r\n     3.2.  Registration Messages . . . . . . . . . . . . . . . . . .  10\r\n     3.3.  Registration Functions  . . . . . . . . . . . . . . . . .  11\r\n       3.3.1.  CreateRegistrationRequest . . . . . . . . . . . . . .  11\r\n       3.3.2.  CreateRegistrationResponse  . . . . . . . . . . . . .  11\r\n       3.3.3.  FinalizeRequest . . . . . . . . . . . . . . . . . . .  11\r\n       3.3.4.  CredentialFile  . . . . . . . . . . . . . . . . . . .  13\r\n   4.  Online Authenticated Key Exchange . . . . . . . . . . . . . .  13\r\n     4.1.  Credential Retrieval  . . . . . . . . . . . . . . . . . .  13\r\n       4.1.1.  Credential Retrieval Messages . . . . . . . . . . . .  14\r\n       4.1.2.  Credential Retrieval Functions  . . . . . . . . . . .  14\r\n     4.2.  AKE Instantiations  . . . . . . . . . . . . . . . . . . .  16\r\n       4.2.1.  Key Schedule Utility Functions  . . . . . . . . . . .  17\r\n       4.2.2.  OPAQUE-3DH Instantiation  . . . . . . . . . . . . . .  18\r\n       4.2.3.  Alternate AKE instantiations  . . . . . . . . . . . .  20\r\n   5.  Configurations  . . . . . . . . . . . . . . . . . . . . . . .  20\r\n```\r\n\r\ncc @hugokraw, @crockeea",
      "createdAt": "2021-01-26T13:47:50Z",
      "updatedAt": "2021-04-24T15:12:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "50b3ce795fe0ec19b74e98dcfcf482992b9bb692",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/restructure-doc",
      "headRefOid": "db6a82ac6fd5661447ccc3773752ed12fe812dcd",
      "closedAt": "2021-01-30T15:19:17Z",
      "mergedAt": "2021-01-30T15:19:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3451ec3e3e5f6ab3d06247a8d4e7bf1488749c64"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This re-structuring looks good, in particular it needs to correct the impression people had that the AKE part is not an integral (and essential) part of the specification.\r\n\r\nAs for the presentation of HMQV of SIGMA, I want to have a sketch of them in the document as additional examples, especially given how simple it is to do it on the basis of the 3DH description. For HMQV it just means defining the key derivation and for SIGMA it is not much more than that, and it gives a different type of protocol, in particular one that would be used with TLS and IKE.  Since this  is more on the informational side, I would move them to an appendix.\r\n\r\nRegarding the sentence \r\n`any post-quantum (PQ) AKE protocol that has the message flow above`\r\nI am not sure what the \"message flow above\" refers to but we should not prescribe a particular flow. Definitely not a 3-flow KE since KEM-based AKE would most probably not preserve that.",
          "createdAt": "2021-01-26T18:03:30Z",
          "updatedAt": "2021-01-26T18:03:30Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Is there a rendered version of this somewhere?",
          "createdAt": "2021-01-26T20:47:47Z",
          "updatedAt": "2021-01-26T20:47:47Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@crockeea you can find a rendered version at https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/42c6cfc7fe40015d5e9e4956e0bfe76045bdc357/draft-irtf-cfrg-opaque.md\r\n",
          "createdAt": "2021-01-27T22:01:58Z",
          "updatedAt": "2021-01-27T22:01:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjUyODUx",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "crockeea",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:43:55Z",
          "updatedAt": "2021-01-26T18:43:56Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "The data encryption scheme for the envelope encryption is already PQ, and to me, any mention of \"data encryption\" outside the key exchange step is outside the scope of this doc. It's not clear which one you are referring to here, but either way, I would remove the references to data encryption.",
              "createdAt": "2021-01-26T18:43:55Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2ODQ3NjU4",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T23:17:51Z",
          "updatedAt": "2021-01-26T23:17:51Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "How about the following formulation (it refers to 'application data' explicitly to avoid confusion of what data we are talking about):\r\nNote that such an instantiation is not quantum safe unless the OPRF is quantum safe. However, an OPAQUE instantiation where the AKE is quantum safe, but the OPRF is not, would still ensure the confidentiality of application data encrypted under session_key (or a key derived from it) with a quantum-safe encryption function.",
              "createdAt": "2021-01-26T23:17:51Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2ODQ4Nzg2",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T23:20:09Z",
          "updatedAt": "2021-01-26T23:20:10Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "Btw, we never say what one does with session_key. We may not want to add a derivation of traffic keys as in TLS but we should comment that deriving such keys would be the typical use although applications may have other uses. ",
              "createdAt": "2021-01-26T23:20:09Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2ODg3ODg5",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is fantastic! Left some comments but overall this should help to clear things up a bit.\r\n\r\n@crockeea, unfortunately I think you just have to clone the PR and render it locally...\r\n\r\nAnd perhaps we can defer the descriptions of HMQV + SIGMA-I to the Appendix, but also in a later PR since this one already has a bunch of changes.",
          "createdAt": "2021-01-27T00:47:17Z",
          "updatedAt": "2021-01-27T00:59:49Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Nit: Perhaps at this point, we should clarify that a bunch of the variables depicted above will be clarified later? Or maybe we can reference a description to them somewhere. After reading this, I become immediately confused... but maybe it is just me :) ",
              "createdAt": "2021-01-27T00:47:17Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 72,
              "body": "Nit: \"the S stores U's credentials\" -> \"S stores U's credentials\" / \"the server stores the user's credentials\"",
              "createdAt": "2021-01-27T00:48:08Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 205,
              "body": "Rename exporter_key to export_key",
              "createdAt": "2021-01-27T00:49:12Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 382,
              "body": "Nit: Perhaps change the anchor link from `#SecHmqv` to something else?",
              "createdAt": "2021-01-27T00:50:55Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 649,
              "body": "nit: info2 does not seem to be defined anywhere",
              "createdAt": "2021-01-27T00:54:29Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzM0OTI2",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T14:59:56Z",
          "updatedAt": "2021-01-29T14:59:56Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Yep, good idea!",
              "createdAt": "2021-01-29T14:59:56Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzQ4MDMx",
          "commit": {
            "abbreviatedOid": "db6a82a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T15:14:06Z",
          "updatedAt": "2021-01-29T15:14:07Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "Thanks, @hugokraw -- I applied your suggested text, and added a note describing that applications can use `session_key` to derive additional keying material.",
              "createdAt": "2021-01-29T15:14:07Z",
              "updatedAt": "2021-01-29T15:14:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY0NDQ0MTYy",
      "title": "Simplify envelope secret derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/126",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #120.\r\n\r\ncc @hugokraw ",
      "createdAt": "2021-01-30T15:33:26Z",
      "updatedAt": "2021-04-24T15:12:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3451ec3e3e5f6ab3d06247a8d4e7bf1488749c64",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/simplify-secret-derivation",
      "headRefOid": "00810795fa60f5a5e77cee205d1e698d3b533077",
      "closedAt": "2021-02-01T14:31:15Z",
      "mergedAt": "2021-02-01T14:31:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "239450c6747e5aed3a3b510d9b33ac7f816534e1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5OTYyMjgx",
          "commit": {
            "abbreviatedOid": "0081079"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2021-02-01T01:18:39Z",
          "updatedAt": "2021-02-01T01:18:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY0NDc2Mzgy",
      "title": "Update the keyagreement reference",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/127",
      "state": "CLOSED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "so that the \"Update Editor's Copy\" GitHub action succeeds.\r\n\r\nThe GitHub action fails with the following message:\r\n```\r\n/github/home/.cache/xml2rfc/reference.DOI.10.6028_NIST.SP.800-56Ar3--anchor=keyagreement.xml: fetching\r\n*** 404 NOT FOUND while fetching https://xml2rfc.tools.ietf.org/public/rfc/bibxml7/reference.DOI.10.6028/NIST.SP.800-56Ar3.xml?anchor=keyagreement\r\n*** No such file or directory @ rb_sysopen - /github/home/.cache/xml2rfc/reference.DOI.10.6028_NIST.SP.800-56Ar3--anchor=keyagreement.xml for /github/home/.cache/xml2rfc/reference.DOI.10.6028_NIST.SP.800-56Ar3--anchor=keyagreement.xml\r\nError: Unable to parse the XML document: /dev/stdin\r\nmake: *** [lib/main.mk:68: draft-irtf-cfrg-opaque.xml] Error 1\r\n```\r\nSee https://github.com/cfrg/draft-irtf-cfrg-opaque/runs/1797781503 .\r\n\r\nThere is an alternate link to this reference here:\r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml-nist/reference.NIST.NIST.SP.800-56Ar3.xml .",
      "createdAt": "2021-01-30T17:48:25Z",
      "updatedAt": "2021-01-30T21:20:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3451ec3e3e5f6ab3d06247a8d4e7bf1488749c64",
      "headRepository": null,
      "headRefName": "keyagreement",
      "headRefOid": "bce6d06160b760c6ff3e5c02f0c88e57a4acafed",
      "closedAt": "2021-01-30T17:59:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "creemama",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Awww shucks, I thought that would work. Let me see if I can figure this out.",
          "createdAt": "2021-01-30T17:50:41Z",
          "updatedAt": "2021-01-30T17:50:41Z"
        },
        {
          "author": "creemama",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The GitHub action tries to pull from \r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml2/reference.NIST.NIST.SP.800-56Ar3.xml\r\ninstead of\r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml-nist/reference.NIST.NIST.SP.800-56Ar3.xml .\r\n\r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml2 has some NIST references but not the one we want.",
          "createdAt": "2021-01-30T17:59:30Z",
          "updatedAt": "2021-01-30T17:59:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Don't worry about fixing this. I'll take care of it.",
          "createdAt": "2021-01-30T21:20:12Z",
          "updatedAt": "2021-01-30T21:20:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY2MjA0ODcy",
      "title": "First test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/133",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #119.",
      "createdAt": "2021-02-02T19:02:55Z",
      "updatedAt": "2021-04-24T15:12:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "239450c6747e5aed3a3b510d9b33ac7f816534e1",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/format-vectors",
      "headRefOid": "7402eb5441d45028adce29c8a3a41680411f078b",
      "closedAt": "2021-02-03T00:32:03Z",
      "mergedAt": "2021-02-03T00:32:02Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "ea3739c54c9c580f12ade6811d5e5ea414ccc549"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> They match!\r\n\r\ncongrats @kevinlewi  :)\r\n",
          "createdAt": "2021-02-03T21:55:16Z",
          "updatedAt": "2021-02-03T21:55:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxNzU2NzQ0",
          "commit": {
            "abbreviatedOid": "46e2424"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "- [x] Let's move any discussion of variable name changes and designation of inputs/outputs to #119, so that once we agree on a setting, this PR can just implement whatever is decided in #119\r\n\r\n- [x] credential_request / KE1, credential_response / KE2, and credential_finalization / KE3 messages are missing\r\n\r\n- [ ] Add a glossary for some of the variable names that do not appear anywhere in the spec (for example, envelope_nonce)",
          "createdAt": "2021-02-02T20:44:45Z",
          "updatedAt": "2021-02-03T00:00:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxODg5NjAz",
          "commit": {
            "abbreviatedOid": "7402eb5"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "They match!",
          "createdAt": "2021-02-03T00:29:38Z",
          "updatedAt": "2021-02-03T00:29:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MTE0MTA5",
      "title": "Adding text on export key usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/135",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion in #130 \r\n\r\nCloses #130 ",
      "createdAt": "2021-02-03T20:13:01Z",
      "updatedAt": "2021-02-03T20:16:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ea3739c54c9c580f12ade6811d5e5ea414ccc549",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "export_key_usage",
      "headRefOid": "2286ceaa269e47551febe2b3b9bd875759019d06",
      "closedAt": "2021-02-03T20:16:23Z",
      "mergedAt": "2021-02-03T20:16:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2d6462b358c97b192b2030eadf55dab6da4fbac9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNzYzODEy",
          "commit": {
            "abbreviatedOid": "2286cea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-03T20:16:17Z",
          "updatedAt": "2021-02-03T20:16:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MTIxMjM3",
      "title": "Renaming \"user\" to \"client\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/136",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #134 ",
      "createdAt": "2021-02-03T20:25:18Z",
      "updatedAt": "2021-02-03T20:27:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2d6462b358c97b192b2030eadf55dab6da4fbac9",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "user_to_client",
      "headRefOid": "f1d16cdc593833d188daad7606abc99c5316cd60",
      "closedAt": "2021-02-03T20:27:18Z",
      "mergedAt": "2021-02-03T20:27:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "111b02c884ca967d6c78182dae08f7d83d4be7ae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNzcxOTgy",
          "commit": {
            "abbreviatedOid": "f1d16cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-03T20:27:14Z",
          "updatedAt": "2021-02-03T20:27:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MTIzMzg4",
      "title": "Limiting opaque key types to 255 bytes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/137",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes all opaque key types to be at most 255 bytes (instead of 2^16-1). Also changed encrypted_creds in the envelope to have the same restriction.\r\n\r\nNote: Still need to update the test vectors to match this new change.\r\n\r\nCloses #132 ",
      "createdAt": "2021-02-03T20:29:15Z",
      "updatedAt": "2021-02-17T01:43:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "111b02c884ca967d6c78182dae08f7d83d4be7ae",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "hkdf_limits",
      "headRefOid": "21e9d8b937f298d7693dfdf62342d19102f94a64",
      "closedAt": "2021-02-17T01:43:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Changes all opaque key types to be at most 255 bytes (instead of 2^16-1). Also changed encrypted_creds in the envelope to have the same restriction.\r\n\r\nThis may be too restrictive with PQ algorithms. So if you set that limit, a discussion will be needed about what you do when the algorithm you want to deploy has more than 255 bytes. I will check more about lattice-based schemes and how well they accommodate expanding a PRG seed (namely, what's the computational cost of expanding the seed to a full key).",
          "createdAt": "2021-02-04T19:12:59Z",
          "updatedAt": "2021-02-04T19:12:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Putting this in draft mode so that we can address #121 with this PR as well. I intend to add a new `Nk` parameter to denote the key size, which would be set in the configuration for the ciphersuite.",
          "createdAt": "2021-02-07T23:12:18Z",
          "updatedAt": "2021-02-07T23:12:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #141 ",
          "createdAt": "2021-02-17T01:43:08Z",
          "updatedAt": "2021-02-17T01:43:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MjQyMDU5",
      "title": "Add back alternate AKE sketches",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/138",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, nail down the MHF parameters. We don't currently allow them to be negotiated *in* the protocol. (The wrapper protocol may choose to allow negotiation, but that negotiation would yield a different configuration.)\r\n\r\nCloses #128 and #69.\r\n\r\ncc @hugokraw ",
      "createdAt": "2021-02-04T00:20:58Z",
      "updatedAt": "2021-04-24T15:12:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "111b02c884ca967d6c78182dae08f7d83d4be7ae",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/add-alternates",
      "headRefOid": "ef80344d24412fab0270422536184095ba296b7f",
      "closedAt": "2021-02-05T21:00:08Z",
      "mergedAt": "2021-02-05T21:00:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "62d7d074d3a24e98d8812f0a200916330a28e9fe"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Change overall looks good to me. One nit: Perhaps preface the titles of the last few sections with \"Appendix: Test Vectors\" and \"Appendix: Alternate AKE instantiations\", just to make it extra clear?",
          "createdAt": "2021-02-04T00:59:16Z",
          "updatedAt": "2021-02-04T00:59:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "These are already rendered in the appendix:\r\n\r\n```\r\n   Appendix B.  Alternate AKE instantiations\r\n     B.1.  HMQV Instantiation Sketch\r\n     B.2.  SIGMA-I Instantiation Sketch\r\n```\r\n\r\nProbably adding \"Appendix\" to the section headers would be redundant?",
          "createdAt": "2021-02-04T01:11:12Z",
          "updatedAt": "2021-02-04T01:11:12Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> These are already rendered in the appendix:\r\n> \r\n> ```\r\n>    Appendix B.  Alternate AKE instantiations\r\n>      B.1.  HMQV Instantiation Sketch\r\n>      B.2.  SIGMA-I Instantiation Sketch\r\n> ```\r\n> \r\n> Probably adding \"Appendix\" to the section headers would be redundant?\r\n\r\nOops, didn't realize that. Great!",
          "createdAt": "2021-02-04T01:12:40Z",
          "updatedAt": "2021-02-04T01:12:40Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Test vectors look good!",
          "createdAt": "2021-02-05T18:23:26Z",
          "updatedAt": "2021-02-05T18:23:26Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I see no point in adding SIGMA to the appendix the way it is now. If you put a sketch of it in the appendix then let's put a sketch of it, not just one sentence. The only substantial difference with the description of 3DH and HMQV is the signature. The rest follows the same pattern as 3DH and HMQV.  I believe that this description will be useful and since we do not provide test vectors then it does not have an extra cost. ",
          "createdAt": "2021-02-06T04:35:41Z",
          "updatedAt": "2021-02-06T04:35:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0NTk2MDEx",
          "commit": {
            "abbreviatedOid": "ef80344"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-05T18:23:38Z",
          "updatedAt": "2021-02-05T18:23:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MjQ0NTc1",
      "title": "Match identifiers with main document.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/139",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "```txt\r\nenum {\r\n  base(1),\r\n  custom_identifier(2),\r\n  (255)\r\n} EnvelopeMode;\r\n```",
      "createdAt": "2021-02-04T00:27:44Z",
      "updatedAt": "2021-02-04T13:11:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "111b02c884ca967d6c78182dae08f7d83d4be7ae",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "d4402cb2754ef734043f24dc088beaab11135404",
      "closedAt": "2021-02-04T13:11:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch, @armfazh, thanks!! @chris-wood should we instead change base to be 0 and custom_identifier to be 1 in the main document, or go ahead with this change?",
          "createdAt": "2021-02-04T00:56:24Z",
          "updatedAt": "2021-02-04T00:56:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's just update the text to start at 0. I'm not sure why we had them start at 1? @armfazh, could you please submit a PR with that change? (I can also update #138 to do that.)",
          "createdAt": "2021-02-04T01:09:08Z",
          "updatedAt": "2021-02-04T01:09:08Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "In other designs, IDs start at 1 to allow for a default value or a value that doesn't pin an exact identifier. E.g if the client starts with a configuration set where the mode is 0, the mode is not forced to be one or another, meaning the client can then determine at runtime what it prefers or what's available (given the context the client may or may not have access to identifiers, and will only decide at protocol execution).\nAlso, the OPRF ciphersuites start at 1 as well :)",
          "createdAt": "2021-02-04T04:46:35Z",
          "updatedAt": "2021-02-04T04:46:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In other designs, IDs start at 1 to allow for a default value or a value that doesn't pin an exact identifier. E.g if the client starts with a configuration set where the mode is 0, the mode is not forced to be one or another, meaning the client can then determine at runtime what it prefers or what's available (given the context the client may or may not have access to identifiers, and will only decide at protocol execution).\r\n\r\nI don't follow this rationale. Modes are part of the configuration -- they're not 'negotiated' in any way.\r\n\r\n> Also, the OPRF ciphersuites start at 1 as well :)\r\n\r\nYeah, though it's somewhat arbitrary. I'll just take this change and update the test vectors in #138.",
          "createdAt": "2021-02-04T13:04:42Z",
          "updatedAt": "2021-02-04T13:04:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Applied this change to #138. Thanks, @armfazh!",
          "createdAt": "2021-02-04T13:11:16Z",
          "updatedAt": "2021-02-04T13:11:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 140,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcwOTc0OTU1",
      "title": "Addressing comments from issue #124",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/140",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@stef, replying to your suggestions in-line below. Please let me know if these adequately address the concerns you brought up! Closes #124 \r\n\r\n> > 2OSP and OS2IP: Convert a byte string to and from a non-negative integer as described in {{?RFC8017}}.\r\n> \r\n> link to https://tools.ietf.org/html/rfc8017#section-4.1 and https://tools.ietf.org/html/rfc8017#section-4.2\r\n> \r\n> perhaps also note that this is also known as the htons/ntohs functions in POSIX - implementors might find this very helpful!\r\n\r\nAdded a mention that these can be found in Section 4, but did not add the POSIX references since I could not find a link to them, and these may not be as widely known.\r\n\r\n> \r\n> > kX: An OPRF private key used in role X. For example, kU refers to U's private OPRF key.\r\n> \r\n> is there any other role besides kU?\r\n\r\nGood point, changed the text to refer to `oprf_key` instead of `kU`.\r\n\r\n> \r\n> > random(n): Generate a random byte string of length n bytes.\r\n> \r\n> note that this random string should be of cryptographic quality. although there is a note under all the definitions saying so, it's better to have it closer where it matters and less ignored.\r\n\r\nAdded a note here that it should be cryptographically-secure\r\n\r\n> \r\n> in #cryptographic-protocol-and-algorithm-dependencies-dependencies\r\n> \r\n> the note that only the base variant of the OPRF is needed is also a bit far away from where the OPRF dependency is specified.\r\n\r\nShifted the sentence to be right under the OPRF text\r\n\r\n> \r\n> > auth_tag : Authentication tag protecting the contents of the envelope, covering InnerEnvelope and CleartextCredentials\r\n> \r\n> then it notes:\r\n> \r\n> > The full procedure for constructing Envelope and InnerEnvelope from SecretCredentials and CleartextCredentials is described in {{finalize-request}}.\r\n> \r\n> which is:\r\n> \r\n> > 1. auth_tag = HMAC(auth_key, concat(contents, cleartext_creds))\r\n> \r\n> it's all there but quite dispersed spatially, someone trying to implement this has to jump around in the doc, it's very hard to read this spec sequentially.\r\n\r\nUnfortunately I could not find a way to address this without a major rework to the organization of the doc, since I think it is somewhat inherent to how it is currently laid out.\r\n\r\n> \r\n> > Credential information corresponding to the configuration-specific mode, along with the user public key pkU and private key skU, are stored in a Credentials object with the following named fields:\r\n> > skU, pkU, idU, idS\r\n> \r\n> it is not necessary to specify for interoperability how an implementation stores these values. also for security i think it is better to handle skU seperatately from the other values - or maybe not, depending on the configuration, if any of the other values is also to be kept secret. a sensible implementation wants to actually protect the sensitive values differently from the public values. maybe by storing them in mprotected/sanitized-after-use storage, in secure elements, or something else.\r\n> \r\n> i do see how it is a shortcut to list all the necessary items from the creds struture as an input to finalizerequest though.\r\n\r\nAdded text saying that this is \"recommended\", to emphasize the point that it is not required\r\n\r\n> \r\n> > Clients MUST NOT use the same key pair (skU, pkU) for two different accounts.\r\n> \r\n> why is this, when the server can use the same keypair for different accounts? in the case when idU == pkU this is not even possible i guess.\r\n\r\nRight, well if multiple accounts have the same skU associated with them, then decrypting one envelope would result in yielding the same secret for another without having to know the other account's password -- presumably this is bad for security.\r\n\r\n> \r\n> > pkS : An encoded public key that will be used for the online authenticated key exchange stage.\r\n> \r\n> add explicitly that this is the _servers_ pubkey\r\n> \r\n> similarly be explicit also about this:\r\n> \r\n> > pkU : An encoded public key, corresponding to the private key skU.\r\n> \r\n\r\nAdded, thanks!\r\n\r\n> #credential-file\r\n> \r\n> we agree these things need to be persisted, however i do not see how this helps interoperability or security specifying this struct. i propose to change the wording to something like:\r\n> \r\n> the server needs to be able to reproduce the following values for the online phase.\r\n> \r\n> an implementation might choose to generate kU by doing a KDF on some global secret value in combination with idU for example, then this storage of kU can be skipped. again we should realize that kU is a sensitive value which needs protection (like sanitization, possibly also at-rest encryption, not being swapped to disk, stored in a secure element, etc) while envU is an encrypted blob that does not need these kind of protections. in case pkU == idU it might be possbile that envU is stored in a hashdictionary that is indexed by idU, and thus pkU does not need to be stored at all. lumping these values together and requiring them to be stored in this structure creates unnecessary limitations on implementations. while this specification might harm security, it does not really improve interoperability.\r\n> \r\n> either delete this section, or make this optional, and put it into an non-binding appendix.\r\n> \r\n> another thing against this, is the usage of export-keys, in case an implementation chooses to encrypt data with an export-key but wants to stay stateless on the client, then the export-key encrypted data might also be stored on the server.\r\n\r\nAdded text to emphasize that this is not a requirement of the spec: \"The below structure represents an example of how\r\nthese values might be conveniently stored together.\"",
      "createdAt": "2021-02-10T10:01:08Z",
      "updatedAt": "2021-02-13T17:56:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c8321fdf18977af420c72c6d96c132b1970e3b4",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "stefs_comments",
      "headRefOid": "d186d249c017ea81c4f26a03dae156698fe4a34f",
      "closedAt": "2021-02-13T17:56:42Z",
      "mergedAt": "2021-02-13T17:56:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "572f395c8c536694ed8efe35fa80db2b213cdefd"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "good job. thanks!",
          "createdAt": "2021-02-11T14:16:25Z",
          "updatedAt": "2021-02-11T14:16:25Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "btw posix has a definition here https://pubs.opengroup.org/onlinepubs/9699919799/functions/htonl.html also known as: \r\n\r\n> The Open Group Base Specifications Issue 7, 2018 edition IEEE Std 1003.1-2017",
          "createdAt": "2021-02-11T14:23:28Z",
          "updatedAt": "2021-02-11T14:23:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 141,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcxMDA2MTk5",
      "title": "Adding Npk / Nsk parameter to fix public/private key sizes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/141",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Gets rid of the variable-length encoding of the client/server public/private keys, and restricts them to be of a fixed length (denoted by the parameters `Npk` and `Nsk`). Note that `Npk` and `Nsk` are parameters that must be specified for each AKE instantiation -- this gives the flexibility of future AKE instantiations that are PQ to use a larger `Npk` / `Nsk` if necessary.\r\n\r\nCloses #121 and #132 ",
      "createdAt": "2021-02-10T10:48:57Z",
      "updatedAt": "2021-02-17T21:51:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "572f395c8c536694ed8efe35fa80db2b213cdefd",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "adding_nk",
      "headRefOid": "238e956e2064ac5d7a5b43eca3a7c193cdd54366",
      "closedAt": "2021-02-17T21:51:35Z",
      "mergedAt": "2021-02-17T21:51:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fb9c5f136ec310978040892b0cb392623f3d4773"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "- Added Npk/Nsk instead of just Nk.\r\n- Added extra text to the Alternate AKEs section",
          "createdAt": "2021-02-16T22:24:08Z",
          "updatedAt": "2021-02-16T22:24:08Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Btw, @chris-wood  -- landing this will require an update to the test vectors. Should that be done in this change, or is it ok to land this first and expect that the test vectors will be updated in a later PR?",
          "createdAt": "2021-02-16T23:27:20Z",
          "updatedAt": "2021-02-16T23:27:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We (I) can do it in a separate PR. Before we merge this, I'd like to hear from @hugokraw about the proposal. ",
          "createdAt": "2021-02-16T23:30:29Z",
          "updatedAt": "2021-02-16T23:30:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not sure how I feel about fixing the length of keys. I guess it would be defined as part of a ciphersuite (or something that looks like it). Note that different representations of the same curves may have different public key lengths.\r\n\r\nYeah, this is the idea. A configuration (ciphersuite) would fully identify the AKE, including the key(s) used.\r\n\r\n> That seems an overkill way of dealing with the HKDF limit of 255*hlen. A simpler mechanism is to expand HKDF-expand, e.g. via concatentation of Expand(prk, info1, L1) and Expand(prk, info2, L2), etc.\r\n\r\nWhile true, I'd prefer not to have HKDF-specific workarounds in the spec. If anything, I'd suggest we factor out HKDF to a generic KDF that does not have an input limitation. Either way, this particular issue seems orthogonal to the overall change here (moving to fixed-length keys). \r\n\r\nI suggest we land this PR, and then use #132 to track a fix to the input limit.",
          "createdAt": "2021-02-17T19:53:59Z",
          "updatedAt": "2021-02-17T19:53:59Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'd prefer not to have HKDF-specific workarounds in the spec.\r\n\r\nI was not suggesting to specify that workaround as part of the spec. I was mostly \"complaining\" about telling people to use what can be an involved procedure (full key generation from a seed) when there are simpler straightforward workarounds for the HKDF length issue.  If you are already suggesting some solutions, I suggest you mention this simpler option. \r\n\r\nJust for fun I was looking at what discussion I had with Pasi Eronen when writing the HKDF draft and I said \r\n\r\n`The other issue that I am not totally happy with is the counter in the calculation of T(i)'s. I agree that for typical IETF applications, namely, protocols where HKDF is used to derive shared keys, the 2^8*2^5 bytes of key material (assuming SHA-256) should suffice. But I see the definition of HKDF as serving other purposes, such as more general pseudo-random generation, where larger amounts of output bits may be required. Should we say that applications may decide to use HKDF with longer counters? Or should we suggest a way of \"re-keying\" the PRF as I indicated in my previous message to you?`\r\n\r\n(the \"serving other purposes\" is well exemplified here)\r\n\r\nPasi answered:\r\n\r\n`About the counter length: I suggest we leave it as-is for now. \r\n(BTW, an application that needs more than 8 KB could also call\r\nthe KDF several times with different \"info\" values).`\r\n\r\nThe eternal tension between generality and complexity. Personally, I agree that too much flexibility is not good. But limiting generality also has its price and these things need to be weighted carefully. What is useful is to provide advise on points that may be too limiting (e.g., I wish we had a remark about the hkdf length workaround)\r\n",
          "createdAt": "2021-02-17T21:47:52Z",
          "updatedAt": "2021-02-17T21:47:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I hear what you're saying :-) I moved this comment over to #132, where we can address this issue in a future-proof way! For now, I'm merging this change.",
          "createdAt": "2021-02-17T21:51:28Z",
          "updatedAt": "2021-02-17T21:51:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjk0NjQ0",
          "commit": {
            "abbreviatedOid": "c7c1233"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with some suggestions -- thanks!",
          "createdAt": "2021-02-15T18:37:41Z",
          "updatedAt": "2021-02-16T14:00:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Are these always going to be the same size? (For 3DH, they will be, but perhaps not for others?)\r\n\r\n```suggestion\r\n  - Npk: The size of public keys used for the key exchange protocol.\r\n  - Nsk: The size of private keys used for the key exchange protocol.\r\n```",
              "createdAt": "2021-02-15T18:37:42Z",
              "updatedAt": "2021-02-16T23:09:25Z"
            },
            {
              "originalPosition": 89,
              "body": "Perhaps we should add some text to the \"alternate AKEs\" section elaborating on this point. Here's a suggestion:\r\n\r\n```\r\nThe AKE private key size (Nsk) is limited to the output size of the HKDF Expand function from {{RFC5869}}. \r\nFuture specifications which have keys exceeding this size should specify a mechanism by which private keys,\r\nand their corresponding public keys, can be deterministically derived from a fixed-length seed. \r\n```",
              "createdAt": "2021-02-15T18:43:43Z",
              "updatedAt": "2021-02-16T23:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxODY1NDI5",
          "commit": {
            "abbreviatedOid": "238e956"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I am not sure how I feel about fixing the length of keys. I guess it would be defined as part of a ciphersuite (or something that looks like it). Note that different representations of the same curves may have different public key lengths.\r\n\r\nThis one I don't like:\r\n\r\n```\r\n Future specifications which have keys exceeding this size should specify a\r\n mechanism by which private keys and their corresponding public keys can be\r\n deterministically derived from a fixed-length seed.\r\n```\r\n\r\nThat seems an overkill way of dealing with the HKDF limit of 255*hlen. A simpler mechanism is to expand HKDF-expand, e.g. via concatentation of Expand(prk, info1, L1) and Expand(prk, info2, L2), etc.",
          "createdAt": "2021-02-17T06:12:29Z",
          "updatedAt": "2021-02-17T06:12:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcyOTMyMDYy",
      "title": "Address #142 and minor suggestions to the draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/144",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In _opaque_ake.sage_ drop pre-hashing and carry only the transcript in the state + minor renaming to avoid confusion.\r\n\r\nSome typo fixing in the draft and suggestions.",
      "createdAt": "2021-02-13T12:39:27Z",
      "updatedAt": "2021-02-13T18:51:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c8321fdf18977af420c72c6d96c132b1970e3b4",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "4c8321fdf18977af420c72c6d96c132b1970e3b4",
      "closedAt": "2021-02-13T17:54:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can you please produce a diff that is not a complete replacement of the changed files. reviewing the changes like this is a bit uneconomic.",
          "createdAt": "2021-02-13T12:57:47Z",
          "updatedAt": "2021-02-13T12:57:47Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see. I don't know how this happened. Do you know how I can avoid that?",
          "createdAt": "2021-02-13T17:19:22Z",
          "updatedAt": "2021-02-13T17:19:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @stef! I submitted the same change in #145, with a correct diff :)",
          "createdAt": "2021-02-13T18:51:22Z",
          "updatedAt": "2021-02-13T18:51:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcyOTc3NzAw",
      "title": "Address #142 and minor suggestions to the draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/145",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In opaque_ake.sage drop pre-hashing and carry only the transcript in the state + minor renaming to avoid confusion.\r\n\r\nSome typo fixing in the draft and suggestions for wording.\r\n\r\ncc @chris-wood",
      "createdAt": "2021-02-13T18:50:06Z",
      "updatedAt": "2021-02-17T20:33:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "572f395c8c536694ed8efe35fa80db2b213cdefd",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "681df8652f2e109a008884d54e252190bdb2b430",
      "closedAt": "2021-02-17T20:33:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "why not hash the transcript?",
          "createdAt": "2021-02-13T18:59:26Z",
          "updatedAt": "2021-02-13T18:59:26Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not specified in the draft. ",
          "createdAt": "2021-02-13T19:00:42Z",
          "updatedAt": "2021-02-13T19:00:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the poc, the rust and my implementation did it like that. i think it comes from the paper. and it makes sense. i'd like to stick with it and rather specify it in the spec, than to drop it.",
          "createdAt": "2021-02-13T20:47:30Z",
          "updatedAt": "2021-02-13T20:47:30Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Why do you pre-hash it before hmac ?",
          "createdAt": "2021-02-13T22:09:51Z",
          "updatedAt": "2021-02-13T22:09:51Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "My PR comes from a conversation with @kevinlewi and @chris-wood, and we couldn't explain where this came from.\r\n\r\nI think I found it. The V1 says\r\n\r\n> * The explicit concatenation of elements under transcript2 and transcript3 can be replaced with hashed values of these elements, or their combinations, using a collision-resistant hash (e.g., as in the transcript-hash of TLS 1.3 [RFC8446]). \r\n\r\n\r\nbut this section is now absent. \r\n\r\nRFC8446 justifies this with the following\r\n\r\n> The reason for this construction is to allow the server to do a\r\n>    stateless HelloRetryRequest by storing just the hash of ClientHello1\r\n>    in the cookie, rather than requiring it to export the entire\r\n>    intermediate hash state (see Section 4.2.2).\r\n\r\nIs this useful in OPAQUE?",
          "createdAt": "2021-02-13T22:20:36Z",
          "updatedAt": "2021-02-13T23:14:19Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "interesting. i looked in the original paper and it is not there. there is one benefit for prehashing, the fact that the server does not have to preserve all the inputs for the hmac between the create-credential-response and the explicit authentication where the server verifies the km3 mac of the user.",
          "createdAt": "2021-02-13T22:38:50Z",
          "updatedAt": "2021-02-13T22:38:50Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "As Transcript3 is defined, it is transcript2 + server mac, and can be assembled at the KE2 stage.\nKeeping a hash of Transcript3 reduces the size of the server's state, indeed.",
          "createdAt": "2021-02-13T22:45:10Z",
          "updatedAt": "2021-02-13T22:45:43Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "From a security perspective, though, pre-hashing is a weaker construction, as it relies on the collision resistance of the pre-hashing function. Not hashing protects against a theoretical attack, I don't know if this has been considered in our case.",
          "createdAt": "2021-02-14T00:14:44Z",
          "updatedAt": "2021-02-14T00:14:56Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, the server can compute the client_mac at KE2 as well. It doesn't actually need to preserve anything except the client_mac.\r\n\r\nSo the server does all its signing in KE2, the client all its signing in KE3, none need to carry any trace of transcript2 and transcript3. Hence, no pre-hashing needed.",
          "createdAt": "2021-02-14T00:40:33Z",
          "updatedAt": "2021-02-14T00:46:28Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "indeed with the elimination of info3/einfo3 this makes sense.",
          "createdAt": "2021-02-14T00:43:18Z",
          "updatedAt": "2021-02-14T00:43:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare can we close this given that #147 landed?",
          "createdAt": "2021-02-17T19:50:14Z",
          "updatedAt": "2021-02-17T19:50:14Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, of course.",
          "createdAt": "2021-02-17T20:33:18Z",
          "updatedAt": "2021-02-17T20:33:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczMTY4Mzc5",
      "title": "Unify key derivation and confirmation transcripts.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/147",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change unifies the transcripts used across key derivation and confirmation. It allows clients and servers to keep a rolling hash of messages sent and received when running the protocol, thereby minimizing state. It also makes testing and implementation easier, as there are no longer two different transcripts which differ in context.\r\n\r\nCloses #108 and #142.\r\n\r\ncc @bytemare, @stef\r\n",
      "createdAt": "2021-02-14T22:47:33Z",
      "updatedAt": "2021-04-24T15:12:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "572f395c8c536694ed8efe35fa80db2b213cdefd",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/unify-transcripts",
      "headRefOid": "ac007182b0793ed927444f1458d6f1e8c97885ef",
      "closedAt": "2021-02-17T19:49:21Z",
      "mergedAt": "2021-02-17T19:49:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "82a20bd788dd99d25eee2802111fc0317d44d63b"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "That's very interesting, well spotted!\r\nBut do you hash in `hmac` because you already hash for `info` ?",
          "createdAt": "2021-02-15T13:36:53Z",
          "updatedAt": "2021-02-15T13:38:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> But do you hash in hmac because you already hash for info ?\r\n\r\nI'm not sure I understand this question \ud83e\udd14 ",
          "createdAt": "2021-02-15T18:05:28Z",
          "updatedAt": "2021-02-15T18:05:28Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "If I'm not mistaken, `hmac()` doesn't need its input to be hashed beforeheand. Please correct me if I'm wrong.\r\n\r\nHere, you build upon the running hash used for `info` and use this state for `hmac()`. `info` needs to hash, so reusing this existing state is beneficial. My question is whether you hash the transcript for `hmac()` so you can use/piggyback on `info`'s running hash.",
          "createdAt": "2021-02-15T23:11:30Z",
          "updatedAt": "2021-02-15T23:11:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I'm not mistaken, hmac() doesn't need its input to be hashed beforeheand. Please correct me if I'm wrong.\r\n\r\nThat's right -- it doesn't. \r\n\r\n> Here, you build upon the running hash used for info and use this state for hmac(). info needs to hash, so reusing this existing state is beneficial. My question is whether you hash the transcript for hmac() so you can use/piggyback on info's running hash.\r\n\r\nI *think* I understand you (it would be helpful if you pointed to specific text). I did this because HMAC implementations always hash the input, which is treated as an opaque string. HMAC APIs don't allow one to \"pass in\" existing hash state, e.g., the running hash context for `info`. \r\n\r\nSo, yes, the hash is redundant, but it's there because of API limitations. Does that help clarify?",
          "createdAt": "2021-02-16T14:16:24Z",
          "updatedAt": "2021-02-16T14:16:24Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, thank you :)",
          "createdAt": "2021-02-17T01:39:52Z",
          "updatedAt": "2021-02-17T01:39:52Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, I tested and confirm the new vectors! ",
          "createdAt": "2021-02-17T01:40:20Z",
          "updatedAt": "2021-02-17T01:40:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great suggestions, @kevinlewi! I applied them. Please have another look?",
          "createdAt": "2021-02-17T18:00:37Z",
          "updatedAt": "2021-02-17T18:00:37Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks great! Also verified the test vectors.",
          "createdAt": "2021-02-17T19:44:44Z",
          "updatedAt": "2021-02-17T19:44:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNDkwNTA4",
          "commit": {
            "abbreviatedOid": "a1451a8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T13:47:42Z",
          "updatedAt": "2021-02-15T17:36:06Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Maybe we should call the suffix something else than `transcript`, when it's only `mac` or `einfo + mac`, as it can be confusing.",
              "createdAt": "2021-02-15T13:47:42Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjgwNzk5",
          "commit": {
            "abbreviatedOid": "a1451a8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T18:05:49Z",
          "updatedAt": "2021-02-15T18:05:50Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "`suffix` would be a fine name for this, I think?",
              "createdAt": "2021-02-15T18:05:49Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNzM0MDU0",
          "commit": {
            "abbreviatedOid": "a1451a8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T00:18:49Z",
          "updatedAt": "2021-02-17T00:18:49Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "sounds good!",
              "createdAt": "2021-02-17T00:18:49Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNzQyODcz",
          "commit": {
            "abbreviatedOid": "a1451a8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T00:40:11Z",
          "updatedAt": "2021-02-17T00:40:23Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "client_transcript **is**  KE1",
              "createdAt": "2021-02-17T00:40:11Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxODA1MTU5",
          "commit": {
            "abbreviatedOid": "a1451a8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T03:12:45Z",
          "updatedAt": "2021-02-17T03:12:45Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "\ud83d\udc4d good catch",
              "createdAt": "2021-02-17T03:12:45Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxODQxNTIy",
          "commit": {
            "abbreviatedOid": "a1451a8"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Providing some initial suggestions after reading through the changes, which look reasonable to me.\r\n\r\nI would also like to try to implement this and see if the test vectors match, and also verify whether or not this is actually a simplification of the implementation, but thought it would be good to leave these suggestions here first. But no need to block on me completing the implementation portion.",
          "createdAt": "2021-02-17T05:07:12Z",
          "updatedAt": "2021-02-17T05:22:01Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Can we rename this variable to `preamble` or something, instead of keeping it as `info`? It seems to be called `preamble` in the HMQV/SIGMA-I sections, and `info` is already an overloaded term here, since it could be confused with HKDF info, `client_info`, `enc_server_info `, etc. :) ",
              "createdAt": "2021-02-17T05:07:12Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            },
            {
              "originalPosition": 47,
              "body": "The new `client_transcript` variable only appears twice. Can we just rename it as `KE1` in the two occurrences it appears in, rather than introducing a new variable?\r\n\r\nAlso, same thing with the `server_transcript` variable. I am wary of introducing all of these new terms that aren't accompanied by a struct definition. Perhaps we could abstract away the struct definition of `KE2` to denote an \"inner\" struct which captures these values that we want to represent as `server_transcript` here? So in other words, something like:\r\n\r\n```\r\nstruct {\r\n  CredentialResponse response;\r\n  uint8 server_nonce[32];\r\n  uint8 server_keyshare[Npk];\r\n} InnerKE2;\r\n\r\nstruct {\r\n  InnerKE2 inner_ke2;\r\n  opaque enc_server_info<0..2^16-1>;\r\n  uint8 mac[Nh];\r\n} KE2;\r\n```\r\n\r\nAnd then just use `InnerKe2` here instead of `server_transcript`.",
              "createdAt": "2021-02-17T05:08:14Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            },
            {
              "originalPosition": 61,
              "body": "Agreed with not calling this `transcript`. Also, maybe the clarity of this could be improved, by explicitly writing out the computation of KE2.mac and KE2.mac in an equation form (similarly to how the `auth_tag` computation is written for the envelope):\r\n\r\n- `Ke2.mac = HMAC(Km2, concat(info, KE2.enc_server_info))`\r\n- `Ke3.mac = HMAC(Km3, concat(info, KE2.enc_server_info, KE2.mac))`\r\n\r\nThat way, you don't even need to introduce the `transcript` or `suffix` variable :) ",
              "createdAt": "2021-02-17T05:18:49Z",
              "updatedAt": "2021-02-17T18:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNTYxNDkx",
          "commit": {
            "abbreviatedOid": "ac00718"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-17T19:44:53Z",
          "updatedAt": "2021-02-17T19:44:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczNTg0NTQ1",
      "title": "Simplify static DH text.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/148",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #131.",
      "createdAt": "2021-02-15T14:01:38Z",
      "updatedAt": "2021-04-24T15:12:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "572f395c8c536694ed8efe35fa80db2b213cdefd",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/static-dh",
      "headRefOid": "78809ec371fea2056c226723732ce223d8ca1b63",
      "closedAt": "2021-02-17T03:09:49Z",
      "mergedAt": "2021-02-17T03:09:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c7f6db0c1843db4fe11c050ff6049864fbd73691"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNzczMDQy",
          "commit": {
            "abbreviatedOid": "78809ec"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2021-02-17T01:42:48Z",
          "updatedAt": "2021-02-17T01:42:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2MDUwODI3",
      "title": "Update test vectors to match the fixed-length key change.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/149",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @bytemare if he wants to verify :) ",
      "createdAt": "2021-02-18T22:55:31Z",
      "updatedAt": "2021-04-24T15:12:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "fb9c5f136ec310978040892b0cb392623f3d4773",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fix-key-lengths",
      "headRefOid": "50c932ab0313734298d3f29d358ceac0ab2261a1",
      "closedAt": "2021-02-19T21:45:42Z",
      "mergedAt": "2021-02-19T21:45:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e2387879ec05c7251532f2d3203e60f7c8297722"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Verified \u2705",
          "createdAt": "2021-02-19T01:56:46Z",
          "updatedAt": "2021-02-19T01:56:46Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Verified both of the ristretto255 test vectors, thanks!",
          "createdAt": "2021-02-19T21:45:00Z",
          "updatedAt": "2021-02-19T21:45:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NTk5NzEw",
          "commit": {
            "abbreviatedOid": "50c932a"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-19T21:45:17Z",
          "updatedAt": "2021-02-19T21:45:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3MTI4MzA2",
      "title": "Remove implementation encrypted credentials length prefix, and align with VOPRF-06",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/151",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #150.\r\n\r\ncc @bytemare",
      "createdAt": "2021-02-21T15:18:51Z",
      "updatedAt": "2021-04-24T15:12:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e2387879ec05c7251532f2d3203e60f7c8297722",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/drop-ct-length-prefix",
      "headRefOid": "9fcb7a3be90be69abf258197ee2042d743decde0",
      "closedAt": "2021-02-21T23:36:45Z",
      "mergedAt": "2021-02-21T23:36:45Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "a2caa62480a44d3af8a428021b8aab48d2a0b454"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "\u2705 Works like a charm!",
          "createdAt": "2021-02-21T17:17:07Z",
          "updatedAt": "2021-02-21T17:17:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODYxNDgx",
          "commit": {
            "abbreviatedOid": "b7df7ee"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T17:13:38Z",
          "updatedAt": "2021-02-21T17:13:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "That's maybe `random_bytes(config.Nsk)`",
              "createdAt": "2021-02-21T17:13:38Z",
              "updatedAt": "2021-02-21T19:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODg1MzM1",
          "commit": {
            "abbreviatedOid": "9fcb7a3"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T21:58:01Z",
          "updatedAt": "2021-02-21T21:58:01Z",
          "comments": [
            {
              "originalPosition": 370,
              "body": "> draft-06\r\n\r\nIn the future, it might become difficult to remember to update this number, right? Should we just eliminate this sentence?",
              "createdAt": "2021-02-21T21:58:01Z",
              "updatedAt": "2021-02-21T21:58:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODg1NDYx",
          "commit": {
            "abbreviatedOid": "9fcb7a3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T21:59:14Z",
          "updatedAt": "2021-02-21T21:59:15Z",
          "comments": [
            {
              "originalPosition": 370,
              "body": "I left it here to make it clear that we\u2019re using -06. I\u2019m not worried about updating this in the future.",
              "createdAt": "2021-02-21T21:59:15Z",
              "updatedAt": "2021-02-21T21:59:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODg1NDky",
          "commit": {
            "abbreviatedOid": "9fcb7a3"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T21:59:30Z",
          "updatedAt": "2021-02-21T21:59:30Z",
          "comments": [
            {
              "originalPosition": 372,
              "body": "Rather than calling these \"OPAQUE-3DH Test Vector 1, 2, 3, etc.\", should we give them more descriptive names based on the configuration? We already reference the fact that it is 3DH here.",
              "createdAt": "2021-02-21T21:59:30Z",
              "updatedAt": "2021-02-21T21:59:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODg2MDg1",
          "commit": {
            "abbreviatedOid": "9fcb7a3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T22:05:12Z",
          "updatedAt": "2021-02-21T22:05:13Z",
          "comments": [
            {
              "originalPosition": 372,
              "body": "Maybe, but this requires a script change that we can make in a future PR. Can you file an issue for this?",
              "createdAt": "2021-02-21T22:05:13Z",
              "updatedAt": "2021-02-21T22:05:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODk1NTMz",
          "commit": {
            "abbreviatedOid": "9fcb7a3"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "verified Test Vectors 1 and 6",
          "createdAt": "2021-02-21T23:33:10Z",
          "updatedAt": "2021-02-21T23:33:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3MTUyODg1",
      "title": "Fix some typos and suggested wording.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/152",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @chris-wood ",
      "createdAt": "2021-02-21T18:01:59Z",
      "updatedAt": "2021-02-21T19:18:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "caw/drop-ct-length-prefix",
      "baseRefOid": "218d57ecde0df545c437f5d82b3aa15c496ee6a9",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "79981c582a21a731056bfbd67922478c259408d9",
      "closedAt": "2021-02-21T19:18:44Z",
      "mergedAt": "2021-02-21T19:18:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9fcb7a3be90be69abf258197ee2042d743decde0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODcxNTU1",
          "commit": {
            "abbreviatedOid": "79981c5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-21T19:18:34Z",
          "updatedAt": "2021-02-21T19:18:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 154,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzNDIzNTEy",
      "title": "New Envelope mode proposal including private key derivation from OPRF output",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/154",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After discussions with @chris-wood and @kevinlewi and the thread in #84, this PR is a first sketch of a proposal to address these discussions.\r\n\r\nProposal of new envelope modes\r\n\r\n1. **Drop Base/CustomIdentifiers**\r\nCleartextCredentials always contain pks, idu and ids. If not supplied by the client, idu and ids MUST default to the public keys.\r\n2. Introduce two new modes\r\n    a. **Internal mode**\r\n    The client keys are generated internally from a seed. (also called \"seed mode\", \"encryption-less mode\", etc. in different issues and conversations). No encrypted creds in the envelope. Applications are not expected to know how to deal with key generation.\r\n    b. **External mode**\r\n    The client keys are provided by the application, and OPAQUE encrypts the private key into the encrypted creds in the envelope.\r\n\r\nIsolating the Envelope description and mode, as well as the rearrangements, are my own suggestions and not part of the discussions.",
      "createdAt": "2021-03-02T23:51:54Z",
      "updatedAt": "2021-04-15T13:25:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "40f2784b521eba1c0e4a5a1b0fa34b12b88e4b5e",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "1886ef63567c4e97a16d0a462f6198c70d548c35",
      "closedAt": "2021-04-15T13:25:47Z",
      "mergedAt": "2021-04-15T13:25:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "694282530704ea47a98cd8fc65c274fd93d5aa40"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Line 302-306 would need to be adapted as well:\r\n\r\n> OPAQUE consists of two stages: registration and authenticated key exchange.\r\n> In the first stage, a client registers its password with the server and stores\r\n> its encrypted credentials on the server. In the second stage, a client obtains\r\n> those credentials, recovers them using the client's password, and subsequently uses\r\n> them as input to an AKE protocol.",
          "createdAt": "2021-03-07T14:53:24Z",
          "updatedAt": "2021-03-07T14:53:24Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Latest changes include:\r\n- Moving envelope mode and nonce out of the inner envelope up into the envelope. The inner envelope is now purely independent from one mode to the other and use it as they see fit. E.g. the internal mode uses a \"nil\" envelope.\r\n- In case no custom identifiers are used, the client didn't have access to its public key. The internal mode could get it for the cost of a scalar multiplication, but the external mode wouldn't be covered. Sending it to the client in the CredentialResponse covers both modes. Integrated with CleartextCredentials it's authenticated under the mac.\r\n- Introduced `Nn` to abstract nonce length, to not have magic numbers laying around in the document",
          "createdAt": "2021-03-11T14:55:53Z",
          "updatedAt": "2021-04-12T01:01:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzk0MTky",
          "commit": {
            "abbreviatedOid": "21bb6d2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T00:23:40Z",
          "updatedAt": "2021-03-03T00:58:57Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "> For example, if used as raw public keys for TLS 1.3 {{?RFC8446}}, they may be RSA or ECDSA keys as per {{?RFC7250}}.\r\n\r\nThis is not relevant anymore in that part of the document.",
              "createdAt": "2021-03-03T00:23:40Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 196,
              "body": "I will do a commit on this later",
              "createdAt": "2021-03-03T00:24:35Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 223,
              "body": "@chris-wood I think we should define the HashToScalar similarly to what has been done in VOPRF. What do you think?",
              "createdAt": "2021-03-03T00:27:47Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 221,
              "body": "I'm open to suggestions on how to best formulate this.\r\nI'm thinking of something around this\r\n\r\n> KeyGenFromSeed(seed): expand the seed to full private/public generation in the AKE setup",
              "createdAt": "2021-03-03T00:58:18Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNDUzMDU4",
          "commit": {
            "abbreviatedOid": "21bb6d2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-03T23:10:11Z",
          "updatedAt": "2021-03-03T23:19:57Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Can't this just be equal to hash_to_field with a specific DST?",
              "createdAt": "2021-03-03T23:10:11Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 223,
              "body": "Either hash_to_field or HashToScalar from VOPRF (may be cleaner to just specify hash_to_field from the h2c spec)",
              "createdAt": "2021-03-03T23:10:14Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 59,
              "body": "reference to `custom_identifier` mode which needs to be updated",
              "createdAt": "2021-03-03T23:11:03Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 125,
              "body": "reference to `custom_identifier` mode which needs to be updated",
              "createdAt": "2021-03-03T23:11:20Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 158,
              "body": "reference to `custom_identifier` mode which needs to be updated",
              "createdAt": "2021-03-03T23:11:26Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 30,
              "body": "I like the way this is written! Let's just remove all of the other references to this identity being \"optional\" in the later texts, and we can clarify that it defaults to the client_public_key and server_public_key.",
              "createdAt": "2021-03-03T23:18:33Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNjIzNjgw",
          "commit": {
            "abbreviatedOid": "21bb6d2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T01:33:48Z",
          "updatedAt": "2021-03-04T01:33:48Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "I think we should describe a generic `KeyGenFromSeed(seed)` here, and then specify that in OPAQUE-3DH we use `hash_to_field` with dst etc.. This way, it stays relevant for other AKEs, that  just need to define their own `KeyGenFromSeed(seed)` implementation.",
              "createdAt": "2021-03-04T01:33:48Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNjI0MTIx",
          "commit": {
            "abbreviatedOid": "21bb6d2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T01:35:02Z",
          "updatedAt": "2021-03-04T01:35:02Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "That's a leftover, well spotted!",
              "createdAt": "2021-03-04T01:35:02Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNjI2NDI0",
          "commit": {
            "abbreviatedOid": "21bb6d2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T01:40:48Z",
          "updatedAt": "2021-03-04T01:40:49Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Maybe \"redefine but with the same definition as in VOPRF\", just to make clear not to use VOPRF's DST for this hash_to_field",
              "createdAt": "2021-03-04T01:40:48Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTg0NzMw",
          "commit": {
            "abbreviatedOid": "21bb6d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T20:44:03Z",
          "updatedAt": "2021-03-05T21:01:14Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Maybe delete this entire sentence and the list (and replace it with one sentence above^)?",
              "createdAt": "2021-03-05T20:44:03Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nDuring protocol execution, these values are stored in an implementation-specific `Credentials` object with names matching the values. For example, `Credentials.server_public_key` is the server's public key.\r\n\r\nThese values are used in `SecretCredentials` and `CleartextCredentials` structures as follows:\r\n```",
              "createdAt": "2021-03-05T20:45:47Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 196,
              "body": "I don't think we need to include this rationale. It's probably fine to simply say, \"Applications can use existing key pairs for OPAQUE-3DH with the \"external\" mode,\" or something.",
              "createdAt": "2021-03-05T20:55:47Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 201,
              "body": "```suggestion\r\nIn this mode, the client's private and public keys are deterministically derived from the OPRF output. For OPAQUE-3DH, this is done by hashing the OPRF output to a scalar in the corresponding prime order group to produce a private key, and then multiplying that scalar by the fixed generator to produce the public key.\r\n```",
              "createdAt": "2021-03-05T20:57:35Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 203,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-03-05T20:57:45Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 221,
              "body": "\ud83d\udc4d agreed, and maybe call this `DeriveKeyPair(seed)`? Its implementation for OPAQUE-3DH would then be:\r\n\r\n```\r\nUse hash_to_field from {{!I-D.irtf-cfrg-hash-to-curve}} using Order() as the prime modulus, L = 48, `expand_message_xmd` with SHA-512, and DST = \"OPAQUE\", to produce sk. Then compute pk = sk * G.\r\n```\r\n... or something",
              "createdAt": "2021-03-05T20:59:28Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 223,
              "body": "I think the implementation should be something like:\r\n\r\n```\r\nsk = HashToScalar(seed)\r\npk = sk * G\r\n```",
              "createdAt": "2021-03-05T21:00:46Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NjIwNjE3",
          "commit": {
            "abbreviatedOid": "21bb6d2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T21:24:01Z",
          "updatedAt": "2021-03-05T21:24:01Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "ok, with something like \"OPAQUE-HashToScalar\" for dst?",
              "createdAt": "2021-03-05T21:24:01Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NzA0NTAy",
          "commit": {
            "abbreviatedOid": "f7fe1dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-06T00:50:52Z",
          "updatedAt": "2021-03-06T00:50:52Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "(Discussed offline) let's just mimic what the VOPRF draft does for HashToScalar here :) ",
              "createdAt": "2021-03-06T00:50:52Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5NjE0MjY1",
          "commit": {
            "abbreviatedOid": "cffa6f3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T10:35:10Z",
          "updatedAt": "2021-03-11T10:35:11Z",
          "comments": [
            {
              "originalPosition": 539,
              "body": "@kevinlewi should the modification be applied here as well?",
              "createdAt": "2021-03-11T10:35:10Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjg0NDg1",
          "commit": {
            "abbreviatedOid": "4e17ff3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Second pass done -- looking good! The rebase will obviously change some things, but the factored out functions is _really_ nice. I have comments and questions about some of the semantic changes and presentation, but we can certainly work through them (here or online -- whichever you prefer!)",
          "createdAt": "2021-03-24T22:32:40Z",
          "updatedAt": "2021-03-24T22:54:57Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n opaque server_identity<1..2^16-1>;\r\n opaque client_identity<1..2^16-1>;\r\n```\r\n\r\n(Since neither field can be empty)",
              "createdAt": "2021-03-24T22:32:40Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n\r\n~~~\r\n```",
              "createdAt": "2021-03-24T22:33:03Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 100,
              "body": "```suggestion\r\n\r\n~~~\r\n```",
              "createdAt": "2021-03-24T22:33:30Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 104,
              "body": "Why is `auth_tag` _before_ `inner_env`? It seems like `auth_tag` should cover the entire envelope, right?",
              "createdAt": "2021-03-24T22:34:10Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 122,
              "body": "This also includes `mode` and `nonce`, right?",
              "createdAt": "2021-03-24T22:34:54Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 128,
              "body": "```suggestion\r\nCreateEnvelope(random_pwd, server_public_key, creds)\r\n```",
              "createdAt": "2021-03-24T22:35:19Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 128,
              "body": "(here and below!)",
              "createdAt": "2021-03-24T22:35:38Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 148,
              "body": "@kevinlewi's change removed the nonce from this step, so we can probably lift derivation of `prk` to the function that calls `CreateEnvelope`.",
              "createdAt": "2021-03-24T22:38:47Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 158,
              "body": "The server public key is passed in as a parameter (as part of the CredentialResponse), so why is it needed to be part of `creds`?",
              "createdAt": "2021-03-24T22:40:33Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 217,
              "body": "```suggestion\r\nIn this mode, the client's private and public keys are deterministically derived from the OPRF output. \r\n```",
              "createdAt": "2021-03-24T22:44:03Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\r\nWith the internal key mode the `EnvelopeMode` value MUST be `internal` and the `InnerEnvelope` is empty.\r\n```",
              "createdAt": "2021-03-24T22:44:16Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 230,
              "body": "```suggestion\r\n```\r\nThe group seems implicit, so I think we can remove this.",
              "createdAt": "2021-03-24T22:45:14Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 242,
              "body": "```suggestion\r\n- client_public_key, the client's AKE public key\r\n\r\nSteps:\r\n1. _, client_public_key = DeriveKeyPair(prk)\r\n2. Output (nil, client_public_key)\r\n```",
              "createdAt": "2021-03-24T22:46:00Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 242,
              "body": "(Just renaming some things)",
              "createdAt": "2021-03-24T22:46:09Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 248,
              "body": "I think we should move this to the configuration section, which discusses particular types of Groups for 3DH.",
              "createdAt": "2021-03-24T22:47:54Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n```\r\n\r\nThis isn't an API that's exposed outside of its use in DeriveKeyPair, right? If not, we can probably drop it from here, and describe it where we specify how to implement DeriveKeyPair. (In the configurations section?)",
              "createdAt": "2021-03-24T22:48:59Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 246,
              "body": "```suggestion\r\nOPAQUE-3DH implements DeriveKeyPair(prk) as follows:\r\n```",
              "createdAt": "2021-03-24T22:49:32Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 282,
              "body": "```suggestion\r\n1. (client_secret_key, _) = DeriveKeyPair(prk)\r\n```",
              "createdAt": "2021-03-24T22:50:02Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 291,
              "body": "```suggestion\r\nIn this mode, the application provides the OPAQUE instantiation with the client's authentication material through the `Credentials` structure. An encryption key is generated from the hardened OPRF output and used to encrypt the client's private key, which is then stored encrypted in the `Envelope`. This allows for applications which prefer to generate keys using some existing method. \r\n```",
              "createdAt": "2021-03-24T22:51:51Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 341,
              "body": "Flagging this as a section that changed in @kevinlewi's PR, too.",
              "createdAt": "2021-03-24T22:52:20Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 487,
              "body": "Why is this needed? In internal mode, clients can compute it from the seed. In external mode, clients can also presumably compute it from the private key. Is this for settings where clients can't compute the public key from a private key?",
              "createdAt": "2021-03-24T22:53:45Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzMwNDE1",
          "commit": {
            "abbreviatedOid": "4e17ff3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:19:33Z",
          "updatedAt": "2021-03-25T00:19:34Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "`auth_tag` covers the entire envelope, indeed, but putting it before `inner_env` ensures it's always in the same position, regardless of the mode, and thus simplifies parsing. What do you think?",
              "createdAt": "2021-03-25T00:19:33Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzMzMjA3",
          "commit": {
            "abbreviatedOid": "4e17ff3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:27:22Z",
          "updatedAt": "2021-03-25T00:27:23Z",
          "comments": [
            {
              "originalPosition": 487,
              "body": "Indeed. I don't know if we can presume that clients can recompute their public key from the private key alone.\r\nAs much as I dislike this, simply sending it back to the client covers all cases and simplifies the implementation.\r\n\r\nBut if you think we should assume public key regeneration possible from the private one I'm totally on board.",
              "createdAt": "2021-03-25T00:27:23Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzM0NTkz",
          "commit": {
            "abbreviatedOid": "7cb2481"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:31:32Z",
          "updatedAt": "2021-03-25T00:31:32Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Yes, it does! Well spotted.",
              "createdAt": "2021-03-25T00:31:32Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzM4NjQ5",
          "commit": {
            "abbreviatedOid": "7cb2481"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:42:53Z",
          "updatedAt": "2021-03-25T00:42:53Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Indeed, I think this is a leftover of a drafting phase. In my implementation, I only use this field to pass the server public key to the server when responding on login. Thanks for spotting this !",
              "createdAt": "2021-03-25T00:42:53Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzQzNjU4",
          "commit": {
            "abbreviatedOid": "7cb2481"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:57:59Z",
          "updatedAt": "2021-03-25T00:57:59Z",
          "comments": [
            {
              "originalPosition": 487,
              "body": "Also, deriving the public key from the private key pushes the `auth_tag` verification to be done after the secret is recovered, i.e. we have the secret open and in memory, before we can authenticate the envelope. But maybe I'm just being overly paranoid.",
              "createdAt": "2021-03-25T00:57:59Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzQ0Nzgz",
          "commit": {
            "abbreviatedOid": "7cb2481"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T01:01:11Z",
          "updatedAt": "2021-03-25T01:01:11Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "And that I'm thinking of it, client_public_key isn't necessary either.",
              "createdAt": "2021-03-25T01:01:11Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwNDIxNDU1",
          "commit": {
            "abbreviatedOid": "89754dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T02:11:12Z",
          "updatedAt": "2021-03-25T02:11:12Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Yep, that makes sense. Let's leave this as-is.",
              "createdAt": "2021-03-25T02:11:12Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwNDI0MjE0",
          "commit": {
            "abbreviatedOid": "89754dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T02:13:06Z",
          "updatedAt": "2021-03-25T02:13:07Z",
          "comments": [
            {
              "originalPosition": 487,
              "body": "Hmm... how does this simplify the implementation? Does the client need to check that the public key it receives is correct for the given private key? I'd prefer we assume that the public key is recoverable from the private key.",
              "createdAt": "2021-03-25T02:13:06Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwNDQzMzE1",
          "commit": {
            "abbreviatedOid": "12b4cf7"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T02:25:49Z",
          "updatedAt": "2021-03-25T02:25:49Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Fixed.",
              "createdAt": "2021-03-25T02:25:49Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwNDU1NTcw",
          "commit": {
            "abbreviatedOid": "9195e95"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T02:33:11Z",
          "updatedAt": "2021-03-25T02:33:11Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Moved to the configurations sections, please have a look",
              "createdAt": "2021-03-25T02:33:11Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwNDcwMzI1",
          "commit": {
            "abbreviatedOid": "9598a45"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T02:42:12Z",
          "updatedAt": "2021-03-25T02:42:13Z",
          "comments": [
            {
              "originalPosition": 487,
              "body": "It simplifies the implementation in case you're using something else than POG and if you need extra data to generate your public key (e.g. for RSA). But I forgot we pinned this to 3DH only. I'll amend.",
              "createdAt": "2021-03-25T02:42:12Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNjI0ODg2",
          "commit": {
            "abbreviatedOid": "ad77e8a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T22:19:33Z",
          "updatedAt": "2021-03-25T22:19:33Z",
          "comments": [
            {
              "originalPosition": 487,
              "body": "Fixed. See https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/154/commits/ad77e8accc08c246dca858aeb9fbf503566ec506",
              "createdAt": "2021-03-25T22:19:33Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyODEzMjAy",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-29T01:22:07Z",
          "updatedAt": "2021-03-29T01:22:08Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "`CreateCleartextCredentials()`\r\nThe name might be misleading for the new reader.",
              "createdAt": "2021-03-29T01:22:08Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0ODc5Mjc2",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "afbase",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T04:19:57Z",
          "updatedAt": "2021-03-31T04:19:57Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": ">OPAQUE allows applications to either provide custom client private and public keys for authentication or to generate them internally, making the application oblivious to the client's private key. Each public and private key value is an opaque byte string, specific to the AKE protocol in which OPAQUE is instantiated.\r\n>\r\n>These two options are defined as the Internal Key and External Key modes. See {{envelope-modes}} for their specifications.\r\n\r\nCould we maybe be even more explicit to state that the the `EnvelopeMode` is external when a separate application(s) provide custom client private and public keys for authentication? \r\n\r\n>or to generate them internally\r\n\r\nAnd then a secondary statement which states the complimentary where the `EnvelopeMode` is internal when it is not the case when a separate application(s) provide custom client private and public keys for authentication. \r\n\r\nApologies if I'm falling out of the sky into this PR.  I've been following OPAQUE and TLS OPAQUE loosely for a bit.",
              "createdAt": "2021-03-31T04:19:57Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NTExNDA1",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T16:49:56Z",
          "updatedAt": "2021-03-31T17:21:31Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "@chris-wood: You wanted this moved into the OPRF part in my PR, just calling this out that it is moved back into its own section here",
              "createdAt": "2021-03-31T16:49:56Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 25,
              "body": "This is not used anymore, and I believe DeriveKeyPair should be used instead. So, delete this, I think...",
              "createdAt": "2021-03-31T16:51:03Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 125,
              "body": "Let's just remove these two steps (one because NoPubKeyError / nil is not defined anywhere, and two because this pseudocode can just assume that server_public_key and client_public_key already exist)",
              "createdAt": "2021-03-31T16:52:16Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 183,
              "body": "s/client_secret_key/client_private_key/\r\n\r\nHere, and everywhere else in the doc",
              "createdAt": "2021-03-31T16:59:07Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 126,
              "body": "We should define nil somewhere, or just turn this into pseudocode by saying \"if server_identity not specified\". Same for client_identity",
              "createdAt": "2021-03-31T17:01:34Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 176,
              "body": "\"specifying at least the `EnvelopeMode`.\"\r\n\r\nThat's no longer true, right?",
              "createdAt": "2021-03-31T17:02:55Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 341,
              "body": "Yes, it was removed -- can you remove it here as well?",
              "createdAt": "2021-03-31T17:05:14Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 58,
              "body": "Can we remove the word \"generally\"? Or are there exceptions to this rule? Also, is there ever a case where `Nn` is not equal to 32, and if so, can we just remove the use of this extra variable and hard-code 32 in place of `Nn`?",
              "createdAt": "2021-03-31T17:07:08Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 176,
              "body": "Can you also perhaps add a reference in the doc to where a reader can find the definition(s) of `InnerEnvelope`? Because they haven't been defined yet and it can cause confusion",
              "createdAt": "2021-03-31T17:08:59Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 335,
              "body": "internal key -> external key",
              "createdAt": "2021-03-31T17:10:27Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1ODY0MTg2",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T02:58:06Z",
          "updatedAt": "2021-04-01T02:59:31Z",
          "comments": [
            {
              "originalPosition": 491,
              "body": "Internal mode -> Internal Key mode",
              "createdAt": "2021-04-01T02:58:06Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 454,
              "body": "The API for FinalizeRequest should be updated (first argument is the client_private_key now)",
              "createdAt": "2021-04-01T02:58:29Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzU0NDU1",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Another round after my implementation and second pass -- nice work as usual!",
          "createdAt": "2021-03-31T22:02:19Z",
          "updatedAt": "2021-04-01T13:55:17Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "```suggestion\r\n6. cleartext_creds = CreateCleartextCredentials(server_public_key, client_public_key, server_identity, client_identity)\r\n```",
              "createdAt": "2021-03-31T22:02:19Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 194,
              "body": "Can we replace this with the server and client identities as two explicit parameters?\r\n```suggestion\r\n- server_identity, The encoded server identity\r\n- client_identity, The encoded client identity\r\n```",
              "createdAt": "2021-03-31T22:02:42Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 329,
              "body": "```suggestion\r\n3. Create SecretCredentials secret_creds with client_secret_key\r\n```",
              "createdAt": "2021-03-31T22:37:37Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 48,
              "body": "Hmm, these don't correspond to the OPRF, though, but are for the prime-order group keys, right? ",
              "createdAt": "2021-04-01T13:21:10Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nRandom nonces used in this protocol are of length `Nn = 32` bytes.\r\n```",
              "createdAt": "2021-04-01T13:21:35Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 126,
              "body": "Alternatively, we can modify the parameter description to read:\r\n\r\n```\r\n- server_public_key, The encoded client public key for the AKE protocol, which is nil if not specified\r\n```",
              "createdAt": "2021-04-01T13:22:46Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 178,
              "body": "```suggestion\r\nThe size of the serialized envelope is denoted `Ne` and varies based on the mode. The exact value for `Ne` is specified in {{internal-mode}} and {{external-mode}}.\r\n```",
              "createdAt": "2021-04-01T13:24:06Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 191,
              "body": "I would prefer that the hardened output (prk) be passed to this function (this function already does a lot).",
              "createdAt": "2021-04-01T13:25:06Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 274,
              "body": "This seems out of place now.\r\n```suggestion\r\n```",
              "createdAt": "2021-04-01T13:28:26Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 25,
              "body": "This looks like the rebase dropped some stuff, which makes me somewhat worried. @kevinlewi is anything else missing?",
              "createdAt": "2021-04-01T13:29:37Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 48,
              "body": "Additionally, @kevinlewi's change introduced DeriveKeyPair on the OPRF API. We need a different function name for the prime-order group variant. Perhaps, `DeriveGroupKeyPair`?",
              "createdAt": "2021-04-01T13:30:29Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 671,
              "body": "I know I was the one who suggested this be down in {{configurations}}, but now I'm second guessing that. Perhaps these should be kept in the external mode section? @kevinlewi, what do you think? (Also, is the generator G defined anywhere?)",
              "createdAt": "2021-04-01T13:43:19Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NDk2NDcw",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T17:30:24Z",
          "updatedAt": "2021-04-01T17:30:24Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "+1 for dropping generally\r\n\r\nOn the other hand, I'm less comfortable with hardcoding values. But if you both think we should revert to do it, I can live with that :)",
              "createdAt": "2021-04-01T17:30:24Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NDk3MzE4",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T17:31:27Z",
          "updatedAt": "2021-04-01T17:31:27Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I just saw @chris-wood  suggestion !",
              "createdAt": "2021-04-01T17:31:27Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NDk4NzQ4",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T17:33:16Z",
          "updatedAt": "2021-04-01T17:33:16Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "Perfect, much better \ud83d\udc4c  thanks !",
              "createdAt": "2021-04-01T17:33:16Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NDk5Njky",
          "commit": {
            "abbreviatedOid": "6da4b38"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T17:34:27Z",
          "updatedAt": "2021-04-01T17:34:27Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "i.e. dropping the need for the `Credentials` structure, right? (I'm in favor)",
              "createdAt": "2021-04-01T17:34:27Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NTA0NTYy",
          "commit": {
            "abbreviatedOid": "02936f1"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T17:40:42Z",
          "updatedAt": "2021-04-01T17:41:02Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Yes, true, well spotted. ",
              "createdAt": "2021-04-01T17:40:42Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NTE2OTc0",
          "commit": {
            "abbreviatedOid": "b115431"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T17:56:33Z",
          "updatedAt": "2021-04-01T17:56:34Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Sorry !\r\n\r\nhm, indeed, these are for the AKE.\r\n\r\n1. Should I reintroduce Kevin's `- DeriveKeyPair(seed): Derive a private and public key pair deterministically from a seed.` into the OPRF section?\r\n2. I suggest we call it `DeriveAkeKeyPair` to make it very explicit",
              "createdAt": "2021-04-01T17:56:33Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NTc1Mzc4",
          "commit": {
            "abbreviatedOid": "f017dc9"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T19:17:07Z",
          "updatedAt": "2021-04-01T19:17:07Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Done!",
              "createdAt": "2021-04-01T19:17:07Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NTc2NzE4",
          "commit": {
            "abbreviatedOid": "f017dc9"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T19:18:55Z",
          "updatedAt": "2021-04-01T19:18:55Z",
          "comments": [
            {
              "originalPosition": 671,
              "body": "external or internal?",
              "createdAt": "2021-04-01T19:18:55Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NjQzMTE5",
          "commit": {
            "abbreviatedOid": "83548ce"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T20:57:27Z",
          "updatedAt": "2021-04-01T20:57:28Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Hello \ud83d\udc4b\r\n\r\nThe key can be provided by the same application or the wrapper protocol. A usage example is when the same application needs the private key for some other use (with the internal mode, the private key never leaves the AKE). So it's not just for use with external applications.",
              "createdAt": "2021-04-01T20:57:27Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NjQ2NDE5",
          "commit": {
            "abbreviatedOid": "83548ce"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T21:02:27Z",
          "updatedAt": "2021-04-01T21:02:28Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "No, the server public MUST NOT be nil, it's the client's key that can be nil",
              "createdAt": "2021-04-01T21:02:28Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NjU3Mzc0",
          "commit": {
            "abbreviatedOid": "5dc41ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T21:21:13Z",
          "updatedAt": "2021-04-01T21:21:14Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "\ud83e\udd26 duh, yes, sorry. This only applies to the client. ",
              "createdAt": "2021-04-01T21:21:13Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2Njg5MTQy",
          "commit": {
            "abbreviatedOid": "952bd69"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T22:29:15Z",
          "updatedAt": "2021-04-01T22:29:16Z",
          "comments": [
            {
              "originalPosition": 671,
              "body": "It's only used in the internal mode, it makes total sense to define it there, yes.",
              "createdAt": "2021-04-01T22:29:15Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2OTM2NzQ4",
          "commit": {
            "abbreviatedOid": "004e9af"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-02T11:38:13Z",
          "updatedAt": "2021-04-02T11:38:13Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Does this answer your question? Happy to discuss if you don't agree :)",
              "createdAt": "2021-04-02T11:38:13Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NDI0NTg5",
          "commit": {
            "abbreviatedOid": "004e9af"
          },
          "author": "afbase",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-03T02:29:55Z",
          "updatedAt": "2021-04-03T02:29:56Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": ">A usage example is when the same application needs the private key for some other use (with the internal mode, the private key never leaves the AKE).\r\n\r\nThat is a lot clearer thank you @bytemare  !",
              "createdAt": "2021-04-03T02:29:56Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NTE1MzE5",
          "commit": {
            "abbreviatedOid": "004e9af"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-04T08:11:53Z",
          "updatedAt": "2021-04-04T08:11:54Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "Why is the length of the seed that is passed as input to DeriveAkeKeyPair of length `Nsk`?\r\n\r\nShouldn't it be `Nh`?\r\n\r\ncc: @chris-wood ",
              "createdAt": "2021-04-04T08:11:53Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NTE3OTc5",
          "commit": {
            "abbreviatedOid": "004e9af"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-04T08:49:44Z",
          "updatedAt": "2021-04-04T08:49:44Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "Yes, you're right !",
              "createdAt": "2021-04-04T08:49:44Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxNDE0NzM3",
          "commit": {
            "abbreviatedOid": "004e9af"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-08T13:45:55Z",
          "updatedAt": "2021-04-08T13:45:55Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "But you are right, this is a totally valid use case and we could include that example. Thanks!",
              "createdAt": "2021-04-08T13:45:55Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzMDgxMTg3",
          "commit": {
            "abbreviatedOid": "647fbee"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-12T01:18:02Z",
          "updatedAt": "2021-04-12T01:18:02Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Do you think that the following phrase\r\n\r\n> OPAQUE allows applications to either provide custom client private and public keys for authentication\r\n\r\ncovers your following use case not explicitly enough?\r\n\r\n> when a separate application(s) provide custom client private and public keys for authentication\r\n\r\nEven if provided by an external application, it is still the wrapper application that implements or integrates OPAQUE that will import the keys.",
              "createdAt": "2021-04-12T01:18:02Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1MDQ4Mjg4",
          "commit": {
            "abbreviatedOid": "c8085ef"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T21:38:28Z",
          "updatedAt": "2021-04-13T21:47:45Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "Add `This is nil in internal mode`",
              "createdAt": "2021-04-13T21:38:28Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 475,
              "body": "In external mode, implementations can be free to add the public key here. If added, then the public key doesn't have to be recovered in BuildInnerEnvelope() and the function must be adapted accordingly.\r\n\r\ncc @chris-wood ",
              "createdAt": "2021-04-13T21:47:37Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1MDk4ODEx",
          "commit": {
            "abbreviatedOid": "c8085ef"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T23:21:41Z",
          "updatedAt": "2021-04-13T23:21:41Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "ftr: reverting this change, as the amount of entropy in the seed should be no less than the amount of entropy in a private key",
              "createdAt": "2021-04-13T23:21:41Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MDM5MzM5",
          "commit": {
            "abbreviatedOid": "ee4cd5a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-14T20:12:26Z",
          "updatedAt": "2021-04-14T20:24:58Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Can we move this to the notation section above?",
              "createdAt": "2021-04-14T20:12:26Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 63,
              "body": "Can we call this \"Internal\" and \"External\", rather than \"Internal Key\" and \"External Key\"?",
              "createdAt": "2021-04-14T20:13:23Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nApplications may pin key material to identities if desired. If no identity is given for a party, its value MUST default to its public key. The following types of application credential information are hereby considered:\r\n```",
              "createdAt": "2021-04-14T20:14:01Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nThese credential values are used in the `CleartextCredentials` structure as follows:\r\n```",
              "createdAt": "2021-04-14T20:15:22Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nThe function CreateCleartextCredentials constructs a `CleartextCredentials` structure given application credential information.\r\n```",
              "createdAt": "2021-04-14T20:15:54Z",
              "updatedAt": "2021-04-14T23:48:42Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\nA client `Envelope` is constructed independently from the `EnvelopeMode`, but offers an `InnerEnvelope` entry whose structure is determined by the mode. Future modes MAY introduce alternate `InnerEnvelope` contents.\r\n```",
              "createdAt": "2021-04-14T20:17:12Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\nClients create an `Envelope` at registration with the function `CreateEnvelope` defined below.\r\n```",
              "createdAt": "2021-04-14T20:18:44Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 184,
              "body": "```suggestion\r\n- server_identity, The optional encoded server identity\r\n```",
              "createdAt": "2021-04-14T20:19:30Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 185,
              "body": "```suggestion\r\n- client_identity, The optional encoded client identity\r\n```",
              "createdAt": "2021-04-14T20:19:36Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 205,
              "body": "```suggestion\r\nClients recover their `Envelope` during authentication with the `RecoverEnvelope` function defined below.\r\n```",
              "createdAt": "2021-04-14T20:20:19Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 236,
              "body": "```suggestion\r\nThe `EnvelopeMode` specifies the structure and encoding of the corresponding `InnerEnvelope`. This document specifies the values of the two aformentioned modes:\r\n```",
              "createdAt": "2021-04-14T20:20:42Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 252,
              "body": "```suggestion\r\n- `client_private_key, client_public_key = RecoverKeys(prk, nonce, inner_env)`: recover and return the client's private and public keys for the AKE protocol.\r\n\r\nThe implementation of this interface for both `internal` and `external` modes is in {{internal-mode}} and {{external-mode}}, respectively.\r\n```",
              "createdAt": "2021-04-14T20:21:20Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 288,
              "body": "```suggestion\r\nHashToScalar(msg, dst) is as specified in {{I-D.irtf-cfrg-voprf}}, except that dst = \"OPAQUE-HashToScalar\".\r\n```",
              "createdAt": "2021-04-14T20:22:18Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 357,
              "body": "```suggestion\r\nIf the implementation provides the `client_public_key` to `CreateEnvelope()`, then `BuildInnerEnvelope()` MAY skip the `RecoverPublicKey()` call and use the public key provided.\r\n```",
              "createdAt": "2021-04-14T20:23:28Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            },
            {
              "originalPosition": 671,
              "body": "I'm not sure how I feel about this function here. It seems sort of out of place. But we can keep it now and move it around later.",
              "createdAt": "2021-04-14T20:24:54Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MTU5OTkz",
          "commit": {
            "abbreviatedOid": "ee4cd5a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-14T23:34:30Z",
          "updatedAt": "2021-04-14T23:34:30Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "I think it's `aforementioned` ! :)",
              "createdAt": "2021-04-14T23:34:30Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MTYxNDgx",
          "commit": {
            "abbreviatedOid": "ee4cd5a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-14T23:38:14Z",
          "updatedAt": "2021-04-14T23:38:15Z",
          "comments": [
            {
              "originalPosition": 357,
              "body": "`BuildInnerEnvelope()` doesn't need to use the public key",
              "createdAt": "2021-04-14T23:38:14Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MTYyNjUx",
          "commit": {
            "abbreviatedOid": "ee4cd5a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-14T23:41:11Z",
          "updatedAt": "2021-04-14T23:41:12Z",
          "comments": [
            {
              "originalPosition": 671,
              "body": "Should we move this to the _dependencies_ section?",
              "createdAt": "2021-04-14T23:41:11Z",
              "updatedAt": "2021-04-14T23:48:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 155,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg0MTYzODQx",
      "title": "Generalize all baked-in cryptographic algorithms.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/155",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Starting as a draft for now, since this does technically add more dependencies, but I think it's more future proof. \r\n\r\nOnce we agree on the contents here, I'll update the PoC to match. Note that this should not change any test vectors, but will in fact remove some!\r\n\r\nCloses #132.",
      "createdAt": "2021-03-03T18:09:49Z",
      "updatedAt": "2021-04-24T15:12:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "6012168b4e1093d7ae47081b64af0cc020334aa8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/add-kdf",
      "headRefOid": "0d93d4f20e5373a29a01d3e13935372f47b85e8f",
      "closedAt": "2021-03-10T16:31:42Z",
      "mergedAt": "2021-03-10T16:31:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d344e4f0062df1a4f54f674c3a1ff9147929ed5c"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "All vectors are good \u2714\ufe0f ",
          "createdAt": "2021-03-10T16:31:01Z",
          "updatedAt": "2021-03-10T16:31:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzMjU5Mjg1",
          "commit": {
            "abbreviatedOid": "b793b46"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T19:18:07Z",
          "updatedAt": "2021-03-03T19:18:07Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "why not argon2i?",
              "createdAt": "2021-03-03T19:18:07Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzMjc2MjY2",
          "commit": {
            "abbreviatedOid": "b793b46"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T19:38:28Z",
          "updatedAt": "2021-03-03T19:38:28Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "One can certainly use argon2i, but this document (right now) only uses scrypt. ",
              "createdAt": "2021-03-03T19:38:28Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNDEzNjk5",
          "commit": {
            "abbreviatedOid": "b793b46"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T22:33:43Z",
          "updatedAt": "2021-03-03T22:33:44Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "that is clear. my question was why?",
              "createdAt": "2021-03-03T22:33:43Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNTU1NDEy",
          "commit": {
            "abbreviatedOid": "b793b46"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T00:43:14Z",
          "updatedAt": "2021-03-04T00:43:14Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "This is not a great answer, but.... we can't properly cite Argon2i as it's [not yet an RFC](https://datatracker.ietf.org/doc/draft-irtf-cfrg-argon2/). (The same is true of the OPRF draft, but that's a dependency we can't workaround.) \r\n\r\nWe can certainly change this to argon2i, or whatever, provided there's a suitable reference and evidence that the new thing is more widely supported than scrypt. The purpose of this is to be a recommendation for applications should they not know what they're doing. ",
              "createdAt": "2021-03-04T00:43:14Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2ODI3OTUw",
          "commit": {
            "abbreviatedOid": "fe80401"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-09T00:24:03Z",
          "updatedAt": "2021-03-09T00:52:15Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This isn't really important, but if we name `Nh` after the hash length and `Nm` for the mac length, we might as well call this one `Ne` for the `Extract()` output length.",
              "createdAt": "2021-03-09T00:24:03Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 36,
              "body": "This seems a bit too generic.\r\n\r\nThe introductory phrase states\r\n> OPAQUE relies on the following protocols and primitives:\r\n\r\nSo I understand this block is a generic spec not pinning 3DH. It's true we rely on an AKE as a 'Cryptographic Protocol and Algorithm Dependency' here, so maybe we should define the 4 functions to handle 3-way messages? (e.g. start, response, finalize client, finalize server)",
              "createdAt": "2021-03-09T00:31:36Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 37,
              "body": "It can make sense to specify the necessary Group operations in 3DH.\r\nA \"3DH Group\" (or so) block could outline the necessary functions (e.g. KeyGen() for the ephemeral keys (or _GetRandomScalar()_ and _ScalarBaseMult()_ ) and ScalarMult() ).",
              "createdAt": "2021-03-09T00:51:53Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2ODY0NzAx",
          "commit": {
            "abbreviatedOid": "fe80401"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-09T01:50:10Z",
          "updatedAt": "2021-03-09T01:50:43Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "`Npk` and `Nsk`",
              "createdAt": "2021-03-09T01:50:10Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2ODc0NjMw",
          "commit": {
            "abbreviatedOid": "fe80401"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T02:14:56Z",
          "updatedAt": "2021-03-09T02:15:00Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "If XOF are accepted for the hash function, we should maybe state it and give the conditions of the length of Nh.",
              "createdAt": "2021-03-09T02:14:56Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2ODgyMzMy",
          "commit": {
            "abbreviatedOid": "fe80401"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good to me.\r\n\r\nI believe we also need to adjust the test vectors to include settings for Nm, Nl, Nh, etc. to be all equal to 32, so if you could add that before committing, that would be great!",
          "createdAt": "2021-03-09T02:33:54Z",
          "updatedAt": "2021-03-09T02:39:47Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: you reference `Nl` here, but it is defined below -- I'd say just remove the reference",
              "createdAt": "2021-03-09T02:33:55Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 21,
              "body": "nit: you reference `Nm` here, but it is defined below -- I'd say just remove the reference",
              "createdAt": "2021-03-09T02:34:17Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 26,
              "body": "nit: you reference `Nh` here, but it is defined below -- I'd say just remove the reference",
              "createdAt": "2021-03-09T02:34:41Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 36,
              "body": "@bytemare The problem is that there may be future AKEs that support 4-way (or more) messages, so I think even that API can't be specified here...",
              "createdAt": "2021-03-09T02:36:33Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 37,
              "body": "This would be 3DH-specific, though. Also, presumably we would reuse the corresponding functions in the OPRF bullet point for 3DH.",
              "createdAt": "2021-03-09T02:37:52Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2ODg1Mjk1",
          "commit": {
            "abbreviatedOid": "fe80401"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T02:41:34Z",
          "updatedAt": "2021-03-09T02:43:59Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I considered that, but `Ne` conflicts with the VOPRF terminology for \"size of Element\", so I went with `Nl`.",
              "createdAt": "2021-03-09T02:41:34Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 36,
              "body": "This is borrowed text, but I agree. We can change this to a prime-order group, specifically for 3DH. And the appendix can discuss how this might change if it's needed for other AKEs.",
              "createdAt": "2021-03-09T02:42:58Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 37,
              "body": "See above -- I'll just say we assume a prime-order group. That will help your internal/external PR, too, since I'll make HashToScalar a part of that interface. ",
              "createdAt": "2021-03-09T02:43:41Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 283,
              "body": "```suggestion\r\nand `Nsk`, respectively -- must adhere to an output length limitations of the KDF\r\n```",
              "createdAt": "2021-03-09T02:43:54Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            },
            {
              "originalPosition": 283,
              "body": "Good catch!",
              "createdAt": "2021-03-09T02:43:57Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3NzAzMDc1",
          "commit": {
            "abbreviatedOid": "7dbb85c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T17:58:15Z",
          "updatedAt": "2021-03-09T17:58:51Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "What if the VOPRF terminology changes to `Np` for \"size of Point\"?",
              "createdAt": "2021-03-09T17:58:15Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3NzI1OTY4",
          "commit": {
            "abbreviatedOid": "7dbb85c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T18:24:19Z",
          "updatedAt": "2021-03-09T18:24:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Point implies curve, which may not always be the case. :) ",
              "createdAt": "2021-03-09T18:24:19Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3NzMyOTQx",
          "commit": {
            "abbreviatedOid": "7dbb85c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T18:31:59Z",
          "updatedAt": "2021-03-09T18:31:59Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Good point!",
              "createdAt": "2021-03-09T18:31:59Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4MTMwMTk2",
          "commit": {
            "abbreviatedOid": "7dbb85c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T21:54:43Z",
          "updatedAt": "2021-03-09T21:54:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "For 3DH, should the \"running hash\" functions Write() and Sum() be specified ? Or should we not go into that much detail?",
              "createdAt": "2021-03-09T21:54:43Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4MTM0NjQx",
          "commit": {
            "abbreviatedOid": "7dbb85c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T21:56:39Z",
          "updatedAt": "2021-03-09T21:56:39Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "That's certainly too much detail, I think. Implementations can implement `Hash` with a streaming API or one-shot API. ",
              "createdAt": "2021-03-09T21:56:39Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4MjcyNjYw",
          "commit": {
            "abbreviatedOid": "7dbb85c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T02:10:28Z",
          "updatedAt": "2021-03-10T02:10:28Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is notation borrowed from the HPKE draft, so I'm inclined to keep it. We can always remove in a followup change!",
              "createdAt": "2021-03-10T02:10:28Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4Mjc2NjM1",
          "commit": {
            "abbreviatedOid": "678294a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T02:20:42Z",
          "updatedAt": "2021-03-10T02:20:42Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "That's a good point, and it's not clear to me what the minimum bound on `Nh`. I suggest we file an issue and track this for a future change. :) ",
              "createdAt": "2021-03-10T02:20:42Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4ODMzMTUx",
          "commit": {
            "abbreviatedOid": "9ffa0fd"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T15:19:10Z",
          "updatedAt": "2021-03-10T15:19:10Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "#158",
              "createdAt": "2021-03-10T15:19:10Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4ODMzMzYx",
          "commit": {
            "abbreviatedOid": "9ffa0fd"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-10T15:19:20Z",
          "updatedAt": "2021-03-10T15:19:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4ODczNDAx",
          "commit": {
            "abbreviatedOid": "9ffa0fd"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T15:53:08Z",
          "updatedAt": "2021-03-10T15:53:09Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Resurrecting this, at the risk of being annoying, but what do you think about `Nx`?",
              "createdAt": "2021-03-10T15:53:08Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4ODc3Mzg3",
          "commit": {
            "abbreviatedOid": "9ffa0fd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T15:56:33Z",
          "updatedAt": "2021-03-10T15:56:34Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Why that over `Nl`? ",
              "createdAt": "2021-03-10T15:56:33Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4ODg3NjA4",
          "commit": {
            "abbreviatedOid": "9ffa0fd"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T16:04:48Z",
          "updatedAt": "2021-03-10T16:04:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "isn't the second letter referring to the function name? if _e_ is already taken, _x_ refers more easily to \"extract\" than _l_",
              "createdAt": "2021-03-10T16:04:48Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4ODkxNjkx",
          "commit": {
            "abbreviatedOid": "9ffa0fd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-10T16:08:25Z",
          "updatedAt": "2021-03-10T16:08:25Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This is a pretty epic bike shed! I picked `l` for length. I do not care what we go with here.",
              "createdAt": "2021-03-10T16:08:25Z",
              "updatedAt": "2021-03-10T16:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5ODY2ODY1",
          "commit": {
            "abbreviatedOid": "0d93d4f"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T15:08:37Z",
          "updatedAt": "2021-03-11T15:08:38Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "@chris-wood I missed this. Why are we moving from a running hash to an Extract()?",
              "createdAt": "2021-03-11T15:08:38Z",
              "updatedAt": "2021-03-11T15:08:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5ODcwMTg3",
          "commit": {
            "abbreviatedOid": "0d93d4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T15:11:35Z",
          "updatedAt": "2021-03-11T15:11:35Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "I missed this too -- I meant to revert this to `Hash`. Can you file an issue (and send PR)? :) ",
              "createdAt": "2021-03-11T15:11:35Z",
              "updatedAt": "2021-03-11T15:11:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 156,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1MzQxOTc3",
      "title": "Addressing client enumeration section with protocol changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/156",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Introduces an `oprf_seed` parameter which must be generated during server setup and persisted across all registration/login requests (similar to `server_private_key`)\r\n- Introduces a `cred_identifier` parameter -- this could be the same as `client_identity`, but does not need to be\r\n- Derives `oprf_key` from `oprf_seed` and `cred_identifier` -- this results in altering `RegistrationResponse` and `CredentialResponse`\r\n- Modifies the \"Credential File\" section to just store the RegistrationUpload object, while making clear that the `oprf_seed` and `server_private_key` need to be kept around too\r\n- In `FinalizeRequest`, adds a new element `envelope_key` which must be stored as part of a `RegistrationUpload` object\r\n- Reverts the changes described in #120 (PR #126), necessary in order for the decryption step involving `envelope_key` to work properly\r\n- Introduces an `encryption_nonce` parameter, and steps for encrypting the envelope using `envelope_key`, in `CreateCredentialResponse`\r\n- Adds a new `FakeCredentialResponse` function\r\n- Introduces a new \"N\" parameter, `Nok` for representing the size of an OPRF key. Removes unused calls to `SerializeScalar` and `DeserializeScalar` from the VOPRF draft\r\n- Removes the text corresponding to the \"Client Enumeration\" section\r\n\r\nCloses #22.",
      "createdAt": "2021-03-05T05:52:05Z",
      "updatedAt": "2021-03-25T00:20:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2e018a1c0c24d75c639eac2b71db990bcc4d4415",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "client_enumeration",
      "headRefOid": "aba1fca8c3c5b65e7f205a2afa8523870e069891",
      "closedAt": "2021-03-24T21:49:29Z",
      "mergedAt": "2021-03-24T21:49:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a9c566d33cba27a54e065a7acfec4d67331ddf01"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Kevin, I can't say I did a thorough review but here are a few comments from a cursory reading. Nothing major.\r\n\r\n- the name envelope_key is too generic, there are too many envelope-related keys, how about enum_masking_key\r\n- till now, we only required the registration to go over authenticated channels, with the sending of the enum_masking_key we now need to explicitly assume authenticated and confidential channel (e.g., TLS)\r\n- In the derivation of prk, prk = HKDF-Extract(\"prk\", Harden(y, params)), replace \"prk\" (acting as salt) with 0 (as in HKDF-Extract(salt=0, IKM)). There is no real value-add in using a different string. A salt of zero is the indication that instead of an extractor you are assuming a random oracle. Domain separators (as \"prk\" can be thought of) are not part of HKDF-Extract but of HKDF-Expand (there is  good rationale behind that distinction)\r\n- The operations under FakeCredentialResponse need to be defined as closely to the \"real case\", particularly to avoid identifying the fake executions via side channels, particularly timing attacks. So instead of a random() in encrypted_response = random(Npk + Nsk + Nh + 33), l you may want to specify that the server generates encrypted_response as a fresh encryption of 0's using some dummy encryption key (even this can result in some timing difference if the encryption key is fixed leading to some optimizations). \r\n- Rationale for the enumeration-prevention measures. While you have now eliminated the text that proposed (and asked feedback for)  these measures, some of this text needs to stay to provide rationale (otherwise this whole thing looks \"suspicious). Moreover, the issue in the previous bullet (timing attacks) needs to be explained and implementations for which enumeration is a real threat need to take measures to do an as accurate as possible simulation of the real case.",
          "createdAt": "2021-03-07T05:03:41Z",
          "updatedAt": "2021-03-07T05:03:41Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "See my most recent comment on https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/22#issuecomment-792660335 -- I believe we should not make the changes I proposed to the protocol after all.",
          "createdAt": "2021-03-08T10:37:08Z",
          "updatedAt": "2021-03-08T10:37:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Nevermind about the previous comment for not making the changes -- after some clarification in #22 where we discussed the `oprf_key` doesn't need to be rotated upon re-registration of a user, I believe we can continue with these proposed changes.\r\n\r\nAddressed @hugokraw's comments:\r\n- renamed `envelope_key` to `masking_key`\r\n- clarified that registration now needs an authenticated and confidential channel\r\n- changed prk derivation to use salt=0 instead of salt=\"prk\"\r\n- mirrored the fake credential response function after the real one to prevent timing attacks\r\n- added a bunch of text into the Client Enumeration section (text copied below) -- @hugokraw please take a look at this when you get a chance!\r\n\r\n---------\r\n\r\n## Preventing Client Enumeration\r\n\r\nClient enumeration refers to attacks where the attacker tries to learn\r\nextra information about the behavior of clients that have registered with\r\nthe server. There are two types of attacks we consider:\r\n1) An attacker tries to learn whether a given client identity is registered\r\nwith a server, and\r\n2) An attacker tries to learn whether a given client identity has recently\r\ncompleted registration, or has re-registered (e.g. after a password change).\r\n\r\nPreventing the first type of attack requires the server to act with\r\nunregistered client identities in a way that is indistinguishable from its\r\nbehavior with existing registered clients. This is achieved in\r\n{{create-credential-response}} for an unregistered client by simulating a\r\nCredentialResponse for unregistered clients through the sampling of a\r\nrandom masking_key value and relying on the semantic security provided by\r\nthe XOR-based pad over the envelope.\r\n\r\nImplementations must employ care to avoid side-channel leakage (e.g.,\r\ntiming attacks) from helping differentiate these operations from a regular\r\nserver response.\r\n\r\nPreventing the second type of attack requires the server to supply a\r\ncred_identifier value for a given client identity, consistently between the\r\n{{create-reg-response}} and {{create-credential-response}} steps.\r\nNote that cred_identifier can be set to client_identity, for simplicity.\r\n\r\nIn the event of a server compromise that results in a re-registration of\r\ncredentials for all compromised clients, the oprf_seed value must be resampled,\r\nresulting in a change in the oprf_key value for each client. Although this\r\nchange can be detected by an adversary, it is only leaked upon password rotation\r\nafter the exposure of the credential files.",
          "createdAt": "2021-03-09T10:50:04Z",
          "updatedAt": "2021-03-09T10:51:01Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The essential difference between the two attacks is that to address the first one the protocol needs not change. The defense against this attack is achieved via server-side implementations that do not impact the client side. The second attack does require a change in the form of the masking of the envelope. However, **it is important to note** (and this addresses some of @kevinlewi concerns), that once we include the masking technique, the server is free to apply or not apply the defenses we describe. For example, an application where user enumeration is not an issue can ignore the deterministic derivation of oprf_key from the user's identifier and could generate a fresh independent oprf_key with each registration. You may want to comment on this as the need for deterministic derivation and rotation of oprf_seed may be seen as added complexity for those that don't need such defense. They would still be doing the envelope masking since it is now part of the protocol and not just an optional element. The important thing is that the deterministic derivation with oprf_seed is only needed to defend  against attack 2 but has no other security implication. ",
          "createdAt": "2021-03-09T18:50:30Z",
          "updatedAt": "2021-03-09T18:50:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> why is confidentiality required?\r\n\r\nI assume you are asking about the need for a confidential channel during registration. This is because the (secret) masking_key needs to be sent from client to server (before, we only needed an authenticated channel). In most cases, if you have an authenticated channel (e.g. TLS) then you have a confidential one too (in particular, you can always upgrade authenticated to confidential by sending a public key over the authenticated channel)",
          "createdAt": "2021-03-09T18:54:40Z",
          "updatedAt": "2021-03-09T18:54:40Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "One more comment on the user enumeration defenses:\r\nI assume that given that you want to minimize options and security decisions by implementers/applications, you will not want to do the following. But \"for the record\", one could specify OPAQUE without talking about enumeration attacks and use of oprf_seed and instead use oprf_key as values chosen with each registration. Then, you would have a section dedicated to Defenses against User Enumeration attacks in which you would say that applications that are concerned with such attacks, can address them via the FakeCredentialResponse mechanism that you would specify specifically for this case.\r\n(Note that envelope masking will always be implemented hence _leaving the defense against user enumeration as a server-side implementation choice._)",
          "createdAt": "2021-03-09T19:18:09Z",
          "updatedAt": "2021-03-09T19:18:09Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw makes sense. Yes, as you guessed, I think we are leaning towards reducing the number of security decisions that applications would need to make.\r\n\r\nAre you saying that you would like to have text added to the current doc that specifically clarifies the flexibility of the server in choosing or not choosing to use the \"FakeCredentialResponse\" mechanism? I believe that this is already inherent/implied, since a server can simply return \"FAIL\" rather than bother with running FakeCredentialResponse, and so my vote is to not add this text since it is unnecessary. But, happy to add something if you feel like we should add the clarification.",
          "createdAt": "2021-03-09T20:46:50Z",
          "updatedAt": "2021-03-09T20:46:50Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "It may be worth having language saying that other than envelope masking, which is part of the basic protocol and a must-to-have for interoperability, the rest of FakeCredentialResponse (such as the use of oprf_seed) becomes a pure server-side implementation decision. ",
          "createdAt": "2021-03-10T00:02:52Z",
          "updatedAt": "2021-03-10T00:02:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Could the IETF/CFRG impose on the server to implement  FakeCredentialResponse for standard-compliance even though it is not needed for interoperability? In principle, such compliance could be tested by simulating a user enumeration attacker.   But I doubt it is something IETF would mandate. What do you think?",
          "createdAt": "2021-03-10T00:03:34Z",
          "updatedAt": "2021-03-10T00:03:34Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased, added DeriveKeyPair reference, and added the following optional text to the end of the Client Enumeration section:\r\n\r\n> Finally, note that server implementations may choose to forego the construction\r\nof a simulated credential response message for an unregistered client if these client\r\nenumeration attacks can be mitigated through other application-specific means.",
          "createdAt": "2021-03-11T08:44:45Z",
          "updatedAt": "2021-03-11T08:44:45Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed above comments. Also changed the use of \"CredentialResponsePad\" literal string to use encryption_nonce instead.",
          "createdAt": "2021-03-23T03:54:50Z",
          "updatedAt": "2021-03-23T03:54:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed names:\r\n- `encryption_nonce` -> `masking_nonce`\r\n- `encrypted_response` -> `masked_response`",
          "createdAt": "2021-03-23T18:19:57Z",
          "updatedAt": "2021-03-23T18:19:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5MTM5NzE0",
          "commit": {
            "abbreviatedOid": "4a56e37"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> @chris-wood Could the IETF/CFRG impose on the server to implement FakeCredentialResponse for standard-compliance even though it is not needed for interoperability? In principle, such compliance could be tested by simulating a user enumeration attacker. But I doubt it is something IETF would mandate. What do you think?\r\n\r\nWell, we can certainly say that servers MUST implement the protocol this way to achieve the desired security properties. (This is akin, in my view, to saying that servers MUST choose ephemeral TLS key shares for connections, but some may choose to reuse them.) Whether or not implementations follow the requirement is up to them. :-)",
          "createdAt": "2021-03-10T20:32:14Z",
          "updatedAt": "2021-03-10T20:38:37Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I don't think this is a workable replacement. This basically type casts bytes to an OPRF private key. I think we should revert this, and instead use DeriveKeyPair(HKDF(...)).",
              "createdAt": "2021-03-10T20:32:14Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5NTEyNDQ0",
          "commit": {
            "abbreviatedOid": "ccf45ee"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T08:45:25Z",
          "updatedAt": "2021-03-11T08:45:25Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Addressed in the latest push",
              "createdAt": "2021-03-11T08:45:25Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEyNTMxODY5",
          "commit": {
            "abbreviatedOid": "ccf45ee"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-15T18:42:23Z",
          "updatedAt": "2021-03-15T22:10:31Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "\"credential_file _argument_\"",
              "createdAt": "2021-03-15T18:42:24Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 237,
              "body": "#157 : \"CredentialResponsePad\" ;)",
              "createdAt": "2021-03-15T21:07:47Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MDAzNzUy",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-22T21:38:22Z",
          "updatedAt": "2021-03-23T01:20:02Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This is part of the OPRF API, right? Why not move it up?",
              "createdAt": "2021-03-22T21:38:22Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 45,
              "body": "Is it required that the same seed be used across all users?",
              "createdAt": "2021-03-22T21:41:21Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 167,
              "body": "This is now a bit of an orphan section. Should we just fold the contents here into the preceding section?",
              "createdAt": "2021-03-22T21:43:40Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 168,
              "body": "Should we say that the credential file also stores the credential identifier? Or at least has a pointer to it? ",
              "createdAt": "2021-03-22T21:45:19Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 207,
              "body": "```suggestion\r\nIn the case of an existing credential_file record with the corresponding identifier `credential_identifier`, the server invokes the following function to\r\n```",
              "createdAt": "2021-03-22T21:45:39Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 195,
              "body": "Is this missing `encryption_nonce`?",
              "createdAt": "2021-03-22T23:24:03Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 268,
              "body": "```suggestion\r\n4. credential_response_pad = Expand(masking_key,\r\n```",
              "createdAt": "2021-03-22T23:36:04Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n1. (oprf_key, _) = DeriveKeyPair(Expand(oprf_seed, concat(\"OPRFKey\", credential_identifier), Nok))\r\n```\r\nFor case consistency?",
              "createdAt": "2021-03-23T00:17:08Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MTIwOTY4",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T02:07:02Z",
          "updatedAt": "2021-03-23T02:07:03Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "It does not have to be one seed for all. For example, there could be a seed for all userid's that start with letter a, one for those that start with letter b, etc. But a userid should always use the same oprf seed. A change of seed can only happen at re-registration.",
              "createdAt": "2021-03-23T02:07:03Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MTc0MDIx",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T03:22:44Z",
          "updatedAt": "2021-03-23T03:22:44Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Yes, it is. Can you clarify what you mean by \"move it up\"? It is already under the OPRF section -- do you mean to move it up in front of `Blind(x)`, `Evaluate(k, M)`, etc?",
              "createdAt": "2021-03-23T03:22:44Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MTc0NzAy",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T03:24:41Z",
          "updatedAt": "2021-03-23T03:24:41Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@chris-wood: How should we allow for the flexibility in this API, in terms of producing test vectors, etc. ? Does it suffice to just add a note here saying that multiple oprf_seeds can be used?",
              "createdAt": "2021-03-23T03:24:41Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MTc1MTI1",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T03:25:50Z",
          "updatedAt": "2021-03-23T03:25:51Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I don't think that's necessary. In the same way we don't mention the storing of any user or server identifiers when CustomIdentifier mode is used, I don't think we need to mention that the credential file has to store the credential identifier. But we can add it too if you think it increases clarity",
              "createdAt": "2021-03-23T03:25:50Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MTc4ODg1",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T03:36:44Z",
          "updatedAt": "2021-03-23T03:36:45Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Folded!",
              "createdAt": "2021-03-23T03:36:44Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MTgxOTQ2",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T03:46:07Z",
          "updatedAt": "2021-03-23T03:46:07Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "It is. Thanks for the catch -- added!",
              "createdAt": "2021-03-23T03:46:07Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MTgzMzEx",
          "commit": {
            "abbreviatedOid": "1678296"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T03:50:30Z",
          "updatedAt": "2021-03-23T03:50:30Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Thanks, used \"OprfKey\" here instead, following the usual convention of CamelCase for acronyms that are longer than 2 letters.",
              "createdAt": "2021-03-23T03:50:30Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4OTQ4NzMz",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T18:43:08Z",
          "updatedAt": "2021-03-23T18:43:09Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Yep! If it's an OPRF API, it should be in the same list as Blind() etc.",
              "createdAt": "2021-03-23T18:43:08Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4OTQ5MTgy",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T18:43:39Z",
          "updatedAt": "2021-03-23T18:43:39Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yeah, I think noting that multiple seeds may be used is sufficient, but the test vectors should just use one seed for all users.",
              "createdAt": "2021-03-23T18:43:39Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4OTUwMDI4",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T18:44:36Z",
          "updatedAt": "2021-03-23T18:44:37Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I'm mainly interested in reducing the number of parameters to our core functions, which is growing little by little. We can keep this as-is for now, but we should keep this possible change on the back burner.",
              "createdAt": "2021-03-23T18:44:36Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4OTU0NTk0",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T18:49:47Z",
          "updatedAt": "2021-03-23T18:49:47Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I guess what I am saying is, it is **already** in the same list as Blind() etc... unless I am misinterpreting what you are saying?",
              "createdAt": "2021-03-23T18:49:47Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4OTU2NTcz",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T18:52:04Z",
          "updatedAt": "2021-03-23T18:52:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "It's in a separate list, like the KDF and other functions below.",
              "createdAt": "2021-03-23T18:52:04Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4OTU5NjE0",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T18:55:29Z",
          "updatedAt": "2021-03-23T18:55:29Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "OH I see what you mean -- I thought you were referring to the `Nok` parameter as needing to move up. But now I realize that you are referring to `DeriveKeyPair` being needed to move up. Got it! :) The comment line numbers this points to was a bit ambiguous :)",
              "createdAt": "2021-03-23T18:55:29Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MDA1MTIx",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T19:50:17Z",
          "updatedAt": "2021-03-23T19:50:18Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ah, yep :) Sorry, I should have been more clear.",
              "createdAt": "2021-03-23T19:50:17Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MTQxODE0",
          "commit": {
            "abbreviatedOid": "bc5f1c1"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T22:33:54Z",
          "updatedAt": "2021-03-23T22:33:54Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Added a side note that multiple seeds can be used",
              "createdAt": "2021-03-23T22:33:54Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MTQyMzY1",
          "commit": {
            "abbreviatedOid": "fe37df6"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-23T22:34:54Z",
          "updatedAt": "2021-03-23T22:34:55Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This should be resolved in the latest diff.",
              "createdAt": "2021-03-23T22:34:55Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjI5OTQz",
          "commit": {
            "abbreviatedOid": "fe37df6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo some final nits!",
          "createdAt": "2021-03-24T21:04:35Z",
          "updatedAt": "2021-03-24T21:11:02Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Where does `credential_identifier` come from? It should probably be included in the Server inputs on L419.",
              "createdAt": "2021-03-24T21:04:35Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 99,
              "body": "```suggestion\r\n: A key used by the server to preserve confidentiality of the envelope during login\r\n```",
              "createdAt": "2021-03-24T21:05:00Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\n3. prk = Extract(\"\", Harden(y, params))\r\n```",
              "createdAt": "2021-03-24T21:06:23Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 249,
              "body": "```suggestion\r\n- record, an instance of RegistrationUpload which is the server's\r\n```",
              "createdAt": "2021-03-24T21:08:30Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            },
            {
              "originalPosition": 249,
              "body": "(here and elsewhere, since we refer to the element of this type as `record` in the FinalizeRequest function.)",
              "createdAt": "2021-03-24T21:09:12Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjM5MDMy",
          "commit": {
            "abbreviatedOid": "fe37df6"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T21:17:19Z",
          "updatedAt": "2021-03-24T21:17:19Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Added!",
              "createdAt": "2021-03-24T21:17:19Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjQzMTk1",
          "commit": {
            "abbreviatedOid": "fe37df6"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T21:23:08Z",
          "updatedAt": "2021-03-24T21:23:08Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "Done!",
              "createdAt": "2021-03-24T21:23:08Z",
              "updatedAt": "2021-03-24T21:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjQzOTA4",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T21:24:14Z",
          "updatedAt": "2021-03-24T21:24:14Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Cool, also changed the salt=0 instance to \"\" in the \"OPAQUE-3DH Key Schedule\" section",
              "createdAt": "2021-03-24T21:24:14Z",
              "updatedAt": "2021-03-24T21:24:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjYwMjQ2",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T21:49:23Z",
          "updatedAt": "2021-03-24T21:49:24Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Actually, it is better to set the salt to 0. It does not have to be described as salt=0 but just 0 (instead of \"\"). In principle, any fixed salt value can do, but I prefer to see 0 being used as the default \"fixed value\". In particular, 0 is used in TLS 1.3 key derivation when a random value for salt is not available and here we want to stay as close as possible to TLS 1.3 key derivation.",
              "createdAt": "2021-03-24T21:49:23Z",
              "updatedAt": "2021-03-24T21:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjY0NjY0",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T21:56:33Z",
          "updatedAt": "2021-03-24T21:56:33Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "For what it's worth, \"\" is the notation used in TLS for zero-length strings, which is what we want here, I think.",
              "createdAt": "2021-03-24T21:56:33Z",
              "updatedAt": "2021-03-24T21:56:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjk2MzY0",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T22:56:37Z",
          "updatedAt": "2021-03-24T22:56:37Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "What is the meaning of 0 in the following TLS 1.3 figure. Is it the value 0 or a 0-length string?\r\n             0\r\n             |\r\n             v\r\n   PSK ->  HKDF-Extract = Early Secret",
              "createdAt": "2021-03-24T22:56:37Z",
              "updatedAt": "2021-03-24T22:56:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjk2ODEw",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T22:57:35Z",
          "updatedAt": "2021-03-24T22:57:36Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Actually I see the answer: \"0\" indicates a string of Hash.length bytes set to zero.\r\n\r\nWe should specify the same here.",
              "createdAt": "2021-03-24T22:57:35Z",
              "updatedAt": "2021-03-24T22:57:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjk2OTU0",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T22:57:56Z",
          "updatedAt": "2021-03-24T22:57:56Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "That's a zero-length string (or NULL, or the equivalent of providing no salt at all), but I was referring to \"\" used elsewhere where context strings.",
              "createdAt": "2021-03-24T22:57:56Z",
              "updatedAt": "2021-03-24T22:57:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjk4MDI3",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T23:00:08Z",
          "updatedAt": "2021-03-24T23:00:08Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "> Actually I see the answer: \"0\" indicates a string of Hash.length bytes set to zero.\r\n\r\nI'm not sure this is best, since the KDF might not be HKDF (and therefore have an implied hash function underneath). I think nil/\"\"/0/whatever are equivalent, and \"\" seems to be most clear (to me) and consistent with 8446.",
              "createdAt": "2021-03-24T23:00:08Z",
              "updatedAt": "2021-03-24T23:00:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzMwNzI2",
          "commit": {
            "abbreviatedOid": "aba1fca"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-25T00:20:24Z",
          "updatedAt": "2021-03-25T00:20:24Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Good point. If we are treating the KDF as a general Extract-then-Expand primitive then we cannot say \"a string of Hash.length bytes set to zero\" but we also cannot say the empty string as it may not make sense in some other KDF. If you want to be generic, then you should refer to this salt value as a \"constant\" (as opposed to a random one), maybe call it const_salt and set it to \"a string of Hash.length bytes set to zero\" in the case of HKDF.",
              "createdAt": "2021-03-25T00:20:24Z",
              "updatedAt": "2021-03-25T00:20:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkwOTQ5MTU4",
      "title": "Revert AKE MAC pre-hashing back to HASH()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/162",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @chris-wood ",
      "createdAt": "2021-03-11T15:23:14Z",
      "updatedAt": "2021-03-11T20:05:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d344e4f0062df1a4f54f674c3a1ff9147929ed5c",
      "headRepository": null,
      "headRefName": "patch-2",
      "headRefOid": "056a6c367d5d90db008e5f1e819d9a034a7f1afa",
      "closedAt": "2021-03-11T20:05:37Z",
      "mergedAt": "2021-03-11T20:05:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2e018a1c0c24d75c639eac2b71db990bcc4d4415"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEwMTc2OTgw",
          "commit": {
            "abbreviatedOid": "265e679"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T20:05:11Z",
          "updatedAt": "2021-03-11T20:05:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n- KE2.mac = MAC(Km2, Hash(concat(preamble, KE2.enc_server_info)), where\r\n```",
              "createdAt": "2021-03-11T20:05:11Z",
              "updatedAt": "2021-03-11T20:05:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEwMTc3MTY1",
          "commit": {
            "abbreviatedOid": "265e679"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-11T20:05:23Z",
          "updatedAt": "2021-03-11T20:05:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n- KE3.mac = MAC(Km3, Hash(concat(preamble, KE2.enc_server_info, KE2.mac)),\r\n```",
              "createdAt": "2021-03-11T20:05:23Z",
              "updatedAt": "2021-03-11T20:05:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5MTY4MTA3",
      "title": "Implement client enumeration fix.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/164",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on changes in #156.",
      "createdAt": "2021-03-23T20:36:53Z",
      "updatedAt": "2021-04-24T15:12:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a9c566d33cba27a54e065a7acfec4d67331ddf01",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/client-enumeration",
      "headRefOid": "69e7cd7ead354fb0a7524f7ca8e9df42af31ff12",
      "closedAt": "2021-03-24T22:03:00Z",
      "mergedAt": "2021-03-24T22:03:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "40f2784b521eba1c0e4a5a1b0fa34b12b88e4b5e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MjU5MDQw",
          "commit": {
            "abbreviatedOid": "2cf2ddf"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-24T02:35:14Z",
          "updatedAt": "2021-03-24T02:35:48Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I believe this should be `Nh` (length of the hash output) bytes long, because `oprf_seed` is fed into the KDF's expand function.",
              "createdAt": "2021-03-24T02:35:14Z",
              "updatedAt": "2021-03-24T21:53:15Z"
            },
            {
              "originalPosition": 46,
              "body": "same here",
              "createdAt": "2021-03-24T02:35:31Z",
              "updatedAt": "2021-03-24T21:53:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMjY3ODUx",
          "commit": {
            "abbreviatedOid": "69e7cd7"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We can consider re-adding the N* parameters back in at some point",
          "createdAt": "2021-03-24T22:01:46Z",
          "updatedAt": "2021-03-24T22:01:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2NjU1NDI2",
      "title": "Implement internal and external mode.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/168",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Implements #154. Starting as a draft while we work through interop.",
      "createdAt": "2021-04-01T01:10:02Z",
      "updatedAt": "2021-04-24T15:12:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "40f2784b521eba1c0e4a5a1b0fa34b12b88e4b5e",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/internal-external",
      "headRefOid": "09e8fc5634873ed6349ca178b19545d63749b707",
      "closedAt": "2021-04-15T13:26:30Z",
      "mergedAt": "2021-04-15T13:26:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7c3e8d5652b0cd10f981bdd52cce51a97b730a44"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Something quite peculiar: P384 and P512 in the internal mode only have a public key in the registration upload vectors that doesn't correspond to either the client public key vector (that is false anyway) and the recovered public key from the password.\r\n\r\nIn all other vectors, the public key in the registration upload is correct.\r\n\r\nEdit: that was because I wasn't using the right seed expansion length for these two groups.",
          "createdAt": "2021-04-06T21:50:59Z",
          "updatedAt": "2021-04-15T17:20:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NTI1MDQ5",
          "commit": {
            "abbreviatedOid": "5131d32"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-04T10:22:11Z",
          "updatedAt": "2021-04-04T10:22:11Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "auth_tag needs to be computed over the mode and the nonce as well, not just the inner_env and cleartext_creds",
              "createdAt": "2021-04-04T10:22:11Z",
              "updatedAt": "2021-04-13T00:11:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NTcwOTEy",
          "commit": {
            "abbreviatedOid": "5131d32"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-04T20:37:11Z",
          "updatedAt": "2021-04-04T20:37:12Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "One problem: when these are derived from the randomized_pwd seed, these are no longer inputs -- they are intermediate values. In particular, I don't think these were updated as their corresponding values when derived from the randomized_pwd seed, and so they end up not matching...",
              "createdAt": "2021-04-04T20:37:12Z",
              "updatedAt": "2021-04-13T00:11:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5MTc3MDM3",
          "commit": {
            "abbreviatedOid": "5131d32"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-04-06T16:28:49Z",
          "updatedAt": "2021-04-06T16:30:30Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "We're dropping `SecretCredentials` and encrypt `client_private_key` directly",
              "createdAt": "2021-04-06T16:28:49Z",
              "updatedAt": "2021-04-13T00:11:15Z"
            },
            {
              "originalPosition": 108,
              "body": "Agreed, that's where the vectors don't match :)",
              "createdAt": "2021-04-06T16:30:05Z",
              "updatedAt": "2021-04-13T00:11:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5NDM1ODg2",
          "commit": {
            "abbreviatedOid": "5131d32"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-06T21:46:31Z",
          "updatedAt": "2021-04-06T21:46:32Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "I confirm",
              "createdAt": "2021-04-06T21:46:31Z",
              "updatedAt": "2021-04-13T00:11:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5OTk4Mzk3",
      "title": "patch secret creds and auth_tag",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/170",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-06T16:40:00Z",
      "updatedAt": "2021-04-12T21:39:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "caw/internal-external",
      "baseRefOid": "5131d32ee8185ca656a331e6fb1b163851a0093d",
      "headRepository": null,
      "headRefName": "patch-3",
      "headRefOid": "8ae6351da25cb1be55cb40ff32791ac0fb59dd43",
      "closedAt": "2021-04-12T21:39:05Z",
      "mergedAt": "2021-04-12T21:39:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4a0f3f48e90cf82b38140b3107532ba9b3dc8521"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\u2764\ufe0f ",
          "createdAt": "2021-04-12T21:39:01Z",
          "updatedAt": "2021-04-12T21:39:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzOTg3OTkx",
          "commit": {
            "abbreviatedOid": "8ae6351"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-12T21:38:56Z",
          "updatedAt": "2021-04-12T21:38:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEzMTc2OTA2",
      "title": "Update the OPAQUE-3DH Instantiation section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/172",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "- Added protocol compilation at login\r\n- interface for main API\r\n- high level composition of credential recovery and AKE\r\n- Write out various functions\r\n- Introduce RandomPrivateKey() to create a fresh key for EDH\r\n- Move to CamelCase and space-less magic strings\r\n- Clean-up leftover mishaps",
      "createdAt": "2021-04-12T00:15:55Z",
      "updatedAt": "2021-04-21T14:43:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4f147815162327daefbcb61e3ae9d669951cdecd",
      "headRepository": null,
      "headRefName": "ake-rewrite",
      "headRefOid": "d3691fd3230b0ff64d40548f00370619102e85c5",
      "closedAt": "2021-04-21T14:43:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to merging bug. Transferred to #193 ",
          "createdAt": "2021-04-21T14:43:38Z",
          "updatedAt": "2021-04-21T14:43:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2OTQ4NzAx",
          "commit": {
            "abbreviatedOid": "9ec6413"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "First pass complete. Looking good!",
          "createdAt": "2021-04-15T17:26:53Z",
          "updatedAt": "2021-04-15T18:18:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-04-15T17:26:53Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 19,
              "body": "Do we need the \"OPAQUE\" prefix for these functions? This is part of the OPAQUE spec, so that seems implied. Perhaps just `ClientInit`, `ServerInit`, `ClientFinish`, and `ServerFinish`?",
              "createdAt": "2021-04-15T17:28:23Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nThe `ke1`, `ke2`, and `ke3` output values are the protocol messages sent between client and server.\r\n```",
              "createdAt": "2021-04-15T17:59:04Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 34,
              "body": "The function names in this paragraph seem outdated?",
              "createdAt": "2021-04-15T18:00:14Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 37,
              "body": "Since these are internal values, perhaps we can hide them under a \"client_state\" and \"server_state\" structure? Otherwise, APIs might be tempted to export them for applications to use.",
              "createdAt": "2021-04-15T18:00:56Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 101,
              "body": "As above, I would recommend folding all this into a \"state\" or \"context\" object.",
              "createdAt": "2021-04-15T18:06:47Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n- server_identity, the optional encoded server identity, which is set to its public key if nil\r\n```",
              "createdAt": "2021-04-15T18:07:04Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\nServers MUST NOT use `session_key` unless `OPAQUEServerFinalize` returns `true`.\r\n```",
              "createdAt": "2021-04-15T18:07:48Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 140,
              "body": "Make this a state/context object, too?",
              "createdAt": "2021-04-15T18:08:07Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 197,
              "body": "Should we reference the dependencies section, where this is specified?",
              "createdAt": "2021-04-15T18:09:10Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 330,
              "body": "Maybe we can add \"GenerateKeyPair\" to the AKE dependency? For example:\r\n\r\n```\r\nGenerateKeyPair(): Return a randomly generate private and public key pair. This\r\ncan be implemented by generating a random private key `sk` and then computing\r\n`pk = RecoverPublicKey(sk)`.\r\n```",
              "createdAt": "2021-04-15T18:11:11Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 331,
              "body": "`ephemeral_client_secret_key` is undefined?",
              "createdAt": "2021-04-15T18:11:18Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 213,
              "body": "The \"AKE\" prefix is missing here. I think it reads better without it, so maybe we drop \"AKE\" elsewhere?",
              "createdAt": "2021-04-15T18:12:20Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 446,
              "body": "```suggestion\r\n```\r\n\r\nThis should just go in the AKE dependency section, I think. (See my comment above about GenerateKeyPair.)",
              "createdAt": "2021-04-15T18:16:35Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            },
            {
              "originalPosition": 449,
              "body": "Can we use the same function for both client and server here? In my implementation, that's what I do.",
              "createdAt": "2021-04-15T18:16:53Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MTc5NjAy",
          "commit": {
            "abbreviatedOid": "1800f32"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-15T22:33:31Z",
          "updatedAt": "2021-04-15T22:33:31Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "No, and I wanted to discuss that. I like your suggestions, let's do it this way.",
              "createdAt": "2021-04-15T22:33:31Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MTgxMDQy",
          "commit": {
            "abbreviatedOid": "1800f32"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-15T22:36:41Z",
          "updatedAt": "2021-04-15T22:36:41Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "Yes, let's drop it",
              "createdAt": "2021-04-15T22:36:41Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjA0ODkx",
          "commit": {
            "abbreviatedOid": "1800f32"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-15T23:02:21Z",
          "updatedAt": "2021-04-15T23:02:22Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "Maybe this phrase is not even necessary, we could drop it",
              "createdAt": "2021-04-15T23:02:21Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjIwNTg5",
          "commit": {
            "abbreviatedOid": "1800f32"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-15T23:41:56Z",
          "updatedAt": "2021-04-15T23:41:56Z",
          "comments": [
            {
              "originalPosition": 331,
              "body": "it's `client_secret`, of course \ud83e\udd26 ",
              "createdAt": "2021-04-15T23:41:56Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjIxMDg1",
          "commit": {
            "abbreviatedOid": "1800f32"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-15T23:43:14Z",
          "updatedAt": "2021-04-15T23:43:14Z",
          "comments": [
            {
              "originalPosition": 446,
              "body": "Will do after rebase",
              "createdAt": "2021-04-15T23:43:14Z",
              "updatedAt": "2021-04-20T23:38:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE2MTU2NDQ1",
      "title": "Apply various editorial changes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/174",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #165, #159, and #157.",
      "createdAt": "2021-04-15T15:38:30Z",
      "updatedAt": "2021-04-24T15:12:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7c3e8d5652b0cd10f981bdd52cce51a97b730a44",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/editorial-changes",
      "headRefOid": "65d72ae0222dd8777d20e8e97aa8dfea8a549684",
      "closedAt": "2021-04-15T23:49:09Z",
      "mergedAt": "2021-04-15T23:49:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ff5ec6e9348f801b00f80287fd13f1d747cb9082"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Vectors check out \u2705 ",
          "createdAt": "2021-04-15T22:26:25Z",
          "updatedAt": "2021-04-15T22:26:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE3MTk5NDQ5",
      "title": "Clarify hash function requirements.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/175",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Closes #158.",
      "createdAt": "2021-04-16T23:59:06Z",
      "updatedAt": "2021-04-24T15:12:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ff5ec6e9348f801b00f80287fd13f1d747cb9082",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hash-dependencies",
      "headRefOid": "6d57454737e47170ddb8b97f8bd6982f9e3a24ed",
      "closedAt": "2021-04-21T14:12:48Z",
      "mergedAt": "2021-04-21T14:12:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9a3fc970ce709492858e614b7af3e54da6b74da6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MTQzMTE5",
          "commit": {
            "abbreviatedOid": "a21e56a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T23:59:44Z",
          "updatedAt": "2021-04-16T23:59:45Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "This is the main change.",
              "createdAt": "2021-04-16T23:59:44Z",
              "updatedAt": "2021-04-20T23:52:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MTQzMTU3",
          "commit": {
            "abbreviatedOid": "a21e56a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T23:59:58Z",
          "updatedAt": "2021-04-16T23:59:58Z",
          "comments": [
            {
              "originalPosition": 253,
              "body": "This is the second part of this change.",
              "createdAt": "2021-04-16T23:59:58Z",
              "updatedAt": "2021-04-20T23:52:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwNDc5NTUw",
          "commit": {
            "abbreviatedOid": "a21e56a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-20T22:41:10Z",
          "updatedAt": "2021-04-20T22:41:28Z",
          "comments": [
            {
              "originalPosition": 253,
              "body": "What is `security parameter` referring to?",
              "createdAt": "2021-04-20T22:41:10Z",
              "updatedAt": "2021-04-20T23:52:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwNTE3ODk3",
          "commit": {
            "abbreviatedOid": "a21e56a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-20T23:52:28Z",
          "updatedAt": "2021-04-20T23:52:29Z",
          "comments": [
            {
              "originalPosition": 253,
              "body": "```suggestion\r\n  if the target security parameter for the configuration is 128-bits, then `Nh` SHOULD be at least 32 bytes.\r\n```",
              "createdAt": "2021-04-20T23:52:29Z",
              "updatedAt": "2021-04-20T23:52:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwNTE4MTM1",
          "commit": {
            "abbreviatedOid": "a21e56a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-20T23:53:07Z",
          "updatedAt": "2021-04-20T23:53:07Z",
          "comments": [
            {
              "originalPosition": 253,
              "body": "Clarified that it's the target security parameter for the OPAQUE configuration. We're not (yet) crisp about that, but we can always expand on that later.",
              "createdAt": "2021-04-20T23:53:07Z",
              "updatedAt": "2021-04-20T23:53:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwOTIwMTIw",
          "commit": {
            "abbreviatedOid": "6d57454"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-21T10:45:01Z",
          "updatedAt": "2021-04-21T10:45:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4NjY0MTMx",
      "title": "Put client_public_key in intermediate test values for all modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/178",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #176",
      "createdAt": "2021-04-19T22:51:44Z",
      "updatedAt": "2021-04-24T15:12:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ff5ec6e9348f801b00f80287fd13f1d747cb9082",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/intermiate-pkc",
      "headRefOid": "4621f1ee4be0c71e90b299d4b300d34ecdd05e88",
      "closedAt": "2021-04-20T14:30:48Z",
      "mergedAt": "2021-04-20T14:30:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5fd6fd09022a552c1052f864992f46852f3b9a12"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5Njk2OTkz",
          "commit": {
            "abbreviatedOid": "4621f1e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T09:05:01Z",
          "updatedAt": "2021-04-20T09:05:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDI3NzI3",
          "commit": {
            "abbreviatedOid": "4621f1e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T14:30:44Z",
          "updatedAt": "2021-04-20T14:30:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 182,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4Nzc3ODMz",
      "title": "Mode configuration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/182",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- the mode must be part of the application configuration and static (not change within the app's lifecycle)\r\n- don't include envelope mode in the envelope itself\r\n- don't include envelope mode in the envelope's auth_tag\r\n- add internal mode as recommended parameter\r\n\r\ncloses #180 ",
      "createdAt": "2021-04-20T00:27:27Z",
      "updatedAt": "2021-04-24T15:12:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4f147815162327daefbcb61e3ae9d669951cdecd",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/config-mode",
      "headRefOid": "d649872d77471cd68d012ac745ff1bc856488af7",
      "closedAt": "2021-04-20T23:51:54Z",
      "mergedAt": "2021-04-20T23:51:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "58150d3a0a98bdee75e8f45a61b6a59c9943bfd6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDMyNjcz",
          "commit": {
            "abbreviatedOid": "f7624d1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending test vector updates!",
          "createdAt": "2021-04-20T14:34:33Z",
          "updatedAt": "2021-04-20T14:34:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4NzkxODcz",
      "title": "Put envelope auth_tag back to envelope end",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/183",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Closes #177 ",
      "createdAt": "2021-04-20T00:39:54Z",
      "updatedAt": "2021-04-25T22:37:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "b1c49e4d98d35b671857fe4a37f38e0834090d62",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/env-auth-tag-back",
      "headRefOid": "0031f8ae74e6eeccc502eca01d72e480aea218e9",
      "closedAt": "2021-04-20T21:19:50Z",
      "mergedAt": "2021-04-20T21:19:50Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "c4f22fd6edf77915abc9afae5addb05a1cc31d48"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5NjkyNzUz",
          "commit": {
            "abbreviatedOid": "8fb3470"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM.\r\n\r\nHowever, this is not just an editorial change, so we need to adjust the test vectors too right?",
          "createdAt": "2021-04-20T09:00:46Z",
          "updatedAt": "2021-04-20T09:01:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDMzMTQy",
          "commit": {
            "abbreviatedOid": "8fb3470"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending test vector updates!",
          "createdAt": "2021-04-20T14:34:54Z",
          "updatedAt": "2021-04-20T14:34:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwNDE1ODkz",
          "commit": {
            "abbreviatedOid": "b48199f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T20:58:08Z",
          "updatedAt": "2021-04-20T20:58:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4ODEzOTk5",
      "title": "Consistent format for OPRF group elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/185",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "- introduce Noe, the serialized element length in the OPRF group\r\n- deleted mention of SerializedScalar, since it's not used\r\n- deleted mention of SerializedElement, since it's not used\r\n- specify OPRF group element lengths in message structures\r\n\r\nCloses #179 ",
      "createdAt": "2021-04-20T00:59:39Z",
      "updatedAt": "2021-04-24T15:12:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ff5ec6e9348f801b00f80287fd13f1d747cb9082",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/oprf-point-format",
      "headRefOid": "966ead1faa641598b250134f54652600335ea5ec",
      "closedAt": "2021-04-20T14:32:47Z",
      "mergedAt": "2021-04-20T14:32:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b1c49e4d98d35b671857fe4a37f38e0834090d62"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5OTk1MjIx",
          "commit": {
            "abbreviatedOid": "966ead1"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-20T14:05:28Z",
          "updatedAt": "2021-04-20T14:05:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@kevinlewi Nok is the 'serialized' size, right?",
              "createdAt": "2021-04-20T14:05:28Z",
              "updatedAt": "2021-04-20T14:05:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDI4NTQx",
          "commit": {
            "abbreviatedOid": "966ead1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-20T14:31:22Z",
          "updatedAt": "2021-04-20T14:31:23Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "\ud83d\udc4d ",
              "createdAt": "2021-04-20T14:31:22Z",
              "updatedAt": "2021-04-20T14:31:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDMwMjYy",
          "commit": {
            "abbreviatedOid": "966ead1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T14:32:43Z",
          "updatedAt": "2021-04-20T14:32:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4ODIxNDg4",
      "title": "Specify envelope length in RegistrationUpload",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/186",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Closes #184 ",
      "createdAt": "2021-04-20T01:06:10Z",
      "updatedAt": "2021-04-24T15:12:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ff5ec6e9348f801b00f80287fd13f1d747cb9082",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/envelope-ne",
      "headRefOid": "46bd3430d6e2a64b6f3481d2bb456224b5112cc7",
      "closedAt": "2021-04-20T13:57:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @kevinlewi ! I wasn't sure about that :)",
          "createdAt": "2021-04-20T13:57:28Z",
          "updatedAt": "2021-04-20T13:57:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5NjkwODc5",
          "commit": {
            "abbreviatedOid": "46bd343"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "According to https://tools.ietf.org/html/rfc8446, Section 3, this change would mean that the field consists of `Ne` Envelope structs. I believe the current state of the draft is correct as it stands.",
          "createdAt": "2021-04-20T08:58:57Z",
          "updatedAt": "2021-04-20T08:58:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4ODMwNDIz",
      "title": "clarify export_key client exclusivity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/187",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Closes #181 ",
      "createdAt": "2021-04-20T01:14:00Z",
      "updatedAt": "2021-04-24T15:12:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ff5ec6e9348f801b00f80287fd13f1d747cb9082",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/client-export-key",
      "headRefOid": "c82041ed16dddee12322b9b21d6c69e0c5c16841",
      "closedAt": "2021-04-20T14:30:17Z",
      "mergedAt": "2021-04-20T14:30:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4828978cc350f6ef827a620b9224ac921683d86c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5NjkxODgy",
          "commit": {
            "abbreviatedOid": "c82041e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-04-20T08:59:55Z",
          "updatedAt": "2021-04-20T08:59:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDI2OTk3",
          "commit": {
            "abbreviatedOid": "c82041e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T14:30:09Z",
          "updatedAt": "2021-04-20T14:30:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5NzYwOTM5",
      "title": "Revert \"Mode configuration\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/188",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reverts cfrg/draft-irtf-cfrg-opaque#182",
      "createdAt": "2021-04-20T23:55:56Z",
      "updatedAt": "2021-04-24T15:11:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "58150d3a0a98bdee75e8f45a61b6a59c9943bfd6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "revert-182-dbz/config-mode",
      "headRefOid": "51c0651a461af225349502cea0c2398d32d2f3e0",
      "closedAt": "2021-04-20T23:56:31Z",
      "mergedAt": "2021-04-20T23:56:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7343ed1ff210a2e6a2f78d9874069d2eb8a8caeb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5NzYzMjA1",
      "title": "Revert #183.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/189",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-21T00:03:15Z",
      "updatedAt": "2021-04-24T15:11:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7343ed1ff210a2e6a2f78d9874069d2eb8a8caeb",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/revert-183",
      "headRefOid": "734acaf7c108ad0d39384dda96f5fe62a1f2b4f4",
      "closedAt": "2021-04-21T00:03:28Z",
      "mergedAt": "2021-04-21T00:03:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "388bc8099747f986c2e5a1d97416b97825577482"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 190,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5NzcxOTA2",
      "title": "Update envelope mode integration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/190",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- the mode must be part of the application configuration and static\r\n- don't include envelope mode form the envelope itself\r\n- don't include envelope mode in the envelope's auth_tag\r\n- add internal mode as recommended parameter\r\n- updated poc and vectors",
      "createdAt": "2021-04-21T00:23:44Z",
      "updatedAt": "2021-04-24T15:12:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "388bc8099747f986c2e5a1d97416b97825577482",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/config-mode-2",
      "headRefOid": "513d5a10cadbeb5ef9356254246ff4cbeca8282a",
      "closedAt": "2021-04-21T00:26:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 191,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5NzgyMTE0",
      "title": "Update envelope mode integration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/191",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- the mode must be part of the application configuration and static\r\n- don't include envelope mode form the envelope itself\r\n- don't include envelope mode in the envelope's auth_tag\r\n- add internal mode as recommended parameter\r\n- updated poc and vectors",
      "createdAt": "2021-04-21T01:01:05Z",
      "updatedAt": "2021-04-24T15:11:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4ff533d3b5d09142ba79ba668d8f4276331d51e2",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/config-mode-3",
      "headRefOid": "7e3359e99524324a9aa76adb26b575e66ea775ba",
      "closedAt": "2021-04-21T14:31:30Z",
      "mergedAt": "2021-04-21T14:31:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6d4e71d3248fde928dc1df600ca6fde68d7f6ea8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5ODA4NDA4",
      "title": "Put envelope auth_tag back to envelope end",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/192",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-21T02:29:47Z",
      "updatedAt": "2021-04-24T15:12:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "388bc8099747f986c2e5a1d97416b97825577482",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/env-auth-tag-back-2",
      "headRefOid": "3908192876e97c17adfceb172fee476a4a2a0bdd",
      "closedAt": "2021-04-21T14:13:17Z",
      "mergedAt": "2021-04-21T14:13:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4ff533d3b5d09142ba79ba668d8f4276331d51e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxMTQ1MzA0",
          "commit": {
            "abbreviatedOid": "3908192"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-21T14:13:12Z",
          "updatedAt": "2021-04-21T14:13:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwMjc2MDY5",
      "title": "Update the OPAQUE-3DH Instantiation section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/193",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "- added protocol compilation at login\r\n- interface for the main API\r\n- high-level composition of credential recovery and AKE\r\n- write out various functions\r\n- introduce RandomPrivateKey() to create a fresh key for EDH\r\n- move to CamelCase and space-less magic strings\r\n- clean-up leftover mishaps\r\n\r\ncloses #172 ",
      "createdAt": "2021-04-21T14:36:40Z",
      "updatedAt": "2021-04-24T15:11:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9f8c81de6bee3a6fac647affd7aba6b6a9a35ea2",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/ake-rewrite",
      "headRefOid": "5ce326fb09f0876d5fc7090376c559c4071155ea",
      "closedAt": "2021-04-21T23:55:16Z",
      "mergedAt": "2021-04-21T23:55:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5895adf00519a140e1f8eb5a07fe0aed6aadcfd3"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM pending @kevinlewi's review!",
          "createdAt": "2021-04-21T19:52:16Z",
          "updatedAt": "2021-04-21T19:52:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxMTgwODQw",
          "commit": {
            "abbreviatedOid": "ddb268e"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T14:42:09Z",
          "updatedAt": "2021-04-21T14:42:56Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Since these are internal values, perhaps we can hide them under a \"client_state\" and \"server_state\" structure? Otherwise, APIs might be tempted to export them for applications to use.",
              "createdAt": "2021-04-21T14:42:09Z",
              "updatedAt": "2021-04-21T23:53:41Z"
            },
            {
              "originalPosition": 419,
              "body": "Can we use the same function for both client and server here? That's what we do in the POC",
              "createdAt": "2021-04-21T14:42:49Z",
              "updatedAt": "2021-04-21T23:53:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNDUzOTAy",
          "commit": {
            "abbreviatedOid": "47618a3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T19:32:53Z",
          "updatedAt": "2021-04-21T19:32:54Z",
          "comments": [
            {
              "originalPosition": 406,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-04-21T19:32:53Z",
              "updatedAt": "2021-04-21T23:53:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNDY3NzUz",
          "commit": {
            "abbreviatedOid": "07190b2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-21T19:52:05Z",
          "updatedAt": "2021-04-21T19:52:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTQ3MDIx",
          "commit": {
            "abbreviatedOid": "07190b2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:22:52Z",
          "updatedAt": "2021-04-21T21:22:52Z",
          "comments": [
            {
              "originalPosition": 461,
              "body": "ke2",
              "createdAt": "2021-04-21T21:22:52Z",
              "updatedAt": "2021-04-21T23:53:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTQ5NjQz",
          "commit": {
            "abbreviatedOid": "07190b2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:24:02Z",
          "updatedAt": "2021-04-21T21:24:03Z",
          "comments": [
            {
              "originalPosition": 430,
              "body": "client_info, the optional client-side information",
              "createdAt": "2021-04-21T21:24:03Z",
              "updatedAt": "2021-04-21T23:53:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTUwMDkx",
          "commit": {
            "abbreviatedOid": "07190b2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:24:14Z",
          "updatedAt": "2021-04-21T21:24:14Z",
          "comments": [
            {
              "originalPosition": 465,
              "body": "server_info, the optional server-side information",
              "createdAt": "2021-04-21T21:24:14Z",
              "updatedAt": "2021-04-21T23:53:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTUyMTky",
          "commit": {
            "abbreviatedOid": "07190b2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:25:10Z",
          "updatedAt": "2021-04-21T21:25:11Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "remove double-space between comma and \"the\"",
              "createdAt": "2021-04-21T21:25:11Z",
              "updatedAt": "2021-04-21T23:53:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTYyMDM0",
          "commit": {
            "abbreviatedOid": "07190b2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T21:29:35Z",
          "updatedAt": "2021-04-21T21:29:35Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "Also, for descriptions of client_identity, can we say \"set to client_public_key if not specified\" instead of \"its public key\"? Same with server_identity",
              "createdAt": "2021-04-21T21:29:35Z",
              "updatedAt": "2021-04-21T23:53:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNTgyNjA5",
          "commit": {
            "abbreviatedOid": "07190b2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo the above comments!",
          "createdAt": "2021-04-21T21:57:25Z",
          "updatedAt": "2021-04-21T21:57:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwNDM1MTEw",
      "title": "Refactor and rearrange things.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/194",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-21T18:31:55Z",
      "updatedAt": "2021-04-24T15:11:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "dbz/ake-rewrite",
      "baseRefOid": "47618a3d0498efaef2f19412267fc0078ce102aa",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/dbz-refactor",
      "headRefOid": "48b21ac362a582d5f4b8eaed6d958540f81cdc88",
      "closedAt": "2021-04-21T19:47:22Z",
      "mergedAt": "2021-04-21T19:47:22Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "07190b28e067eaca767bed2f002e80210054221a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNDM1NDk5",
          "commit": {
            "abbreviatedOid": "2320a07"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T19:08:09Z",
          "updatedAt": "2021-04-21T19:08:09Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "If it's implicit, then maybe not return it at line 1075 :) (or add it at line 1076)",
              "createdAt": "2021-04-21T19:08:09Z",
              "updatedAt": "2021-04-21T19:40:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNDQwNzM1",
          "commit": {
            "abbreviatedOid": "2320a07"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-04-21T19:15:27Z",
          "updatedAt": "2021-04-21T19:36:04Z",
          "comments": [
            {
              "originalPosition": 394,
              "body": "```suggestion\r\nThe OPAQUE-3DH shared secret derived during the key exchange protocol is computed\r\n```",
              "createdAt": "2021-04-21T19:15:27Z",
              "updatedAt": "2021-04-21T19:40:34Z"
            },
            {
              "originalPosition": 422,
              "body": "This function doesn't use Nx directly. Is it necessary specifying it here?",
              "createdAt": "2021-04-21T19:17:10Z",
              "updatedAt": "2021-04-21T19:40:34Z"
            },
            {
              "originalPosition": 461,
              "body": "```suggestion\r\n- ke1, a KE1 message structure\r\n```",
              "createdAt": "2021-04-21T19:21:01Z",
              "updatedAt": "2021-04-21T19:40:34Z"
            },
            {
              "originalPosition": 147,
              "body": "why these two?",
              "createdAt": "2021-04-21T19:35:56Z",
              "updatedAt": "2021-04-21T19:40:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNDU4MDMw",
          "commit": {
            "abbreviatedOid": "a19ee3f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T19:38:46Z",
          "updatedAt": "2021-04-21T19:38:46Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Oh, right, it doesn't need them!",
              "createdAt": "2021-04-21T19:38:46Z",
              "updatedAt": "2021-04-21T19:40:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNDU4Njc0",
          "commit": {
            "abbreviatedOid": "a19ee3f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-21T19:39:36Z",
          "updatedAt": "2021-04-21T19:39:36Z",
          "comments": [
            {
              "originalPosition": 422,
              "body": "Nope -- removed.",
              "createdAt": "2021-04-21T19:39:36Z",
              "updatedAt": "2021-04-21T19:40:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwNjQyMDI1",
      "title": "Move opaque byte representations to uint8",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/196",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "closes #195 ",
      "createdAt": "2021-04-22T00:08:04Z",
      "updatedAt": "2021-04-24T15:11:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5895adf00519a140e1f8eb5a07fe0aed6aadcfd3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/opaque-2-uint8",
      "headRefOid": "bdb4ed2cc6d8e31e48011799b85f27ba6ca7417b",
      "closedAt": "2021-04-22T00:08:49Z",
      "mergedAt": "2021-04-22T00:08:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e221cfe3ab3fc632c5548929a6582dcec46a7098"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNjUwODk1",
          "commit": {
            "abbreviatedOid": "bdb4ed2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-22T00:08:45Z",
          "updatedAt": "2021-04-22T00:08:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIxNjEwNjgx",
      "title": "Editorial pass.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/197",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes some redundant text, tries to introduce better flow in the document (starting with a protocol overview and then drilling into specific stages), and rearranges some text for (what seems to be) better readability. It's still not perfect, but I think this is an improvement overall.",
      "createdAt": "2021-04-22T22:49:19Z",
      "updatedAt": "2021-04-24T15:11:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e221cfe3ab3fc632c5548929a6582dcec46a7098",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/editorial-pass",
      "headRefOid": "238c45a28ff81baa010cbe63880a5878f1ff6134",
      "closedAt": "2021-04-23T17:01:43Z",
      "mergedAt": "2021-04-23T17:01:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d18343e49970a3c9ca229798a24da9273a5fb62a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyNzg2MjUw",
          "commit": {
            "abbreviatedOid": "70fd9f8"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Bunch of nits, but otherwise looks good! Thanks for doing this :) ",
          "createdAt": "2021-04-23T00:10:30Z",
          "updatedAt": "2021-04-23T01:31:50Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "typo: plaintex -> plaintext",
              "createdAt": "2021-04-23T00:10:30Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nused in the AKE. The AKE protocol must provide the following functions:\r\n```",
              "createdAt": "2021-04-23T00:53:00Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\nFinally, all random nonces used in this protocol are of length `Nn` = 32 bytes.\r\n```",
              "createdAt": "2021-04-23T00:53:47Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 198,
              "body": "```suggestion\r\nThe registration flow is shown below:\r\n```",
              "createdAt": "2021-04-23T00:55:39Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 229,
              "body": "```suggestion\r\nThe authenticated key exchange flow is shown below:\r\n```",
              "createdAt": "2021-04-23T00:55:57Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 275,
              "body": "We can probably merge these two paragraphs into one",
              "createdAt": "2021-04-23T01:06:27Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 282,
              "body": "```suggestion\r\napplication credential information are considered:\r\n```",
              "createdAt": "2021-04-23T01:07:28Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 503,
              "body": "Now that `EnvelopeMode` is no longer encoded anywhere, it seems like we do not need to define this enum anymore, right? An implementation can choose to use whatever number it desires to represent \"internal\" and \"external\", it doesn't have to be 1 and 2, right?",
              "createdAt": "2021-04-23T01:10:02Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 516,
              "body": "```suggestion\r\n  Build and return the mode's `InnerEnvelope` structure and the client's public key.\r\n```",
              "createdAt": "2021-04-23T01:10:39Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 518,
              "body": "```suggestion\r\n  Recover and return the client's private and public keys for the AKE protocol.\r\n```",
              "createdAt": "2021-04-23T01:10:47Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 538,
              "body": "```suggestion\r\n`InnerEnvelope` is empty, and the size `Ne` of the serialized `Envelope` is `Nn + Nm`.\r\n```",
              "createdAt": "2021-04-23T01:11:28Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 549,
              "body": "Can we just omit this as a parameter, and hard-code \"OPAQUE-HashToScalar\" on line 707?",
              "createdAt": "2021-04-23T01:12:28Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 549,
              "body": "So that line 707 reads:\r\n\r\n1. private_key = HashToScalar(seed, dst = \"OPAQUE-HashToScalar\")",
              "createdAt": "2021-04-23T01:12:54Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 563,
              "body": "Perhaps remove the \"except that dst = \"OPAQUE-HashToScalar\"\", since this is already specified above?",
              "createdAt": "2021-04-23T01:13:34Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 636,
              "body": "```suggestion\r\nsize `Ne` of the serialized `Envelope` is `Nn + Nm + Nsk`.\r\n```",
              "createdAt": "2021-04-23T01:14:25Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 656,
              "body": "```suggestion\r\nensured with the `auth_tag` field in the envelope that covers this `InnerEnvelope`.\r\n```",
              "createdAt": "2021-04-23T01:15:03Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 672,
              "body": "```suggestion\r\n- client_private_key, the encoded client private key for the AKE protocol.\r\n```",
              "createdAt": "2021-04-23T01:15:38Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 696,
              "body": "```suggestion\r\n- client_private_key, the encoded client private key for the AKE protocol.\r\n```",
              "createdAt": "2021-04-23T01:15:48Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 745,
              "body": "```suggestion\r\n- server_private_key: server private key for the AKE protocol.\r\n```",
              "createdAt": "2021-04-23T01:18:47Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 746,
              "body": "```suggestion\r\n- server_public_key: server public key for the AKE protocol.\r\n```",
              "createdAt": "2021-04-23T01:18:55Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 893,
              "body": "```suggestion\r\n- client_private_key, the client's private key. In internal mode, this is nil.\r\n```",
              "createdAt": "2021-04-23T01:25:32Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 586,
              "body": "```suggestion\r\n2. (_, client_public_key) = DeriveAuthKeyPair(seed)\r\n```",
              "createdAt": "2021-04-23T01:26:00Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 476,
              "body": "```suggestion\r\n3. (client_private_key, client_public_key) =\r\n```",
              "createdAt": "2021-04-23T01:26:15Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 909,
              "body": "```suggestion\r\n3. (envelope, client_public_key, masking_key, export_key) =\r\n```",
              "createdAt": "2021-04-23T01:26:48Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 1010,
              "body": "```suggestion\r\n    (ke3,\r\n    server_info,\r\n    session_key,\r\n    export_key) = ClientFinish(password, client_identity,\r\n```",
              "createdAt": "2021-04-23T01:28:03Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 1159,
              "body": "```suggestion\r\n6. (client_private_key, export_key) =\r\n```",
              "createdAt": "2021-04-23T01:28:46Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 1362,
              "body": "```suggestion\r\n2. (client_private_key, server_public_key, export_key) =\r\n```",
              "createdAt": "2021-04-23T01:30:03Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 1364,
              "body": "```suggestion\r\n3. (ke3, server_info, session_key) =\r\n```",
              "createdAt": "2021-04-23T01:30:11Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 1480,
              "body": "```suggestion\r\n2. (ke2, client_info) = Response(server_identity, server_private_key,\r\n```",
              "createdAt": "2021-04-23T01:30:52Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzAyNzI3",
          "commit": {
            "abbreviatedOid": "70fd9f8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T13:33:52Z",
          "updatedAt": "2021-04-23T13:33:53Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nMoreover, plaintext password authentication over secure channels like\r\n```",
              "createdAt": "2021-04-23T13:33:52Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzEwNDYw",
          "commit": {
            "abbreviatedOid": "3579bfa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T13:41:32Z",
          "updatedAt": "2021-04-23T13:41:33Z",
          "comments": [
            {
              "originalPosition": 503,
              "body": "It doesn't, but let's leave this for a separate PR. ",
              "createdAt": "2021-04-23T13:41:32Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzI3Mjk4",
          "commit": {
            "abbreviatedOid": "fdd862b"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T13:57:38Z",
          "updatedAt": "2021-04-23T13:57:39Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Are we using the C/S notation somewhere?",
              "createdAt": "2021-04-23T13:57:38Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzMxMDQy",
          "commit": {
            "abbreviatedOid": "fdd862b"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-04-23T14:01:11Z",
          "updatedAt": "2021-04-23T14:30:33Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nPassword authentication is ubiquitous in many applications. In a common\r\n```",
              "createdAt": "2021-04-23T14:01:11Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nTLS is also vulnerable to cases where TLS may fail, including PKI\r\n```",
              "createdAt": "2021-04-23T14:03:34Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nno change or awareness on the client-side relative to a single-server implementation).\r\n```",
              "createdAt": "2021-04-23T14:04:48Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 100,
              "body": "I'm not sure about the oxford comma here \ud83e\udd14 ",
              "createdAt": "2021-04-23T14:07:13Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\n- DeriveAuthKeyPair(seed): Derive a private and public authentication key pair\r\n```",
              "createdAt": "2021-04-23T14:08:51Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 195,
              "body": "> which includes its password and user identifier\r\n\r\nWe may want to clarify here that this identifier may or may not be the same as used in the protocol",
              "createdAt": "2021-04-23T14:11:37Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 199,
              "body": "> to encrypt additional information to the server\n\r\nthis phrase can be misleading and interpreted as \"to encrypt additional information sent to the server who can decrypt it\".\r\n\r\n```suggestion\r\nfor application-specific purposes, e.g., to encrypt additional information\r\nto be sent to and saved by server. The server output of this stage is a record corresponding to\r\n```",
              "createdAt": "2021-04-23T14:14:54Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 195,
              "body": "The phrasing may exclude the external mode. Is it intentional?",
              "createdAt": "2021-04-23T14:17:18Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 257,
              "body": "```suggestion\r\nThe remainder of this document describes the details of these stages in detail.\r\n```",
              "createdAt": "2021-04-23T14:21:24Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 259,
              "body": "```suggestion\r\ngenerated, encoded, encrypted, and stored on the server. {{offline-phase}} describes the\r\n```",
              "createdAt": "2021-04-23T14:22:29Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 291,
              "body": "If we mention the client's private key in this part, it makes sense to also mention the server's private key. I suggest either both or none (as they are not used as identities).",
              "createdAt": "2021-04-23T14:25:26Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 392,
              "body": "```suggestion\r\n`InnerEnvelope`, and `CleartextCredentials`.\r\n```",
              "createdAt": "2021-04-23T14:27:50Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzY0NjI4",
          "commit": {
            "abbreviatedOid": "f5c3548"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T14:33:39Z",
          "updatedAt": "2021-04-23T14:33:39Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "I went with a slightly different variant: \"to encrypt additional information under the password\"",
              "createdAt": "2021-04-23T14:33:39Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzY2MTM2",
          "commit": {
            "abbreviatedOid": "c6f112e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T14:35:10Z",
          "updatedAt": "2021-04-23T14:35:11Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "No, but I didn't want to confuse reads so early on. I figured omitting that for now and explaining internal/external mode later was easiest.",
              "createdAt": "2021-04-23T14:35:11Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzY3MjI5",
          "commit": {
            "abbreviatedOid": "c6f112e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T14:36:12Z",
          "updatedAt": "2021-04-23T14:36:13Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "The server public key is part of the CleartextCredentials structure, so I think we should keep this as-is.",
              "createdAt": "2021-04-23T14:36:13Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzY3NDU0",
          "commit": {
            "abbreviatedOid": "c6f112e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T14:36:26Z",
          "updatedAt": "2021-04-23T14:36:27Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Hmm, maybe. Can you propose text?",
              "createdAt": "2021-04-23T14:36:26Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzc1MTQx",
          "commit": {
            "abbreviatedOid": "c6f112e"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T14:43:57Z",
          "updatedAt": "2021-04-23T14:43:57Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "I mean the private keys",
              "createdAt": "2021-04-23T14:43:57Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMzgyMzUy",
          "commit": {
            "abbreviatedOid": "c6f112e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T14:51:08Z",
          "updatedAt": "2021-04-23T14:51:09Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "I understand, but since the server private key isn't used for credentials, it's not included. ",
              "createdAt": "2021-04-23T14:51:08Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNDUxNzEw",
          "commit": {
            "abbreviatedOid": "c6f112e"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-04-23T16:02:55Z",
          "updatedAt": "2021-04-23T16:12:10Z",
          "comments": [
            {
              "originalPosition": 799,
              "body": "```suggestion\r\ncorresponding parameters referenced above.\r\n```",
              "createdAt": "2021-04-23T16:02:55Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 733,
              "body": "```suggestion\r\nIf using the `external` mode, the client provides a key pair\r\n```",
              "createdAt": "2021-04-23T16:03:53Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 943,
              "body": "```suggestion\r\nfull forward security (without it, forward secrecy is only achieved against eavesdroppers,\r\n```",
              "createdAt": "2021-04-23T16:05:25Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 1270,
              "body": "```suggestion\r\n- inner_ke2, an inner_ke2 structure as defined in KE2.\r\n```",
              "createdAt": "2021-04-23T16:08:08Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            },
            {
              "originalPosition": 1087,
              "body": "```suggestion\r\nyet to register, or never will).\r\n```",
              "createdAt": "2021-04-23T16:10:15Z",
              "updatedAt": "2021-04-23T17:00:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIyMTg1NDYw",
      "title": "Some extra typo corrections",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/198",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-04-23T16:18:47Z",
      "updatedAt": "2021-04-24T15:11:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e221cfe3ab3fc632c5548929a6582dcec46a7098",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/fix-typos",
      "headRefOid": "15c8dd6967dcc28a3cf81225bfb0ae6dc0dfb70d",
      "closedAt": "2021-04-23T17:02:21Z",
      "mergedAt": "2021-04-23T17:02:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9cdad32731e22e4e7588ca731f8d319db72af5a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNTAwMDUy",
          "commit": {
            "abbreviatedOid": "15c8dd6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-23T17:02:18Z",
          "updatedAt": "2021-04-23T17:02:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIyNjAzMDUz",
      "title": "Add application considerations.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/199",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #173 and #204.",
      "createdAt": "2021-04-24T15:36:11Z",
      "updatedAt": "2021-06-02T19:19:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "fc42616e4908d4ebfa94ca9ff3d93131f05479c6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/app-considerations",
      "headRefOid": "d3f04d4e0f7bba511fc9d0d8b7f8c00a0d6d50d3",
      "closedAt": "2021-06-02T19:19:09Z",
      "mergedAt": "2021-06-02T19:19:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "72ec450e9c4353e888f60497955f905f2ba3f251"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you mean with regard to #169 and #173?",
          "createdAt": "2021-04-26T13:42:57Z",
          "updatedAt": "2021-04-26T13:44:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare I also included #204 changes here. (Do you think more needs to be said to close out that issue?)",
          "createdAt": "2021-05-26T22:23:18Z",
          "updatedAt": "2021-05-26T22:23:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ0MTg2NTg5",
          "commit": {
            "abbreviatedOid": "260754a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-25T22:19:02Z",
          "updatedAt": "2021-04-25T22:19:02Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "\u2764\ufe0f ",
              "createdAt": "2021-04-25T22:19:02Z",
              "updatedAt": "2021-04-25T22:19:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcxMjgyMDI2",
          "commit": {
            "abbreviatedOid": "1971125"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-05-28T13:09:12Z",
          "updatedAt": "2021-05-28T13:15:15Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\nis already in use, the server will not complete the protocol. This allows an attacker\r\n```",
              "createdAt": "2021-05-28T13:09:12Z",
              "updatedAt": "2021-05-28T13:15:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcxMjkxNTcw",
          "commit": {
            "abbreviatedOid": "1971125"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-28T13:19:37Z",
          "updatedAt": "2021-05-28T19:39:12Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Contradiction with the 1st type of attacks considered in the client enumeration prevention section",
              "createdAt": "2021-05-28T13:19:37Z",
              "updatedAt": "2021-05-28T19:39:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcxNTk3NzY5",
          "commit": {
            "abbreviatedOid": "d3f04d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-28T19:42:39Z",
          "updatedAt": "2021-05-28T19:42:39Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "I think this is resolved?",
              "createdAt": "2021-05-28T19:42:39Z",
              "updatedAt": "2021-05-28T19:42:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcxNzQwNjc2",
          "commit": {
            "abbreviatedOid": "d3f04d4"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-29T12:17:05Z",
          "updatedAt": "2021-05-29T12:17:05Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Yes it is -- I resolved this yesterday when we talked about it",
              "createdAt": "2021-05-29T12:17:05Z",
              "updatedAt": "2021-05-29T12:17:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc0NTkwMTE3",
          "commit": {
            "abbreviatedOid": "d3f04d4"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is very well-written. Thank you!",
          "createdAt": "2021-06-02T19:09:56Z",
          "updatedAt": "2021-06-02T19:09:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI4Mjc1NTkx",
      "title": "Updates based on Hugo's review.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/201",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-30T23:24:10Z",
      "updatedAt": "2021-05-03T13:51:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e221eaf702c2f018ad73bdfd3e043abbf8706b1f",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hugo-feedback",
      "headRefOid": "1eaf912d84822d6052686c30b7227409b097dee9",
      "closedAt": "2021-05-03T13:51:59Z",
      "mergedAt": "2021-05-03T13:51:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "58699b2c6208b7e0668f3b3582f61fb5bf649e17"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5Njk2NTAy",
          "commit": {
            "abbreviatedOid": "4b0a318"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-01T00:25:26Z",
          "updatedAt": "2021-05-01T00:25:27Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "` to import or generate`\r\nWhile that's true, it may confuse the reader as it can easily be understood as \"this mode generates keys for the client\". But maybe that's just me :) ",
              "createdAt": "2021-05-01T00:25:26Z",
              "updatedAt": "2021-05-01T00:25:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5Njk2NzA4",
          "commit": {
            "abbreviatedOid": "4b0a318"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-01T00:26:51Z",
          "updatedAt": "2021-05-01T00:26:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5Njk3NTEw",
          "commit": {
            "abbreviatedOid": "4b0a318"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-01T00:32:38Z",
          "updatedAt": "2021-05-01T00:32:45Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n    email: dan@bytema.re\r\n```",
              "createdAt": "2021-05-01T00:32:38Z",
              "updatedAt": "2021-05-01T00:32:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5Njk3OTM5",
          "commit": {
            "abbreviatedOid": "1eaf912"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-01T00:36:04Z",
          "updatedAt": "2021-05-01T00:36:04Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "The point of this change was to to suggest that it doesn't prohibit from key generation to happen _within_ the registration flow. (That is, registration could call DeriveAuthKeyPair or GenerateAuthKeyPair, for example, depending on mode.) \ud83e\udd37 ",
              "createdAt": "2021-05-01T00:36:04Z",
              "updatedAt": "2021-05-01T00:36:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5Njk4MTI4",
          "commit": {
            "abbreviatedOid": "1eaf912"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-01T00:37:44Z",
          "updatedAt": "2021-05-01T00:37:44Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Ah yes, I see :) thanks!",
              "createdAt": "2021-05-01T00:37:44Z",
              "updatedAt": "2021-05-01T00:37:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 202,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMzODg3MDA2",
      "title": "Adds creds parameter.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/202",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-08T03:56:12Z",
      "updatedAt": "2021-05-10T18:20:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "58699b2c6208b7e0668f3b3582f61fb5bf649e17",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "credsParam",
      "headRefOid": "3e24d591c7707dc6fb6237bfde3579749ce00473",
      "closedAt": "2021-05-10T18:20:07Z",
      "mergedAt": "2021-05-10T18:20:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2c1b0e7f610eda2f13a87750dffb1d263f7553c4"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Well spotted! Thanks! \ud83d\udc4d ",
          "createdAt": "2021-05-08T10:07:53Z",
          "updatedAt": "2021-05-08T10:07:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0OTc5Nzk2",
          "commit": {
            "abbreviatedOid": "3e24d59"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-08T10:08:32Z",
          "updatedAt": "2021-05-08T10:08:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1OTQwMzk1",
          "commit": {
            "abbreviatedOid": "3e24d59"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-10T18:20:03Z",
          "updatedAt": "2021-05-10T18:20:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0NjM5MzYwMTA2",
      "title": "Identities are vector of bytes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/203",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-11T05:26:02Z",
      "updatedAt": "2021-05-20T23:13:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2c1b0e7f610eda2f13a87750dffb1d263f7553c4",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "rangeIdentities",
      "headRefOid": "fd74b01b2149f5eda40d970dcd195dadfb30cbb0",
      "closedAt": "2021-05-20T23:13:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed in favor of #209 ",
          "createdAt": "2021-05-20T23:13:13Z",
          "updatedAt": "2021-05-20T23:13:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2Njc3MjQ3",
          "commit": {
            "abbreviatedOid": "fd74b01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T13:02:11Z",
          "updatedAt": "2021-05-11T13:02:11Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This is mainly a implementation detail, so I'd recommend just removing the struct definition entirely. ",
              "createdAt": "2021-05-11T13:02:11Z",
              "updatedAt": "2021-05-11T13:02:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2Njc3NTY4",
          "commit": {
            "abbreviatedOid": "fd74b01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good catch! I'd go with a slightly different solution.",
          "createdAt": "2021-05-11T13:02:30Z",
          "updatedAt": "2021-05-11T13:02:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3MTg3NTc4",
      "title": "Fixes random generation for test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/205",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also fixes the serialization of `CleartextCredentials`\r\n\r\n```go\r\nstruct {\r\n  uint8 server_public_key[Npk];\r\n  uint8 server_identity<1..2^16-1>;\r\n  uint8 client_identity<1..2^16-1>;\r\n} CleartextCredentials;\r\n```\r\nFile `poc/opaque_messages.sage`:\r\n\r\n```patch \r\n     def serialize(self):\r\n-        return self.pkS + encode_vector(self.idU) + encode_vector(self.idS)\r\n+        return self.pkS + encode_vector(self.idS) + encode_vector(self.idU)\r\n```\r\n",
      "createdAt": "2021-05-19T00:46:48Z",
      "updatedAt": "2021-05-20T20:56:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2c1b0e7f610eda2f13a87750dffb1d263f7553c4",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "fixRandom",
      "headRefOid": "2a5f80ebc3786e795e9f26dbe8d156af178073f0",
      "closedAt": "2021-05-20T20:56:14Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "todo(armfazh): do not update voprf in this PR.\r\n",
          "createdAt": "2021-05-20T17:48:20Z",
          "updatedAt": "2021-05-20T17:48:20Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as this PR is now split in #206 -> #207 -> #208 ",
          "createdAt": "2021-05-20T20:56:14Z",
          "updatedAt": "2021-05-20T20:56:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 206,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ5NDU2MDU1",
      "title": "Bumping up h2c dependency (no changes).",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/206",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-20T20:54:10Z",
      "updatedAt": "2021-05-24T19:35:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2c1b0e7f610eda2f13a87750dffb1d263f7553c4",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "bumpdepH2C",
      "headRefOid": "5b540e4a9e7ac93d5013a0b533beb0308436ccfa",
      "closedAt": "2021-05-24T19:35:24Z",
      "mergedAt": "2021-05-24T19:35:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9f1cfbc66afd43b252e39b7fcf051a17fe207d44"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ5NDU2OTE4",
      "title": "Fix random generation of test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/207",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Merge after #206 ",
      "createdAt": "2021-05-20T20:54:54Z",
      "updatedAt": "2021-05-24T19:38:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2c1b0e7f610eda2f13a87750dffb1d263f7553c4",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "fixRandomSeed",
      "headRefOid": "83461036c0f7d5f85fe4f3311929d4043f2c9499",
      "closedAt": "2021-05-24T19:38:36Z",
      "mergedAt": "2021-05-24T19:38:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "83461036c0f7d5f85fe4f3311929d4043f2c9499"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ5NDU3NTEw",
      "title": "Fix serialization of CleartextCredentials structure",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/208",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Merge after #207 ",
      "createdAt": "2021-05-20T20:55:21Z",
      "updatedAt": "2021-05-24T19:38:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2c1b0e7f610eda2f13a87750dffb1d263f7553c4",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "fixSerCleartextCredentials",
      "headRefOid": "fe9daf1f72ae852ca74256e0dd818d1a0ac1b025",
      "closedAt": "2021-05-24T19:38:35Z",
      "mergedAt": "2021-05-24T19:38:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "11d7a4d5ddc95bd762f7b6727401922800a30fb2"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Nicely spotted! I ended up serializing [pks, idu, ids] as well for some reason.\r\n\r\nNew vectors look good \u2714\ufe0f ",
          "createdAt": "2021-05-24T01:24:57Z",
          "updatedAt": "2021-05-24T01:24:57Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @kevinlewi ",
          "createdAt": "2021-05-24T01:25:40Z",
          "updatedAt": "2021-05-24T01:25:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MTExMTU1",
          "commit": {
            "abbreviatedOid": "fe9daf1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-24T19:38:29Z",
          "updatedAt": "2021-05-24T19:38:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ5NTM2NjA5",
      "title": "Removing Credentials structure.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/209",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The credentials structure is not a message of the protocol, thus, it's upto the implementer its storage definition. \r\nIts content is now split in `server_identity` and `client_identity` variables.\r\n\r\nCloses #203 ",
      "createdAt": "2021-05-20T23:12:19Z",
      "updatedAt": "2021-05-24T19:36:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2c1b0e7f610eda2f13a87750dffb1d263f7553c4",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "removeCredsStruct",
      "headRefOid": "3e421249f4e7e2ad9be356a9b30fcab80d1b4eab",
      "closedAt": "2021-05-24T19:36:37Z",
      "mergedAt": "2021-05-24T19:36:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d918cb9542d9bc95ab437cf20c3ca3b746cef7bb"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, it has become useless",
          "createdAt": "2021-05-24T01:33:22Z",
          "updatedAt": "2021-05-24T01:33:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MTA5NjU4",
          "commit": {
            "abbreviatedOid": "3e42124"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'll update the Sage code in a followup PR. ",
          "createdAt": "2021-05-24T19:36:16Z",
          "updatedAt": "2021-05-24T19:36:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUyNzM5MDI2",
      "title": "Remove client_info and server_info and add shared Context to transcript",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/211",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #169 \r\n\r\ntl;dr\r\n\r\n- completely remove client_info and server_info\r\n- replace \"3DH\" transcript prefix with \"RFCXXXX\" (to be replaced by the actual RFC id)\r\n- introduce optional shared context info \"info\" in configuration, to be length-prefix encoded in the transcript: \"RFCXXXX\" + encoded(info) + ...\r\n- POC uses \"OPAQUE-POC\" as shared info field",
      "createdAt": "2021-05-25T19:31:49Z",
      "updatedAt": "2023-04-03T09:09:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "11d7a4d5ddc95bd762f7b6727401922800a30fb2",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/remove-info",
      "headRefOid": "a65a0aa53faf820db2128663f36f4e3baa9ae218",
      "closedAt": "2021-05-26T17:27:51Z",
      "mergedAt": "2021-05-26T17:27:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "82277527a1d2b1565381431d5e3bffa15f46c99b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4MjgzOTk1",
          "commit": {
            "abbreviatedOid": "6d78ce0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Great start! I'd simplify the format and structure of `Context` somewhat. (Were you also planning on updating the code? If not, I can do it.)",
          "createdAt": "2021-05-25T19:51:06Z",
          "updatedAt": "2021-05-25T19:54:29Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I would simplify this and just say that `context` is an arbitrary-length byte string, and it's encoded in the transcript preamble like so:\r\n\r\n```\r\npreamble = concat(I2OSP(len(context), 2), context, ...\r\n```\r\n\r\nWe could give guidance for what this context should include, such as what you list below, but it _seems_ overly prescriptive to force this particular structure here.",
              "createdAt": "2021-05-25T19:51:06Z",
              "updatedAt": "2021-05-25T19:54:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4MzIzNjU1",
          "commit": {
            "abbreviatedOid": "6d78ce0"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T20:10:01Z",
          "updatedAt": "2021-05-26T07:09:34Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "How about this\r\n\r\n> OPAQUE-3DH can additionally include shared context information in the transcript, such as configuration parameters or application-specific info, e.g. \"appXYZ-va.b.c\"\r\n\r\nand further down\r\n\r\n> Parameters:\r\n> context, a shared context string.\r\n> ...\r\n> Steps:\r\n> 1. preamble = concat(\"RFCXXXX\",\r\n>                      context,\r\n>                      I2OSP(len(client_identity), 2), client_identity,\r\n>                      ke1,\r\n>                      I2OSP(len(server_identity), 2), server_identity,\r\n>                      inner_ke2)\r\n> 2. Output preamble",
              "createdAt": "2021-05-25T20:10:01Z",
              "updatedAt": "2021-05-26T07:09:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MzQ1MzQ1",
          "commit": {
            "abbreviatedOid": "9c901cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T17:25:37Z",
          "updatedAt": "2021-05-26T17:25:37Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-05-26T17:25:37Z",
              "updatedAt": "2021-05-26T17:25:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MzQ2NjI4",
          "commit": {
            "abbreviatedOid": "9c901cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T17:27:03Z",
          "updatedAt": "2021-05-26T17:27:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU0MTAwNTA3",
      "title": "Move Context to the configuration section. Include it in the test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/212",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Small cleanup from #211.",
      "createdAt": "2021-05-26T18:10:56Z",
      "updatedAt": "2021-05-26T19:50:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "82277527a1d2b1565381431d5e3bffa15f46c99b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/update-vectors-and-config",
      "headRefOid": "d4bf580c61d0ff9a17b6c0405380d3c3e941af58",
      "closedAt": "2021-05-26T19:50:24Z",
      "mergedAt": "2021-05-26T19:50:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fc42616e4908d4ebfa94ca9ff3d93131f05479c6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NDEwODIx",
          "commit": {
            "abbreviatedOid": "d4bf580"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T18:29:44Z",
          "updatedAt": "2021-05-26T18:29:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU5NTg4MzI3",
      "title": "Implement fake credentials response",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/213",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bytemare"
      ],
      "labels": [
        "next-version"
      ],
      "body": "Addresses #166 \r\n\r\nA global fake record is created, that should be used in place of a legitimate one:\r\n- envelope data is all 0 bytes\r\n- a fake client public key is generated to serve for the AKE\r\n- a random fake masking key is used\r\n\r\nApplication consideration for #199 \r\n- server must not evaluate oprf on nil or empty user id and must abort\r\n\r\nnext step:\r\n- add more explanatory text to draft about the fake response",
      "createdAt": "2021-06-02T01:33:38Z",
      "updatedAt": "2023-04-03T09:09:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "fc42616e4908d4ebfa94ca9ff3d93131f05479c6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/fake-credentials",
      "headRefOid": "8a95cdb4aeccfd0457503173aeb7a21776b2273e",
      "closedAt": "2021-06-06T12:37:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #214 ",
          "createdAt": "2021-06-06T12:37:58Z",
          "updatedAt": "2021-06-06T12:37:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 214,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYwMzkwODI3",
      "title": "Take #2 on fake credential test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/214",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A couple open questions:\r\n\r\n1. Does this include everything one would need to verify that KE2 is generated correctly? That seems to be the only thing we actually need to test here. (I don't see much value in testing to make sure the client side, but maybe I'm missing something.)\r\n2. How much work will it be to verify vectors in your respective stacks, @bytemare and @kevinlewi?\r\n",
      "createdAt": "2021-06-02T21:05:42Z",
      "updatedAt": "2023-04-03T09:10:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4b5ad4c8ae3163969bff1eebe6786c379075a0db",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fake-creds",
      "headRefOid": "318709fa772bdd7e12446d276505a24a487bfb11",
      "closedAt": "2021-06-21T23:50:49Z",
      "mergedAt": "2021-06-21T23:50:49Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "544c540321b12efad261bacaf1b4bca35c560c6a"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "1. Since we need to fake a client record, and the envelope is set to 0s, there must be a fake client public key, atop the client identifier and KE2 in the vectors. I added a commit to patch that.\r\n2. Now they work :)",
          "createdAt": "2021-06-06T13:26:47Z",
          "updatedAt": "2021-06-06T13:26:47Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I just pushed a commit which does the following:\r\n\r\n- Introduced a new parameter, `fake_masking_key`, as part of the test vectors. Previously, we were just generating an all-zeros bytestring for this.\r\n- Adds the inputs `fake_client_private_key`, `fake_client_public_key`, and `fake_masking_key` to all of the fake test vectors. Also added supporting text in the sections to explain what these parameters are.\r\n- Removes the intermediates and unnecessary inputs/outputs that existed in fake test vectors, in particular moving KE1 to an input instead of an output, and ensuring that KE2 is the only output.\r\n- Fixed a bug in the existing fake test vector generation case: the previous code was using the \"real\" client pkU to generate KE1 and KE2 instead of the fake one\r\n\r\nThe current commit produces test vectors which match my Rust implementation in opaque-ke.",
          "createdAt": "2021-06-21T00:46:58Z",
          "updatedAt": "2021-06-21T00:48:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Latest amendment to the commit renames `fake_client_private_key`, `fake_client_public_key`, and `fake_masking_key` back to just `client_private_key`, `client_public_key`, and `masking_key`",
          "createdAt": "2021-06-21T17:37:01Z",
          "updatedAt": "2021-06-21T17:37:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MTIyNjc3",
          "commit": {
            "abbreviatedOid": "136cbca"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T01:00:54Z",
          "updatedAt": "2021-06-09T01:00:55Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Suggestion: change to \"IsFake\"?",
              "createdAt": "2021-06-09T01:00:54Z",
              "updatedAt": "2021-06-09T01:00:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5NTY2NDc0",
          "commit": {
            "abbreviatedOid": "136cbca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T12:08:30Z",
          "updatedAt": "2021-06-09T12:08:31Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Alternate proposal: move these vectors to a separate appendix in the doc, so they're not mixed with the real vectors. Would that make it more clear?",
              "createdAt": "2021-06-09T12:08:30Z",
              "updatedAt": "2021-06-09T12:08:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjM1MTMy",
          "commit": {
            "abbreviatedOid": "136cbca"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T21:46:26Z",
          "updatedAt": "2021-06-11T21:46:26Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think that would actually! Great idea. (And sorry for the delayed response on this)\r\n\r\nThis means that we wouldn't need the registration portion at all.\r\n\r\nIn addition, could we still have the client_private_key as a parameter, so that implementations can generate the client_public_key associated with the fake record more easily? Thanks :) ",
              "createdAt": "2021-06-11T21:46:26Z",
              "updatedAt": "2021-06-11T21:46:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTQzNTMw",
          "commit": {
            "abbreviatedOid": "401918e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-18T00:30:40Z",
          "updatedAt": "2021-06-18T00:30:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Pushed! Please give it a shot.",
              "createdAt": "2021-06-18T00:30:40Z",
              "updatedAt": "2021-06-18T00:30:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4ODgxMDE4",
          "commit": {
            "abbreviatedOid": "318709f"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good! Vectors pass \ud83c\udf89\r\n\r\nThank you for the modifications!",
          "createdAt": "2021-06-21T21:36:18Z",
          "updatedAt": "2021-06-21T21:36:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 216,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYzOTE3NzQw",
      "title": "Add correct reference to 3DH and editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/216",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-07T21:15:26Z",
      "updatedAt": "2021-06-07T21:24:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "72ec450e9c4353e888f60497955f905f2ba3f251",
      "headRepository": "claucece/draft-irtf-cfrg-opaque",
      "headRefName": "master",
      "headRefOid": "468ed6eee5554272e39b45c6c40154e608c72d4f",
      "closedAt": "2021-06-07T21:24:59Z",
      "mergedAt": "2021-06-07T21:24:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f59849c625a4eb12ad607476b022700f84a10be9"
      },
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc./ @chris-wood ",
          "createdAt": "2021-06-07T21:15:38Z",
          "updatedAt": "2021-06-07T21:15:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM pending one revert -- thanks!",
          "createdAt": "2021-06-07T21:17:31Z",
          "updatedAt": "2021-06-07T21:17:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3ODkyNDgy",
          "commit": {
            "abbreviatedOid": "76dbf20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T21:16:31Z",
          "updatedAt": "2021-06-07T21:17:07Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "We wrote this intentionally as randomize as that does not assume additive or multiplicative blinding -- can we please revert?",
              "createdAt": "2021-06-07T21:16:31Z",
              "updatedAt": "2021-06-07T21:17:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3ODk1Nzc2",
          "commit": {
            "abbreviatedOid": "468ed6e"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T21:21:33Z",
          "updatedAt": "2021-06-07T21:21:33Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done ;)",
              "createdAt": "2021-06-07T21:21:33Z",
              "updatedAt": "2021-06-07T21:21:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3ODk3OTcz",
          "commit": {
            "abbreviatedOid": "468ed6e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-07T21:24:54Z",
          "updatedAt": "2021-06-07T21:24:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYzOTM1MzEy",
      "title": "Fix some errors. Clarify undefined things.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/218",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #217.",
      "createdAt": "2021-06-07T21:45:57Z",
      "updatedAt": "2021-06-07T22:43:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f59849c625a4eb12ad607476b022700f84a10be9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/clarify-things",
      "headRefOid": "5d52847afaf20f95e44c486d807cf6b6e0355f73",
      "closedAt": "2021-06-07T22:32:02Z",
      "mergedAt": "2021-06-07T22:32:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4b5ad4c8ae3163969bff1eebe6786c379075a0db"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTE5NjAx",
          "commit": {
            "abbreviatedOid": "d6de9f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T21:53:23Z",
          "updatedAt": "2021-06-07T21:53:24Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\n- session_key, the shared session secret if and only if KE3 is valid.\r\n```",
              "createdAt": "2021-06-07T21:53:23Z",
              "updatedAt": "2021-06-07T21:53:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTE5OTY1",
          "commit": {
            "abbreviatedOid": "d6de9f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T21:54:02Z",
          "updatedAt": "2021-06-07T21:54:02Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "This change makes the client and server interfaces different: both either return something, or toss an exception.",
              "createdAt": "2021-06-07T21:54:02Z",
              "updatedAt": "2021-06-07T21:54:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTM5OTA0",
          "commit": {
            "abbreviatedOid": "5d52847"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great changes!",
          "createdAt": "2021-06-07T22:31:18Z",
          "updatedAt": "2021-06-07T22:31:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTQxMzg2",
          "commit": {
            "abbreviatedOid": "5d52847"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T22:34:30Z",
          "updatedAt": "2021-06-07T22:34:30Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "`ScalarBaseMult` is not defined in this document, if I'm not mistaken",
              "createdAt": "2021-06-07T22:34:30Z",
              "updatedAt": "2021-06-07T22:34:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTQ1NzM4",
          "commit": {
            "abbreviatedOid": "5d52847"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T22:43:51Z",
          "updatedAt": "2021-06-07T22:43:51Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "It's in the VOPRF document, Section 2.1 (see the citation added in this PR, which also covers where HashToScalar is introduced.)",
              "createdAt": "2021-06-07T22:43:51Z",
              "updatedAt": "2021-06-07T22:43:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 222,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcyNDY0MTQz",
      "title": "Adding implementation considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/222",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #200 ",
      "createdAt": "2021-06-17T10:00:16Z",
      "updatedAt": "2021-06-22T08:52:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "544c540321b12efad261bacaf1b4bca35c560c6a",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "impl_considerations",
      "headRefOid": "379f59e5a56a977e87711988a5529d3e3b38ca64",
      "closedAt": "2021-06-22T08:52:07Z",
      "mergedAt": "2021-06-22T08:52:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "df639c8407280d1057b76751b6921b694df254c7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2MTM5NDIw",
          "commit": {
            "abbreviatedOid": "abc4b90"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-17T10:30:18Z",
          "updatedAt": "2021-06-17T10:30:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTM3MjI1",
          "commit": {
            "abbreviatedOid": "abc4b90"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-18T00:10:44Z",
          "updatedAt": "2021-06-18T21:48:15Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Can we just cite the VOPRF draft for this? It's unclear what \"element\" means in this context, and it's no longer the responsibility of OPAQUE to do this check since VOPRF handles it accordingly. Instead, we might say that implementations must handle errors raised by the VOPRF APIs and abort accordingly. \r\n\r\nThoughts?",
              "createdAt": "2021-06-18T00:10:44Z",
              "updatedAt": "2021-06-18T00:11:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTM3NDE3",
          "commit": {
            "abbreviatedOid": "abc4b90"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The first two suggestions seem fine, but I have concerns about the last one being in this document. It seems to leak details of the VOPRF internals unnecessarily. ",
          "createdAt": "2021-06-18T00:11:19Z",
          "updatedAt": "2021-06-18T21:48:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4OTU5Mzg3",
          "commit": {
            "abbreviatedOid": "abc4b90"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-22T00:15:11Z",
          "updatedAt": "2021-06-22T00:15:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Sounds good, the new text reads:\r\n\r\n```\r\n- Deserialization checks: When parsing messages that have crossed trust boundaries (e.g.\r\na network wire), implementations should properly handle all error conditions covered in\r\n{{I-D.irtf-cfrg-voprf}} and abort accordingly.\r\n```",
              "createdAt": "2021-06-22T00:15:11Z",
              "updatedAt": "2021-06-22T00:15:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5MjM2MjY2",
          "commit": {
            "abbreviatedOid": "379f59e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-22T08:52:01Z",
          "updatedAt": "2021-06-22T08:52:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 223,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc2MDgzMDEx",
      "title": "Removing oprf_key from output of CreateCredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/223",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #220.\r\n\r\nAlso moves `oprf_key` in test vectors from \"inputs\" to \"intermediates\".",
      "createdAt": "2021-06-23T08:51:08Z",
      "updatedAt": "2021-06-25T15:16:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "df639c8407280d1057b76751b6921b694df254c7",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "remove_oprf_key",
      "headRefOid": "78e6ec0d0e94848159aa4c6ef72ca75efc633652",
      "closedAt": "2021-06-25T15:16:07Z",
      "mergedAt": "2021-06-25T15:16:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e52b7f8aad144ce498c438159c7a95a538700b12"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkyOTI4MTY0",
          "commit": {
            "abbreviatedOid": "78e6ec0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-25T15:16:02Z",
          "updatedAt": "2021-06-25T15:16:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc2MDkwOTc5",
      "title": "Fix fake_ prefixes in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/224",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In this comment (https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/214#issuecomment-865220659) of #214 , I said I removed the fake_ prefixes from some variable names. However, I failed to commit some of those changes. This PR fixes the issue.",
      "createdAt": "2021-06-23T09:01:30Z",
      "updatedAt": "2021-06-25T15:15:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "df639c8407280d1057b76751b6921b694df254c7",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_fake_names",
      "headRefOid": "f88bb27bd6e015308d7992dc75b99bf5fc20ed0e",
      "closedAt": "2021-06-25T15:15:27Z",
      "mergedAt": "2021-06-25T15:15:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "19eb915a66ad8646489f64ee3fbd6fbe534d675d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkyOTI3NTAz",
          "commit": {
            "abbreviatedOid": "f88bb27"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-25T15:15:22Z",
          "updatedAt": "2021-06-25T15:15:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc3MzYwMTk1",
      "title": "Contradictory statements on draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/225",
      "state": "MERGED",
      "author": "jansen44",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've been studying OPAQUE for the last month or so (and I must say I'm in love with it). Yesterday I was reading the draft and found two statements that looked a little contradictory. \r\n\r\nI sent an email asking if one of them was really an accident and @bytemare (at least I think it was him lol) replied me saying that I was correct and also that you guys were accepting pull requests, so here I am :blush:.\r\n\r\n- The first statement is the one that that I sent on the email: this statement at the fourth section, second paragraph:  \"OPAQUE allows applications to either provide custom client private and public keys for authentication, or to generate them internally. [...] These two options are defined as the \"internal\" and \"external\" modes, respectively. [...]\"... I think that \"internal mode\" would better refer to \"generate keys internally\", so the \"respectively\" term was kinda misleading.\r\n- The second statement is at the fourth section, third paragraph: \"The following types of application credential information are considered: client_private_key: The encoded client private key for the AKE protocol.\" Every other item on this list was indeed used and stored inside the `CleartextCredentials` struct, but client_private_key was totally ignored, so I guess it's actually not a credential information to be considered (at least at this context).\r\n\r\nI don't know if any of what I said really makes sense to you guys, but I hope it does help \u270c\ud83c\udffb .",
      "createdAt": "2021-06-24T18:58:10Z",
      "updatedAt": "2021-06-29T01:46:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "df639c8407280d1057b76751b6921b694df254c7",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "b5246cf68746912bd5b3606b76fd3d583f017e75",
      "closedAt": "2021-06-29T01:46:23Z",
      "mergedAt": "2021-06-29T01:46:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d60cb423c875ded5581d667ceabeee7b38c42531"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzMjk1MDI4",
          "commit": {
            "abbreviatedOid": "2968b46"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-26T09:28:45Z",
          "updatedAt": "2021-06-26T09:28:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0MDUwMjI5",
          "commit": {
            "abbreviatedOid": "2968b46"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-28T14:47:54Z",
          "updatedAt": "2021-06-28T14:47:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This is still used (for external mode), so I think we should keep this.",
              "createdAt": "2021-06-28T14:47:54Z",
              "updatedAt": "2021-06-28T14:47:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0NTIxMDU1",
          "commit": {
            "abbreviatedOid": "b5246cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-29T01:45:05Z",
          "updatedAt": "2021-06-29T01:45:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc4MzIyMDI0",
      "title": "Ensure constant-time fake credential response",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/227",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Closes #219 ",
      "createdAt": "2021-06-26T11:24:36Z",
      "updatedAt": "2023-04-03T09:10:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e52b7f8aad144ce498c438159c7a95a538700b12",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/static-fake-record",
      "headRefOid": "9ea94ba75b980f50cc3e8b4a53d697f4975ee18c",
      "closedAt": "2021-06-29T01:41:46Z",
      "mergedAt": "2021-06-29T01:41:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "db3e5e221bee5ab47640d2798a882d953a4c3b75"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare, sorry, I meant to suggest that the comment could go [here](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-appendix.c), at the end of the text in the start of Appendix C.",
          "createdAt": "2021-06-28T23:16:20Z",
          "updatedAt": "2021-06-28T23:16:20Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "> @bytemare, sorry, I meant to suggest that the comment could go [here](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-appendix.c), at the end of the text in the start of Appendix C.\r\n\r\nAh, of course. You mean \"Test Vectors\", right?\r\n",
          "createdAt": "2021-06-29T01:24:42Z",
          "updatedAt": "2021-06-29T01:24:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0MDU3OTIy",
          "commit": {
            "abbreviatedOid": "cb54748"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-28T14:54:09Z",
          "updatedAt": "2021-06-28T14:57:08Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nthe server MUST respond to the credential request to fake the existence of the record.\r\n```",
              "createdAt": "2021-06-28T14:54:09Z",
              "updatedAt": "2021-06-28T14:57:08Z"
            },
            {
              "originalPosition": 21,
              "body": "This should probably move to the test vector section, rather than be listed here.",
              "createdAt": "2021-06-28T14:55:59Z",
              "updatedAt": "2021-06-28T14:57:21Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nIt is RECOMMENDED that a fake client record is created once (e.g. as the first user record\r\nof the application) and stored alongside legitimate client records. This allows servers to locate\r\nthe record in time comparable to that of a legitimate client record.\r\n```",
              "createdAt": "2021-06-28T14:57:04Z",
              "updatedAt": "2021-06-28T14:57:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0NDk1MDEw",
          "commit": {
            "abbreviatedOid": "cdf994e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Can we move the text up to the start of Appendix C?",
          "createdAt": "2021-06-29T00:30:51Z",
          "updatedAt": "2021-06-29T00:30:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0NTE5ODQy",
          "commit": {
            "abbreviatedOid": "9ea94ba"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-29T01:41:40Z",
          "updatedAt": "2021-06-29T01:41:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc5MTE4NjU5",
      "title": "Note TLS wire format syntax.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/228",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #226.",
      "createdAt": "2021-06-28T14:52:00Z",
      "updatedAt": "2021-06-29T01:42:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e52b7f8aad144ce498c438159c7a95a538700b12",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/syntax-note",
      "headRefOid": "09c996c63cb0f6e80e9d1f1bde5904e58965cb9d",
      "closedAt": "2021-06-29T01:42:10Z",
      "mergedAt": "2021-06-29T01:42:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "65be0747a26c333c276eeb264f80b48244d22212"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0NTE1NTk0",
          "commit": {
            "abbreviatedOid": "09c996c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-29T01:29:37Z",
          "updatedAt": "2021-06-29T01:29:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgxOTY2NzA4",
      "title": "Fix parameter order. Clarify DH value concatenation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/231",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #229, #230.",
      "createdAt": "2021-07-01T15:33:40Z",
      "updatedAt": "2021-07-01T18:45:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d60cb423c875ded5581d667ceabeee7b38c42531",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/rearrange",
      "headRefOid": "ce8c13495d03574a0c23cd1eb00ac523a334ae40",
      "closedAt": "2021-07-01T18:45:53Z",
      "mergedAt": "2021-07-01T18:45:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "707b784cad1168e8e63ece31ff6e9cefa3f38fd2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3NTQyNTk1",
          "commit": {
            "abbreviatedOid": "ce8c134"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-01T18:26:20Z",
          "updatedAt": "2021-07-01T18:26:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgxOTY4ODU5",
      "title": "Clarify what's stored on the server during registration.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/232",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #221.\r\n\r\ncc @claucece ",
      "createdAt": "2021-07-01T15:36:42Z",
      "updatedAt": "2021-07-01T23:00:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d60cb423c875ded5581d667ceabeee7b38c42531",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/clarify-storage",
      "headRefOid": "44fd6285397cb8ef6cfa5971bf75a0a2cbd77ed8",
      "closedAt": "2021-07-01T19:05:33Z",
      "mergedAt": "2021-07-01T19:05:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7f009d925fcfc06e31efb42333f009aa4a53aad5"
      },
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "awesome! thank you @chris-wood ",
          "createdAt": "2021-07-01T23:00:03Z",
          "updatedAt": "2021-07-01T23:00:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3NTY3MjYy",
          "commit": {
            "abbreviatedOid": "44fd628"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-01T19:00:40Z",
          "updatedAt": "2021-07-01T19:00:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgyMDI5MDE4",
      "title": "Clarify enumeration prevention limitations.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/233",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #210.\r\n\r\n",
      "createdAt": "2021-07-01T17:05:24Z",
      "updatedAt": "2021-07-01T19:05:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d60cb423c875ded5581d667ceabeee7b38c42531",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/clarify-enumeration",
      "headRefOid": "6322c9379517d93ab79c4a1c5369b52f573c17c3",
      "closedAt": "2021-07-01T19:05:42Z",
      "mergedAt": "2021-07-01T19:05:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5a76b127367d95cfd54848485b60952ec4cff0b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3NTM3NjY0",
          "commit": {
            "abbreviatedOid": "6322c93"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-01T18:19:18Z",
          "updatedAt": "2021-07-01T18:19:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3NTY2OTM5",
          "commit": {
            "abbreviatedOid": "6322c93"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great!",
          "createdAt": "2021-07-01T19:00:13Z",
          "updatedAt": "2021-07-01T19:00:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2MjA3Mjc4",
      "title": "Adding note on low entropy OPRF key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/235",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-08T17:40:18Z",
      "updatedAt": "2021-07-08T18:21:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5a76b127367d95cfd54848485b60952ec4cff0b8",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_low_entropy_key_note",
      "headRefOid": "b148809a2744524f9613979897e21b61aab08570",
      "closedAt": "2021-07-08T18:21:02Z",
      "mergedAt": "2021-07-08T18:21:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "65b3a841803740b0363dbf60ac4a6f8acc3c8caf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAyMzcyODY2",
          "commit": {
            "abbreviatedOid": "b148809"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-08T18:20:58Z",
          "updatedAt": "2021-07-08T18:20:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2MjQ5MTI5",
      "title": "set state.ke1 in client Start, removed unused ke1 input",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/236",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi, found this while implementing the protocol. You can always set the value outside, but I think adding this step `state.ke1 = ke1` inside `Start` is very convenient and aligned with the use of `state.ke1` inside `ClientFinalize`.",
      "createdAt": "2021-07-08T18:51:36Z",
      "updatedAt": "2021-08-15T22:25:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "65b3a841803740b0363dbf60ac4a6f8acc3c8caf",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "client-start",
      "headRefOid": "18c6004bf6021b26c0f8e492b7d233cbedb519d0",
      "closedAt": "2021-08-15T21:09:15Z",
      "mergedAt": "2021-08-15T21:09:15Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "2726794ee58f41fa5b0ae5d441afdd28d0797105"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "These are indeed leftovers, as the value has already been taken out in the declaration and elsewhere. Good catch! ",
          "createdAt": "2021-07-21T16:36:17Z",
          "updatedAt": "2021-07-21T16:36:17Z"
        },
        {
          "author": "aldenml",
          "authorAssociation": "CONTRIBUTOR",
          "body": "glad to have a contribution here",
          "createdAt": "2021-07-22T12:57:18Z",
          "updatedAt": "2021-07-22T12:57:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExOTE4Mjk0",
          "commit": {
            "abbreviatedOid": "18c6004"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-21T16:36:33Z",
          "updatedAt": "2021-07-21T16:36:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 237,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2MzczOTMy",
      "title": "Update VOPRF dependency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/237",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, restructure the dependency section and spell out DeriveKeyPair implementation(s). ",
      "createdAt": "2021-07-08T22:55:57Z",
      "updatedAt": "2021-07-12T22:06:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "65b3a841803740b0363dbf60ac4a6f8acc3c8caf",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/update-voprf",
      "headRefOid": "0bc139e793be5ad78dd1e814a14140b969d3285c",
      "closedAt": "2021-07-12T22:06:10Z",
      "mergedAt": "2021-07-12T22:06:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "121922cdfd5c13e03dabdc009968b3fd82f84bd8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAyNzgxMTcy",
          "commit": {
            "abbreviatedOid": "d9de3da"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-07-09T07:55:31Z",
          "updatedAt": "2021-07-09T08:45:50Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The client must not learn the server's input either",
              "createdAt": "2021-07-09T07:55:31Z",
              "updatedAt": "2021-07-09T08:45:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzMDI3MTY1",
          "commit": {
            "abbreviatedOid": "d9de3da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-09T13:03:36Z",
          "updatedAt": "2021-07-09T13:03:36Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nAn Oblivious Pseudorandom Function (OPRF) is a two-party protocol between client and\r\nserver for computing a PRF such that the client learns the PRF output and neither party learns\r\nthe input of the other. This specification uses the the OPRF defined in {{!I-D.irtf-cfrg-voprf}},\r\n```",
              "createdAt": "2021-07-09T13:03:36Z",
              "updatedAt": "2021-07-09T13:03:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0NTgyNjQ0",
          "commit": {
            "abbreviatedOid": "0bc139e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good, and ristretto255 test vectors match my implementation.",
          "createdAt": "2021-07-12T22:06:01Z",
          "updatedAt": "2021-07-12T22:06:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0NzExNTM3Mzky",
      "title": "Editorial pass.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/250",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to improve motivation for the two modes beyond what's here, so I'm open to suggestions. If we can't conceive of a good motivation for external mode, we might even consider dropping it entirely. =)",
      "createdAt": "2021-08-12T20:16:51Z",
      "updatedAt": "2021-08-23T16:08:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "121922cdfd5c13e03dabdc009968b3fd82f84bd8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/edits",
      "headRefOid": "71f6d861b8fdffc65cce2bebdba249e776091e03",
      "closedAt": "2021-08-23T16:08:21Z",
      "mergedAt": "2021-08-23T16:08:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c47d34f0c3ad76d738cfdb59e5ff9f5a0d7f00e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwMjE3Mjcy",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-15T20:21:43Z",
          "updatedAt": "2021-08-15T21:10:33Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This will need vector updates",
              "createdAt": "2021-08-15T20:21:43Z",
              "updatedAt": "2021-08-15T21:10:33Z"
            },
            {
              "originalPosition": 48,
              "body": "Another argument for support for the external mode is the usage of cryptographic primitives for the AKE that don't support key pair creation/recovery from the OPRF output. I'm not familiar enough with the PQ algos to know whether this is relevant to them. To me, the internal mode directly ties the OPRF and AKE whereas the external mode is a proxy that allows more latitude.\r\n\r\nThough I'm not particularly in favor of the external mode, this remains to be considered. If the argument above doesn't hold for any potential AKE, I don't see strong reasons to keep this mode.",
              "createdAt": "2021-08-15T20:28:38Z",
              "updatedAt": "2021-08-15T21:10:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwODA4Mjgy",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-16T14:50:19Z",
          "updatedAt": "2021-08-16T14:50:19Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yeah, I'll do that in a separate commit.",
              "createdAt": "2021-08-16T14:50:19Z",
              "updatedAt": "2021-08-16T14:50:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwODA5NTc3",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-16T14:51:25Z",
          "updatedAt": "2021-08-16T14:51:26Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "> Another argument for support for the external mode is the usage of cryptographic primitives for the AKE that don't support key pair creation/recovery from the OPRF output.\r\n\r\nI can't see how this would be the case. Fundamentally, there must be some way for any key for any protocol to be derived from any sufficient amount of randomness, so it seems like internal mode will _always_ work.",
              "createdAt": "2021-08-16T14:51:25Z",
              "updatedAt": "2021-08-16T14:51:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwODIzMjYx",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-16T15:03:10Z",
          "updatedAt": "2021-08-16T15:03:11Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "@hugokraw, what would be your argument for keeping external mode?",
              "createdAt": "2021-08-16T15:03:10Z",
              "updatedAt": "2021-08-16T15:03:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwODMxMDY1",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-16T15:10:19Z",
          "updatedAt": "2021-08-16T15:10:19Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "isn't smaller packet sizes and generally smaller communication overhead an argument? imagine you have to run this over some low bandwidth radio connection that does afsk1200 for example...",
              "createdAt": "2021-08-16T15:10:19Z",
              "updatedAt": "2021-08-16T15:10:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwODMyNjU0",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-16T15:11:50Z",
          "updatedAt": "2021-08-16T15:11:50Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "@stef I think external mode is more costly in terms of bandwidth, no? (Or maybe you meant a argument _against_ external mode, which I would agree with.)",
              "createdAt": "2021-08-16T15:11:50Z",
              "updatedAt": "2021-08-16T15:11:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwODM5MTQ2",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-16T15:17:43Z",
          "updatedAt": "2021-08-16T15:17:43Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "oh. i guess i'm mistaken, sorry. long time that i looked at the spec, i thought external refers to the keys being derived and not packed in the credentials structure (whatever that is called now)\r\nnote to self: read the spec before smartassing again...",
              "createdAt": "2021-08-16T15:17:43Z",
              "updatedAt": "2021-08-16T15:17:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMxMzA2ODg3",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-17T03:43:56Z",
          "updatedAt": "2021-08-17T03:43:57Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "> @hugokraw, what would be your argument for keeping external mode?\r\n\r\nWe had a long discussion on this in the past. It is mathematically true that one can always run a key generation on a (pseudo) random seed. But different KG cases will have different complexity. For example, for RSA you would need to test numbers for primality, etc.  (there are some ways to simplify this in the case of RSA). The case where the external method is essential is if the key is imported and not generated at the time of key registration. I don't have a case in mind where this would be essential. Since this is not a security question I would defer to you guys on deciding this. If you remove it, I would still leave a note that applications with complicated KGs or those that are interested to import keys may decide to add the key to the envelope (although this mechanism is not specified here).",
              "createdAt": "2021-08-17T03:43:56Z",
              "updatedAt": "2021-08-17T03:43:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMyNTM0NDI2",
          "commit": {
            "abbreviatedOid": "cbdd10a"
          },
          "author": "tlepoint",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-18T07:40:59Z",
          "updatedAt": "2021-08-18T07:40:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM1NDA5NTI1",
          "commit": {
            "abbreviatedOid": "71f6d86"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Everything looks good, vectors included \u2714\ufe0f ",
          "createdAt": "2021-08-20T21:57:16Z",
          "updatedAt": "2021-08-20T21:57:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE3MDgwNzY5",
      "title": "Redefine OPAQUE composition and modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/255",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses #251. Some redefinitions, mostly rewording and moving things around.\r\n\r\n- Redefine OPAQUE as OPRF + Key Recovery + AKE\r\n- Focus the Key Recovery on internal mode only and move the external mode to the appendix\n- Remove mode as a configuration element\r\n- attempt at more abstraction\r\n\r\nThere are probably some things I did not see, I apologize in advance \ud83d\ude4f ",
      "createdAt": "2021-08-21T03:13:55Z",
      "updatedAt": "2021-08-25T19:14:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "c47d34f0c3ad76d738cfdb59e5ff9f5a0d7f00e6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/redefinition",
      "headRefOid": "21b2db28d95b53a0405acb4a37803e089ae20026",
      "closedAt": "2021-08-25T19:14:20Z",
      "mergedAt": "2021-08-25T19:14:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f28f7a1d01e50955e4b8bda48e5a25d4f91ee37e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM2NjQxODA5",
          "commit": {
            "abbreviatedOid": "7257d89"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "First pass complete. I think this needs some work, but I'm happy to land it soon-ish.",
          "createdAt": "2021-08-23T23:17:11Z",
          "updatedAt": "2021-08-23T23:37:41Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-08-23T23:18:13Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nOPAQUE relies on a key recovery mechanism for storing and recovering authentication\r\nmaterial on the server. The key recovery storage mechanism takes as input a private \r\nseed and outputs an envelope. The retrieval process takes as input a private seed\r\nand envelope and outputs authentication material. The signatures for these \r\nfunctionalities are below:\r\n\r\n- Store(private_seed): build and return an `Envelope` structure\r\n- Recover(private_seed, envelope): recover and return the authentication material\r\nfor the AKE from the Envelope.\r\n\r\nThe key recovery mechanism MUST be compatible with the chosen AKE.\r\n```\r\n\r\nSimplifying?",
              "createdAt": "2021-08-23T23:26:56Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 72,
              "body": "```suggestion\r\nOPAQUE additionally depends on a three-message Authenticated Key Exchange (AKE) protocol \r\nwhich satisfies the forward secrecy and KCI properties discussed in {{sec-considerations}}.\r\n```",
              "createdAt": "2021-08-23T23:28:40Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n```\r\n\r\nLet's move this stuff around in a separate change.",
              "createdAt": "2021-08-23T23:30:04Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 259,
              "body": "Should this go in the AKE section? It seems kinda out of place here.",
              "createdAt": "2021-08-23T23:32:36Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 476,
              "body": "Why is this here?",
              "createdAt": "2021-08-23T23:32:51Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 521,
              "body": "I would drop all of this text entirely, and just say that it's possible to implement another form of Envelope with a different protocol version. ",
              "createdAt": "2021-08-23T23:33:24Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 85,
              "body": "Maybe we can rewrite this as, \"The AKE protocol messages are constructed using the following functions:\"",
              "createdAt": "2021-08-23T23:35:20Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 127,
              "body": "```suggestion\r\nFuture variants of OPAQUE may use different key recovery mechanisms. See {{key-recovery}} for details.\r\n```",
              "createdAt": "2021-08-23T23:35:59Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 150,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-08-23T23:36:34Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            },
            {
              "originalPosition": 136,
              "body": "This seems like it belongs with the dependency section up top, where other parameters and constants are defined.",
              "createdAt": "2021-08-23T23:37:05Z",
              "updatedAt": "2021-08-23T23:37:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MDAwMDQz",
          "commit": {
            "abbreviatedOid": "7257d89"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:20:27Z",
          "updatedAt": "2021-08-24T09:20:28Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Yeah, much better, thanks!\r\nI suggest a little tweak though, to avoid any confusion on where the recovery takes place:\r\n\r\n```suggestion\r\nOPAQUE relies on a key recovery mechanism for storing authentication\r\nmaterial on the server and recovering it on the client. The key recovery storage\r\nmechanism takes as input a private seed and outputs an envelope. The retrieval\r\nprocess takes as input a private seed and envelope and outputs authentication\r\nmaterial. The signatures for these functionalities are below:\r\n\r\n- Store(private_seed): build and return an `Envelope` structure\r\n- Recover(private_seed, envelope): recover and return the authentication material\r\nfor the AKE from the Envelope.\r\n\r\nThe key recovery mechanism MUST be compatible with the chosen AKE.\r\n```\r\n\r\n Also, before _\"The key recovery storage mechanism takes as input a private seed and outputs an envelope.\"_ we don't define earlier what an envelope is. Do you think we should or leave it like that?",
              "createdAt": "2021-08-24T09:20:27Z",
              "updatedAt": "2021-08-24T09:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MDA3MzI1",
          "commit": {
            "abbreviatedOid": "7257d89"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:28:12Z",
          "updatedAt": "2021-08-24T09:28:12Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "Yes, and reference this bit from here \ud83d\udc4d ",
              "createdAt": "2021-08-24T09:28:12Z",
              "updatedAt": "2021-08-24T09:28:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MDExMTQy",
          "commit": {
            "abbreviatedOid": "7257d89"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:32:07Z",
          "updatedAt": "2021-08-24T09:32:08Z",
          "comments": [
            {
              "originalPosition": 476,
              "body": "Not sure why it ended up here. I want to define it in the AKE section, since this function is only used there, for the client and server to get their DH keys. I'll revert and work over that in a different PR",
              "createdAt": "2021-08-24T09:32:07Z",
              "updatedAt": "2021-08-24T09:32:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MDExODc3",
          "commit": {
            "abbreviatedOid": "7257d89"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:32:57Z",
          "updatedAt": "2021-08-24T09:32:57Z",
          "comments": [
            {
              "originalPosition": 521,
              "body": "I thought we said to move it to the appendix",
              "createdAt": "2021-08-24T09:32:57Z",
              "updatedAt": "2021-08-24T09:32:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MDE2MTk1",
          "commit": {
            "abbreviatedOid": "8c9caa6"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:37:27Z",
          "updatedAt": "2021-08-24T09:37:27Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "typo?",
              "createdAt": "2021-08-24T09:37:27Z",
              "updatedAt": "2021-08-24T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MDM0ODYy",
          "commit": {
            "abbreviatedOid": "621a85e"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:57:23Z",
          "updatedAt": "2021-08-24T09:57:23Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I re-added `and the client's public key.` to the `Store()` signature, as it's necessary",
              "createdAt": "2021-08-24T09:57:23Z",
              "updatedAt": "2021-08-24T09:57:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3NzE1Njg5",
          "commit": {
            "abbreviatedOid": "a733681"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T21:37:28Z",
          "updatedAt": "2021-08-24T21:37:29Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It's no longer relevant with the new changes.",
              "createdAt": "2021-08-24T21:37:28Z",
              "updatedAt": "2021-08-24T21:37:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3NzE2MDQx",
          "commit": {
            "abbreviatedOid": "a733681"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Few more editorial concerns, then I think we can safely land this!",
          "createdAt": "2021-08-24T21:38:02Z",
          "updatedAt": "2021-08-24T22:07:13Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nis encapsulated in an envelope, whose structure, encoding,\r\n```",
              "createdAt": "2021-08-24T21:38:02Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-08-24T21:39:27Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\n- Recover(private_seed, envelope): recover and return the authentication\r\nmaterial for the AKE from the Envelope. This function raises an error if the\r\nprivate seed cannot be used for recovering authentication material from the\r\ninput envelope.\r\n```",
              "createdAt": "2021-08-24T21:46:01Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nThe key recovery mechanism MUST return an error when trying to recover authentication\r\nmaterial from an envelope with a private seed that was not used in producing the envelope.\r\n```",
              "createdAt": "2021-08-24T21:48:22Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 136,
              "body": "This entire section seems not very useful. Can we delete it?",
              "createdAt": "2021-08-24T21:49:58Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 160,
              "body": "```suggestion\r\nThe key recovery mechanism defines its `Envelope` as follows:\r\n```",
              "createdAt": "2021-08-24T21:50:14Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 264,
              "body": "```suggestion\r\n     raise KeyRecoveryError\r\n```",
              "createdAt": "2021-08-24T21:51:15Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 449,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-08-24T21:52:01Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 227,
              "body": "This hasn't been defined yet. It was in the overview section, but now it's down below... hmm.",
              "createdAt": "2021-08-24T21:55:00Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 690,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-08-24T22:03:44Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 704,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-08-24T22:04:02Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 650,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-08-24T22:04:13Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            },
            {
              "originalPosition": 648,
              "body": "```suggestion\r\nClient authentication material can be stored and retrieved using different key\r\nrecovery mechanisms, provided these mechanisms adhere to the requirements \r\nspecified in {{deps-keyrec}}. Any key recovery mechanism that encrypts data\r\nin the envelope MUST use an authenticated encryption scheme with random\r\nkey-robustness (or key-committing). Deviating from the key-robustness \r\nrequirement may open the protocol to attacks, e.g., {{LGR20}}.\r\nThis specification enforces this property by using a MAC over the envelope \r\ncontents. \r\n\r\nWe remark that export_key for authentication or encryption requires \r\nno special properties from the authentication or encryption schemes \r\nas long as export_key is used only after authentication material is successfully\r\nrecovered, i.e., after the MAC in RecoverCredentials passes verification.\r\n```",
              "createdAt": "2021-08-24T22:07:02Z",
              "updatedAt": "2021-08-24T22:07:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3NzQ4ODgx",
          "commit": {
            "abbreviatedOid": "a733681"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T22:35:48Z",
          "updatedAt": "2021-08-24T22:35:49Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "That's why I'm referring to it some lines above, l. 595",
              "createdAt": "2021-08-24T22:35:48Z",
              "updatedAt": "2021-08-24T22:35:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3ODAwMzA4",
          "commit": {
            "abbreviatedOid": "21b2db2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-25T00:40:32Z",
          "updatedAt": "2021-08-25T00:40:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3ODAxMTM5",
          "commit": {
            "abbreviatedOid": "7257d89"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-25T00:42:45Z",
          "updatedAt": "2021-08-25T00:42:46Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "What do you think?\r\n\r\nI think that referencing `DeriveAuthKeyPair()` here makes sense for that the following functions.",
              "createdAt": "2021-08-25T00:42:46Z",
              "updatedAt": "2021-08-25T00:42:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3ODAxNDgz",
          "commit": {
            "abbreviatedOid": "7257d89"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-25T00:43:43Z",
          "updatedAt": "2021-08-25T00:43:43Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "Or maybe we could add a line to show that this fills the requirement of compatibility with the AKE",
              "createdAt": "2021-08-25T00:43:43Z",
              "updatedAt": "2021-08-25T00:43:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM4NzI2MDM5",
          "commit": {
            "abbreviatedOid": "21b2db2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2021-08-25T19:00:16Z",
          "updatedAt": "2021-08-25T19:00:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIwNjYxMjc0",
      "title": "Add ASCII Login Flowchart",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/259",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses Login from #258",
      "createdAt": "2021-08-26T16:11:15Z",
      "updatedAt": "2023-03-20T23:22:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f28f7a1d01e50955e4b8bda48e5a25d4f91ee37e",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/flowchart-login",
      "headRefOid": "47f4f7312e4be1a5c1d2a2da3b53104ecf382895",
      "closedAt": "2021-10-13T16:55:14Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this in favor of discussions in #258 ",
          "createdAt": "2021-10-13T16:55:14Z",
          "updatedAt": "2021-10-13T16:55:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 260,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIwODI0ODgx",
      "title": "Clarifications around credential identifier",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/260",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Renames any instances of \"client identifier\" and \"server identifier\" to instead read as \"client identity\" and \"server identity\" to avoid confusion\r\n- Renames \"client credential identifier\" to simply be \"credential identifier\"\r\n- Editorial changes around the description of the credential identifier when passed in as parameters to APIs.\r\n- Instead of saying applications SHOULD set credential identifier to be equal to client identity, instead now reads as \"For simplicity, applications may choose to set `credential_identifier` to be equal to `client_identity`.\"\r\n\r\nCloses #247 ",
      "createdAt": "2021-08-26T20:33:18Z",
      "updatedAt": "2021-08-26T22:48:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f28f7a1d01e50955e4b8bda48e5a25d4f91ee37e",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "credential_identifier",
      "headRefOid": "e3975a71e95c1d4adddd8e2056c09c46e80077c1",
      "closedAt": "2021-08-26T22:48:13Z",
      "mergedAt": "2021-08-26T22:48:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0bd1a9afc809dbf570c046d8785f6d7b4906f436"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM5OTk3MTUx",
          "commit": {
            "abbreviatedOid": "e3975a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-26T22:48:10Z",
          "updatedAt": "2021-08-26T22:48:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 261,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIwODM3ODY5",
      "title": "Comment about client-side hardening in security considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/261",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "New text added to the OPRF hardening sub-section of the Security Considerations section, see below:\r\n\r\nHardening the output of the OPRF greatly increases the cost of an offline\r\nattack upon the compromise of the credential file at the server. Applications\r\nSHOULD select parameters that balance cost and complexity. Note that in\r\nOPAQUE, the hardening function is executed by the client, as opposed to\r\nthe server. This means that applications must consider a tradeoff between the\r\nperformance of the protocol on clients (specifically low-end devices) and\r\nprotection against offline attacks after a server compromise.\r\n\r\nCloses #239 ",
      "createdAt": "2021-08-26T20:56:39Z",
      "updatedAt": "2021-08-26T22:48:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f28f7a1d01e50955e4b8bda48e5a25d4f91ee37e",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "hardening",
      "headRefOid": "ca91f5f82588a57cb73a685e4189223d88684219",
      "closedAt": "2021-08-26T22:48:59Z",
      "mergedAt": "2021-08-26T22:48:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "bb2f28e0bb48dc147ab51cf55509131c5e2c0868"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM5OTk3NTYx",
          "commit": {
            "abbreviatedOid": "ca91f5f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-26T22:48:54Z",
          "updatedAt": "2021-08-26T22:48:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 262,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIxOTk5MjEx",
      "title": "fix leftover function parameter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/262",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Apparently leftover from last PR",
      "createdAt": "2021-08-29T18:35:04Z",
      "updatedAt": "2023-04-03T09:09:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "bb2f28e0bb48dc147ab51cf55509131c5e2c0868",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/redefinition",
      "headRefOid": "4ccf9642f6ec622a21f2099939709431316ff697",
      "closedAt": "2021-08-30T13:34:53Z",
      "mergedAt": "2021-08-30T13:34:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2161a40026e7f94a270c142bb164eb5a544f341e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQxNjU1MDQy",
          "commit": {
            "abbreviatedOid": "4ccf964"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-30T13:34:49Z",
          "updatedAt": "2021-08-30T13:34:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIyMDM4NzA5",
      "title": "Abstract AKE definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/263",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses #242 and #254\r\n\r\n- define high-level AKE API in the dependencies section\r\n- Move OPAQUE messages and external API to Protocol Overview\r\n- minor factoring in the core 3DH functions",
      "createdAt": "2021-08-29T23:31:56Z",
      "updatedAt": "2023-04-03T09:09:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "bb2f28e0bb48dc147ab51cf55509131c5e2c0868",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/ake-rewrite",
      "headRefOid": "72e687515623da60c6653a908642079eb60fdae0",
      "closedAt": "2021-10-05T15:53:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 265,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI3MzAzOTQx",
      "title": "Abstract KEx messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/265",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses #254 \r\n\r\n- define all \"external\" messages in the protocol overview section",
      "createdAt": "2021-09-04T22:08:38Z",
      "updatedAt": "2021-09-21T22:27:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2161a40026e7f94a270c142bb164eb5a544f341e",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/abstract-messages",
      "headRefOid": "f177ce8cc256b43b93d4970f90e5a68417fabec0",
      "closedAt": "2021-09-21T22:27:21Z",
      "mergedAt": "2021-09-21T22:27:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ee8e545c956c4ccc693d603192f920179c1922e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwMDQyNTcy",
          "commit": {
            "abbreviatedOid": "f177ce8"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-09-09T08:32:35Z",
          "updatedAt": "2021-09-09T08:32:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4tUVzj",
          "commit": {
            "abbreviatedOid": "f177ce8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T22:27:15Z",
          "updatedAt": "2021-09-21T22:27:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 269,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMwMTU0MTM3",
      "title": "Move AKE API to deps section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/269",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/242 and moves around some things for clarity.",
      "createdAt": "2021-09-09T04:03:13Z",
      "updatedAt": "2021-09-09T04:05:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2161a40026e7f94a270c142bb164eb5a544f341e",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/ake-deps",
      "headRefOid": "65e2595e705fbb2cca194044855943f50c1a71b5",
      "closedAt": "2021-09-09T04:04:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 270,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMwMTYyNTQ3",
      "title": "Move AKE API to deps section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/270",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses #242 and moves around some things for clarity.\r\n\r\nThis PR derives from and depends on #265",
      "createdAt": "2021-09-09T04:23:15Z",
      "updatedAt": "2023-04-03T09:09:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "dbz/abstract-messages",
      "baseRefOid": "f177ce8cc256b43b93d4970f90e5a68417fabec0",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/ake-deps",
      "headRefOid": "6b829c93b8d86941eafbdc82be4ad94ac00d71cd",
      "closedAt": "2021-09-30T21:19:13Z",
      "mergedAt": "2021-09-30T21:19:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5bcd4aaf6808c49fff8e7c66ba43b4e2e4c2ccdb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4tL3N0",
          "commit": {
            "abbreviatedOid": "d46ad8e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This change looks fine by me, although @chris-wood should take a look as well!",
          "createdAt": "2021-09-18T18:54:37Z",
          "updatedAt": "2021-09-18T18:55:26Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "extra comma here",
              "createdAt": "2021-09-18T18:54:38Z",
              "updatedAt": "2021-09-18T18:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tWN-U",
          "commit": {
            "abbreviatedOid": "1a1387e"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-22T11:43:52Z",
          "updatedAt": "2021-09-22T11:43:52Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "thanks! fixed :)",
              "createdAt": "2021-09-22T11:43:52Z",
              "updatedAt": "2021-09-22T11:43:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tYtAa",
          "commit": {
            "abbreviatedOid": "1a1387e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-09-22T22:08:14Z",
          "updatedAt": "2021-09-22T22:12:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n- ClientFinish(client_identity, client_private_key,\r\n```",
              "createdAt": "2021-09-22T22:08:14Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nserver_identity, server_public_key, `AKE_Init`): upon receipt of the server's\r\n```\r\n(and below for the server piece too)",
              "createdAt": "2021-09-22T22:08:27Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nclient_public_key, `AKE_Init`): upon receipt of a client's request `AKE_Init`,\r\n```",
              "createdAt": "2021-09-22T22:08:34Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n- ServerFinish(`AKE_Finalize`): upon receipt of a client's final AKE message\r\n```",
              "createdAt": "2021-09-22T22:08:40Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nThe AKE must define three messages `AuthInit`, `AuthResponse` and `AuthFinish`\r\n```",
              "createdAt": "2021-09-22T22:09:01Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 54,
              "body": "Can we revert this state change? It's separate from the AKE abstraction changes and (I think) sort of complicates presentation now. ",
              "createdAt": "2021-09-22T22:09:42Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\n## Client Authentication Functions {#opaque-client}\r\n```",
              "createdAt": "2021-09-22T22:10:06Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\n## Server Authentication Functions {#opaque-server}\r\n```",
              "createdAt": "2021-09-22T22:10:19Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            },
            {
              "originalPosition": 208,
              "body": "Don't we still need a function to call to get the `session_key` on the server side? (ServerFinish is the function for this, but I don't see why it's defined way below and not here?)",
              "createdAt": "2021-09-22T22:11:53Z",
              "updatedAt": "2021-09-22T22:12:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tY3XX",
          "commit": {
            "abbreviatedOid": "3c61467"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-22T23:36:13Z",
          "updatedAt": "2021-09-22T23:36:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Do you prefer it in another PR or totally absent?",
              "createdAt": "2021-09-22T23:36:13Z",
              "updatedAt": "2021-09-22T23:36:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tZABp",
          "commit": {
            "abbreviatedOid": "c5b8dae"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T01:22:34Z",
          "updatedAt": "2021-09-23T01:22:34Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "Yeah, but I was hesitant in describing it here, since this part is generic without any details about the AKE. Specifying ServerFinish here will start talking about 3DH before the dedicated AKE section (if that makes sense)",
              "createdAt": "2021-09-23T01:22:34Z",
              "updatedAt": "2021-09-23T01:22:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tagpk",
          "commit": {
            "abbreviatedOid": "c5b8dae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-23T12:03:58Z",
          "updatedAt": "2021-09-23T12:03:59Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Right now, I lean towards it being totally absent, but we can always reassess in a followup PR.",
              "createdAt": "2021-09-23T12:03:59Z",
              "updatedAt": "2021-09-23T12:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tdOUZ",
          "commit": {
            "abbreviatedOid": "c5b8dae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T02:01:26Z",
          "updatedAt": "2021-09-24T02:01:26Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "Well, wouldn't _any_ AKE need this final function on the server? How does the server get the session key otherwise?",
              "createdAt": "2021-09-24T02:01:26Z",
              "updatedAt": "2021-09-24T07:11:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tdsTz",
          "commit": {
            "abbreviatedOid": "c5b8dae"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T07:14:22Z",
          "updatedAt": "2021-09-24T07:14:22Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "Of course, but the internals of this function differ from one AKE to the other",
              "createdAt": "2021-09-24T07:14:22Z",
              "updatedAt": "2021-09-24T07:14:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tdsnu",
          "commit": {
            "abbreviatedOid": "c5b8dae"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-24T07:16:04Z",
          "updatedAt": "2021-09-24T07:16:04Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Alright. I need to adapt the API to ask for the arguments that would otherwise be in the state",
              "createdAt": "2021-09-24T07:16:04Z",
              "updatedAt": "2021-09-24T07:16:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4txRgD",
          "commit": {
            "abbreviatedOid": "640b8d5"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-30T13:50:52Z",
          "updatedAt": "2021-09-30T13:50:52Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Reverted \ud83d\udc4d ",
              "createdAt": "2021-09-30T13:50:52Z",
              "updatedAt": "2021-09-30T13:50:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4txgAb",
          "commit": {
            "abbreviatedOid": "6f5af1f"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-30T14:34:31Z",
          "updatedAt": "2021-09-30T14:34:31Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "You're right, the function should still be described here. I described the necessary behaviour and API constraints of ServerFinish() in general. What do you think of that update?",
              "createdAt": "2021-09-30T14:34:31Z",
              "updatedAt": "2021-09-30T14:34:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tzBPF",
          "commit": {
            "abbreviatedOid": "6f5af1f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Let's merge this and do things in followup changes!",
          "createdAt": "2021-09-30T21:09:00Z",
          "updatedAt": "2021-09-30T21:14:56Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nBoth ClientFinish and ServerFinish return an error if authentication failed.\r\n```",
              "createdAt": "2021-09-30T21:09:00Z",
              "updatedAt": "2021-09-30T21:14:56Z"
            },
            {
              "originalPosition": 11,
              "body": "Maybe make this `ClientStart`?",
              "createdAt": "2021-09-30T21:10:28Z",
              "updatedAt": "2021-09-30T21:14:56Z"
            },
            {
              "originalPosition": 19,
              "body": "Maybe make this `ServerStart`?",
              "createdAt": "2021-09-30T21:10:38Z",
              "updatedAt": "2021-09-30T21:14:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 271,
      "id": "PR_kwDOD79ejs4sKUx-",
      "title": "Cite Argon2 RFC.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/271",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #268.",
      "createdAt": "2021-09-22T22:14:14Z",
      "updatedAt": "2021-09-23T12:02:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ee8e545c956c4ccc693d603192f920179c1922e9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/cite-argon2",
      "headRefOid": "da2ace69f143777abcac943fab1fee82aeccfaf8",
      "closedAt": "2021-09-23T12:02:00Z",
      "mergedAt": "2021-09-23T12:02:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "86a3394fd715f8685f7f37717b97351103bb0b59"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2021-09-22T23:16:52Z",
          "updatedAt": "2021-09-22T23:16:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4tZE4a",
          "commit": {
            "abbreviatedOid": "da2ace6"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-23T02:34:12Z",
          "updatedAt": "2021-09-23T02:34:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 272,
      "id": "PR_kwDOD79ejs4sKVE3",
      "title": "Note that configuration agreement is necessary for the protocol to run.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/272",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #246.",
      "createdAt": "2021-09-22T22:16:28Z",
      "updatedAt": "2021-09-23T12:02:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ee8e545c956c4ccc693d603192f920179c1922e9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/note-configs",
      "headRefOid": "f592d35353df18a16d0a8d459f21a3ea12cee976",
      "closedAt": "2021-09-23T12:02:10Z",
      "mergedAt": "2021-09-23T12:02:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6da40b03b7860af3de5651701d322860bd116a39"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2021-09-22T23:17:56Z",
          "updatedAt": "2021-09-22T23:17:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4tZE2X",
          "commit": {
            "abbreviatedOid": "f592d35"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-23T02:33:53Z",
          "updatedAt": "2021-09-23T02:33:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 273,
      "id": "PR_kwDOD79ejs4sKV6q",
      "title": "Pin key derivation seed length to 32 bytes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/273",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #249.",
      "createdAt": "2021-09-22T22:23:42Z",
      "updatedAt": "2021-09-23T12:02:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ee8e545c956c4ccc693d603192f920179c1922e9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/kdf-seed-constant",
      "headRefOid": "e7736037eaed11db3399367cfb3e156c640a3a68",
      "closedAt": "2021-09-23T12:02:18Z",
      "mergedAt": "2021-09-23T12:02:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e999252a569c2c4aad5217986d98da1de0b1509c"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2021-09-22T23:33:51Z",
          "updatedAt": "2021-09-22T23:33:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4tZE1A",
          "commit": {
            "abbreviatedOid": "e773603"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-23T02:33:35Z",
          "updatedAt": "2021-09-23T02:33:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 274,
      "id": "PR_kwDOD79ejs4sKWcV",
      "title": "Harden the harden function.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/274",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #245.",
      "createdAt": "2021-09-22T22:28:51Z",
      "updatedAt": "2021-09-23T12:02:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ee8e545c956c4ccc693d603192f920179c1922e9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/harden-harden",
      "headRefOid": "cd8d16cfc55902add817827c5c66cf855fa2d190",
      "closedAt": "2021-09-23T12:02:28Z",
      "mergedAt": "2021-09-23T12:02:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "90d9754860fb813a707afd7f14ab02991e6d49a3"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good, vectors included \ud83d\udc4d ",
          "createdAt": "2021-09-22T23:27:26Z",
          "updatedAt": "2021-09-22T23:27:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4tZEy0",
          "commit": {
            "abbreviatedOid": "cd8d16c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-23T02:33:02Z",
          "updatedAt": "2021-09-23T02:33:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 275,
      "id": "PR_kwDOD79ejs4sRXEb",
      "title": "Adding deployment considerations for malicious servers",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/275",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adds two items to the deployment considerations section:\r\n\r\n- Additional client-side entropy: OPAQUE supports the ability to incorporate the\r\nclient identity alongside the password to be input to the OPRF. This provides additional\r\nclient-side entropy which can supplement the entropy that should be introduced by the\r\nserver during an honest execution of the protocol.\r\n- Client-side authentication of the server: Note that online guessing attacks\r\n(against any Asymmetric PAKE) can be done from both the client side and the server side.\r\nThis means that additional checks, such as implementing client-side authentication of\r\nthe server, should be considered in a production deployment of OPAQUE.\r\n\r\nCloses #264 .",
      "createdAt": "2021-09-25T19:45:06Z",
      "updatedAt": "2021-09-30T22:44:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "90d9754860fb813a707afd7f14ab02991e6d49a3",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "malicious_server",
      "headRefOid": "7266ad606082a15c58f7b60f66d51bdf1d4a4535",
      "closedAt": "2021-09-30T22:44:38Z",
      "mergedAt": "2021-09-30T22:44:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "52163aecad59839fffd26679abc83dcecc3a7861"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated the language, thanks for the feedback!",
          "createdAt": "2021-09-30T21:29:12Z",
          "updatedAt": "2021-09-30T21:29:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4tjJx7",
          "commit": {
            "abbreviatedOid": "718cf0d"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-27T12:09:45Z",
          "updatedAt": "2021-09-27T12:09:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4tjcBA",
          "commit": {
            "abbreviatedOid": "718cf0d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-09-27T13:20:18Z",
          "updatedAt": "2021-09-27T13:25:05Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nserver during an honest execution of the protocol. This also provides domain separation between\r\ndifferent clients that might otherwise share the same password.\r\n```",
              "createdAt": "2021-09-27T13:20:19Z",
              "updatedAt": "2021-09-27T13:25:05Z"
            },
            {
              "originalPosition": 10,
              "body": "The phrase \"client-side authentication of the server\" is somewhat confusing to me. Perhaps we can say that the channel over which OPAQUE registration and login is run run is server-authenticated?",
              "createdAt": "2021-09-27T13:23:48Z",
              "updatedAt": "2021-09-27T13:25:05Z"
            },
            {
              "originalPosition": 9,
              "body": "I think this needs some more detail to be useful. In particular, I'd try to include that a malicious server can simulate honest responses in an attempt to learn the client's password.",
              "createdAt": "2021-09-27T13:25:01Z",
              "updatedAt": "2021-09-27T13:25:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tzEhk",
          "commit": {
            "abbreviatedOid": "718cf0d"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-30T21:27:43Z",
          "updatedAt": "2021-09-30T21:27:43Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "See my edit and let me know what you think!",
              "createdAt": "2021-09-30T21:27:43Z",
              "updatedAt": "2021-09-30T21:27:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4tzS_t",
          "commit": {
            "abbreviatedOid": "7266ad6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-30T22:44:29Z",
          "updatedAt": "2021-09-30T22:44:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 278,
      "id": "PR_kwDOD79ejs4smxMW",
      "title": "Merge #270 into master",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/278",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "#270 has been successfully merged back into `dbz/abstract-messages`, which, in turn, must now be merged into master again",
      "createdAt": "2021-10-03T16:51:56Z",
      "updatedAt": "2023-04-03T09:09:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "52163aecad59839fffd26679abc83dcecc3a7861",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/abstract-messages",
      "headRefOid": "5bcd4aaf6808c49fff8e7c66ba43b4e2e4c2ccdb",
      "closedAt": "2021-10-04T14:21:25Z",
      "mergedAt": "2021-10-04T14:21:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f056015727a0e5b2a7f08e180c5400b67f744cb2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4t6tQg",
          "commit": {
            "abbreviatedOid": "5bcd4aa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T14:21:21Z",
          "updatedAt": "2021-10-04T14:21:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 279,
      "id": "PR_kwDOD79ejs4soZsj",
      "title": "Add security consideration for HSM",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/279",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses #257",
      "createdAt": "2021-10-04T10:26:30Z",
      "updatedAt": "2023-04-03T09:09:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "52163aecad59839fffd26679abc83dcecc3a7861",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/ake-hsm",
      "headRefOid": "8f90af5826958680f64393ec05eb9eed4d02314d",
      "closedAt": "2021-10-05T13:23:56Z",
      "mergedAt": "2021-10-05T13:23:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ff92b0ae28ab2ca72cfa91c094fdaa595aa67408"
      },
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks perfect to me, I think the only thing left is to evaluate if adding test vectors for X25519 and X448 makes sense.",
          "createdAt": "2021-10-04T10:31:32Z",
          "updatedAt": "2021-10-04T10:31:32Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "It makes sense to me, and I think @chris-wood was also in favor.\r\n\r\nX25519 is widespread and has good support, X448 is not as much.\r\n\r\nIncluding these vectors would be better done in another PR.",
          "createdAt": "2021-10-04T11:08:38Z",
          "updatedAt": "2021-10-04T11:08:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Including these vectors would be better done in another PR.\r\n\r\nWhat issue should we use to track this? ",
          "createdAt": "2021-10-04T15:00:00Z",
          "updatedAt": "2021-10-04T15:00:00Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood how about #238 for tracking?",
          "createdAt": "2021-10-06T11:26:51Z",
          "updatedAt": "2021-10-06T11:26:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4t65TQ",
          "commit": {
            "abbreviatedOid": "d03fb46"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending suggestion!",
          "createdAt": "2021-10-04T14:58:48Z",
          "updatedAt": "2021-10-04T14:59:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nServer implementations of OPAQUE do not need access to the raw AKE private key. They only require\r\nthe ability to compute shared secrets as specified in {{key-schedule-functions}}. Thus, applications\r\nmay store the server AKE private key can be stored in a Hardware Security Module (HSM) or\r\nsimilar. Upon compromise of the OPRF seed and client envelopes, this would prevent an\r\nattacker from using this data to mount a server spoofing attack. Supporting implementations \r\nneed to consider allowing separate AKE and OPRF algorithms in cases where the HSM is \r\nincompatible with the OPRF algorithm.\r\n```",
              "createdAt": "2021-10-04T14:58:48Z",
              "updatedAt": "2021-10-04T14:59:35Z"
            },
            {
              "originalPosition": 13,
              "body": "I _think_ this makes the HSM use case and considerations a bit more clear.",
              "createdAt": "2021-10-04T14:59:27Z",
              "updatedAt": "2021-10-04T14:59:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4t99aw",
          "commit": {
            "abbreviatedOid": "3d1d900"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T09:44:33Z",
          "updatedAt": "2021-10-05T09:44:34Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nmay store the server AKE private key in a Hardware Security Module (HSM) or\r\n```\r\n\r\n@chris-wood is this what you meant ? :)",
              "createdAt": "2021-10-05T09:44:33Z",
              "updatedAt": "2021-10-05T09:44:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4t-qFN",
          "commit": {
            "abbreviatedOid": "3d1d900"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T12:51:48Z",
          "updatedAt": "2021-10-05T12:51:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 280,
      "id": "PR_kwDOD79ejs4ssCeI",
      "title": "minor fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/280",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "~~Last PR to close #263\r\nThis factorizes common code between the client and server 3DH functions, which, I believe, helps readability.~~",
      "createdAt": "2021-10-05T10:45:37Z",
      "updatedAt": "2023-04-03T09:09:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f056015727a0e5b2a7f08e180c5400b67f744cb2",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/3dh-keyschedule-factor",
      "headRefOid": "e1d64b6a150fdedb27f203464392c26da9815bf9",
      "closedAt": "2021-10-15T16:04:26Z",
      "mergedAt": "2021-10-15T16:04:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9bfc405d843cf331f5184a5433c0ec2387122bc9"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Basically, I'm just centralizing the key derivation and mac calculation in a single function, so that the client and server functions don't repeat the same code. Also, there were some leftovers from other PRs that hadn't been fixed",
          "createdAt": "2021-10-05T16:12:19Z",
          "updatedAt": "2021-10-05T16:12:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this just a bug fix PR now?",
          "createdAt": "2021-10-05T16:29:35Z",
          "updatedAt": "2021-10-05T16:29:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4t-qb_",
          "commit": {
            "abbreviatedOid": "c6d21a8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'm not a fan of this change as I don't think it improves readability. ",
          "createdAt": "2021-10-05T12:53:02Z",
          "updatedAt": "2021-10-05T12:54:40Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Does this render correctly?",
              "createdAt": "2021-10-05T12:53:02Z",
              "updatedAt": "2021-10-05T12:54:40Z"
            },
            {
              "originalPosition": 75,
              "body": "I don't really like this -- can we just pass `ikm` in as input?",
              "createdAt": "2021-10-05T12:53:39Z",
              "updatedAt": "2021-10-05T12:54:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4t-w1H",
          "commit": {
            "abbreviatedOid": "c6d21a8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T13:14:01Z",
          "updatedAt": "2021-10-05T13:14:01Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "yeah, probably",
              "createdAt": "2021-10-05T13:14:01Z",
              "updatedAt": "2021-10-05T13:14:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4t-xHW",
          "commit": {
            "abbreviatedOid": "c6d21a8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T13:14:57Z",
          "updatedAt": "2021-10-05T13:14:57Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "no, it doesn't, bad leftover. thanks!",
              "createdAt": "2021-10-05T13:14:57Z",
              "updatedAt": "2021-10-05T13:14:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4t_uk7",
          "commit": {
            "abbreviatedOid": "c9bc8ec"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T16:28:58Z",
          "updatedAt": "2021-10-05T16:35:05Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n2. dh2 = SerializePublicKey(sk2 * pk2)\r\n```",
              "createdAt": "2021-10-05T16:28:58Z",
              "updatedAt": "2021-10-05T16:35:05Z"
            },
            {
              "originalPosition": 52,
              "body": "Why swap the parameter order?",
              "createdAt": "2021-10-05T16:29:07Z",
              "updatedAt": "2021-10-05T16:35:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uCLO3",
          "commit": {
            "abbreviatedOid": "c9bc8ec"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T08:04:08Z",
          "updatedAt": "2021-10-06T08:04:09Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "going back and forth, it just ended up like that, it was not intended. switching back",
              "createdAt": "2021-10-06T08:04:09Z",
              "updatedAt": "2021-10-06T08:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uF6OG",
          "commit": {
            "abbreviatedOid": "b38e926"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T22:56:49Z",
          "updatedAt": "2021-10-06T22:57:28Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Why this change? (At some point we need to stop superfluous changes.)",
              "createdAt": "2021-10-06T22:56:50Z",
              "updatedAt": "2021-10-06T22:57:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uOvsM",
          "commit": {
            "abbreviatedOid": "b38e926"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-10T00:22:47Z",
          "updatedAt": "2021-10-10T00:22:47Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "The Km keys are only needed for that purpose, so we might as well use them here directly. It avoids having these lines in `ClientFinalize()` and `Response()`, which saves a couple of lines there. ",
              "createdAt": "2021-10-10T00:22:47Z",
              "updatedAt": "2021-10-10T00:22:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uR1hZ",
          "commit": {
            "abbreviatedOid": "b38e926"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T15:37:10Z",
          "updatedAt": "2021-10-11T15:39:30Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Well, the function name is called `DeriveKeys`, but now it's doing more than that. Should we name the function if we're going to keep this change?",
              "createdAt": "2021-10-11T15:37:11Z",
              "updatedAt": "2021-10-11T15:39:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4ujUP_",
          "commit": {
            "abbreviatedOid": "e1d64b6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-15T16:04:20Z",
          "updatedAt": "2021-10-15T16:04:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 282,
      "id": "PR_kwDOD79ejs4sz7ii",
      "title": "Integrate POPRF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/282",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address #281 ",
      "createdAt": "2021-10-06T14:51:02Z",
      "updatedAt": "2023-04-03T09:09:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ff92b0ae28ab2ca72cfa91c094fdaa595aa67408",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/poprf",
      "headRefOid": "1e26d8ffa3896a7398a2490218ee1c8a5e2213d6",
      "closedAt": "2021-10-18T10:10:29Z",
      "mergedAt": "2021-10-18T10:10:29Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "2f95f12c5f438cf582108b15d5fb5e60631c6dbf"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i see a lot of changes, and see that the reason for this is POPRF, but the PR lacks any references to what POPRF is, why it is relevant to OPAQUE, and thus why this PR is beneficial. would you please provide the missing context? thank you.",
          "createdAt": "2021-10-06T14:55:57Z",
          "updatedAt": "2021-10-06T14:55:57Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i see there is an issue open, referring to the voprf draft. but it would be useful to spell the reasons out how this applies to opaque.",
          "createdAt": "2021-10-06T14:58:11Z",
          "updatedAt": "2021-10-06T14:58:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef the VOPRF draft now _only_ implements a POPRF, so this is a necessary change.",
          "createdAt": "2021-10-06T15:18:32Z",
          "updatedAt": "2021-10-06T15:18:32Z"
        },
        {
          "author": "gtank",
          "authorAssociation": "NONE",
          "body": "> i see a lot of changes, and see that the reason for this is POPRF, but the PR lacks any references to what POPRF is, why it is relevant to OPAQUE, and thus why this PR is beneficial. would you please provide the missing context? thank you.\r\n\r\nHi folks! If it's helpful, I can supply at least one other reason for the POPRF in OPAQUE from my work on a WhatsApp-style e2e backup recovery system: https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/281#issuecomment-937386635",
          "createdAt": "2021-10-07T02:15:03Z",
          "updatedAt": "2021-10-07T02:15:19Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch @kevinlewi !",
          "createdAt": "2021-10-13T07:38:37Z",
          "updatedAt": "2021-10-13T07:38:37Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood: as @kevinlewi pointed out in #281, it wouldn't hurt to allow apps to input a specific string to use for POPRF, and with some small benefits.\r\n\r\nIf you both don't mind, I'd prefer to land this PR in the current state and that (an)other PR(s) address(es) the following points:\r\n- (_do_) augment the POPRF info to allow applications to put in arbitrary strings as a prefix\r\n- (_decide_) what do we do if no client id is known by the client: is an empty value acceptable?\r\n- (_decide_) if we want tighter binding and would like to include configuration parameters atop the app-specific string, we need to find a format to represent this (or an identification number \u00e0 la IANA), or state that it's part of the app-specific input info and that the OPAQUE spec doesn't specify a configuration format and serialization",
          "createdAt": "2021-10-13T11:32:40Z",
          "updatedAt": "2021-10-13T12:49:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare applications can already put arbitrary info in the context string, so we don't need to let them also put it in the POPRF info string.",
          "createdAt": "2021-10-13T11:59:24Z",
          "updatedAt": "2021-10-13T11:59:24Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Verified that the test vectors match my implementation.",
          "createdAt": "2021-10-17T03:44:39Z",
          "updatedAt": "2021-10-17T03:44:39Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Same for mine \u2705",
          "createdAt": "2021-10-17T09:04:14Z",
          "updatedAt": "2021-10-17T09:04:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4uEMRp",
          "commit": {
            "abbreviatedOid": "03e8ba6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM overall, but I think there's some unnecessary temp variables used throughout. (Thanks for updating the VOPRF dependency, too!)",
          "createdAt": "2021-10-06T15:13:58Z",
          "updatedAt": "2021-10-06T15:17:51Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "This temp variable seems unnecessary -- why not just pass `client_idenity` to Finalize? (Same for the instance below, and Evaluate call above)",
              "createdAt": "2021-10-06T15:13:58Z",
              "updatedAt": "2021-10-06T15:17:51Z"
            },
            {
              "originalPosition": 53,
              "body": "Why not pass `idU` directly?",
              "createdAt": "2021-10-06T15:14:54Z",
              "updatedAt": "2021-10-06T15:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uERI-",
          "commit": {
            "abbreviatedOid": "03e8ba6"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:29:18Z",
          "updatedAt": "2021-10-06T15:29:18Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "To test whether it solves the 'NoneType' problem ",
              "createdAt": "2021-10-06T15:29:18Z",
              "updatedAt": "2021-10-06T15:29:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uEwnf",
          "commit": {
            "abbreviatedOid": "87927a7"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T16:58:23Z",
          "updatedAt": "2021-10-06T16:58:23Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "It's a placeholder, in case we want info to be `configuration || client_id || server_id`.\r\nBut currently, the configuration serialization is not defined, and the server_id is optional and the client doesn't have access to the public key at that point.",
              "createdAt": "2021-10-06T16:58:23Z",
              "updatedAt": "2021-10-06T16:58:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uEx3p",
          "commit": {
            "abbreviatedOid": "87927a7"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T17:03:18Z",
          "updatedAt": "2021-10-06T17:03:18Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Nevertheless, we could still go for `I2OSP(len(client_id), 2) || client_id || I2OSP(len(server_id), 2) || server_id||`. And if they are not defined or inaccessible, then \ud83e\udd37\r\nThe server always has access to both, the client not always. But this asymmetry doesn't break the result as long as it's constant in time.",
              "createdAt": "2021-10-06T17:03:18Z",
              "updatedAt": "2021-10-06T17:03:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uF6JL",
          "commit": {
            "abbreviatedOid": "87927a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T22:56:12Z",
          "updatedAt": "2021-10-06T22:56:12Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Using client_id directly seems simplest here. Can we just do that?",
              "createdAt": "2021-10-06T22:56:12Z",
              "updatedAt": "2021-10-06T22:56:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uF6Kk",
          "commit": {
            "abbreviatedOid": "87927a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T22:56:22Z",
          "updatedAt": "2021-10-06T22:56:22Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "So we'll revert this, yes?",
              "createdAt": "2021-10-06T22:56:22Z",
              "updatedAt": "2021-10-06T22:56:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uGM55",
          "commit": {
            "abbreviatedOid": "87927a7"
          },
          "author": "gtank",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T02:12:20Z",
          "updatedAt": "2021-10-07T02:12:21Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I agree with @chris-wood. I see a need for `client_id` binding, but (depending on the concrete scheme selected) including `server_id` potentially requires the caller to be aware of thresholding or other arrangements by the evalutating parties that would ideally be transparent. The output is already inherently bound to the identity of the server by use of their evaluation key.",
              "createdAt": "2021-10-07T02:12:21Z",
              "updatedAt": "2021-10-07T02:18:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uNNXs",
          "commit": {
            "abbreviatedOid": "87927a7"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T16:35:36Z",
          "updatedAt": "2021-10-08T16:35:36Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "of course ! This PR is still in draft btw ;) ",
              "createdAt": "2021-10-08T16:35:36Z",
              "updatedAt": "2021-10-08T16:35:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uOiVA",
          "commit": {
            "abbreviatedOid": "87927a7"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-09T09:28:28Z",
          "updatedAt": "2021-10-09T09:28:28Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Good point @gtank ! Thanks :)",
              "createdAt": "2021-10-09T09:28:28Z",
              "updatedAt": "2021-10-09T09:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uRpsc",
          "commit": {
            "abbreviatedOid": "9e6514d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending one editorial fix and a suggestion on the PoC. @kevinlewi, can you please check the vectors?",
          "createdAt": "2021-10-11T15:13:48Z",
          "updatedAt": "2021-10-11T15:36:04Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Numbering is off here.",
              "createdAt": "2021-10-11T15:13:49Z",
              "updatedAt": "2021-10-11T15:36:04Z"
            },
            {
              "originalPosition": 8,
              "body": "Rather than do this check inline, can we move it to the calling code and assume that `info` is never `None`?",
              "createdAt": "2021-10-11T15:35:13Z",
              "updatedAt": "2021-10-11T15:36:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uXffv",
          "commit": {
            "abbreviatedOid": "9e6514d"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T22:13:08Z",
          "updatedAt": "2021-10-12T22:13:08Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "info is None when the client identity is not given (e.g. like in the test vectors)",
              "createdAt": "2021-10-12T22:13:08Z",
              "updatedAt": "2021-10-12T22:13:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uXfnD",
          "commit": {
            "abbreviatedOid": "9e6514d"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T22:13:58Z",
          "updatedAt": "2021-10-12T22:13:59Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "oh, you mean assume it's never `None` just in this function ?",
              "createdAt": "2021-10-12T22:13:58Z",
              "updatedAt": "2021-10-12T22:13:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uXlpE",
          "commit": {
            "abbreviatedOid": "a7b97d5"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T22:47:38Z",
          "updatedAt": "2021-10-12T22:47:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Alright, moved it up",
              "createdAt": "2021-10-12T22:47:38Z",
              "updatedAt": "2021-10-12T22:47:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4uYJsC",
          "commit": {
            "abbreviatedOid": "a7b97d5"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "```\r\n response = CreateRegistrationResponse(request,\r\n                                       server_public_key,\r\n                                       credential_identifier,\r\n                                       oprf_seed)\r\n```\r\n\r\n(Lines 773-776) The CreateRegistrationResponse needs to include the additional parameter, client_identity.",
          "createdAt": "2021-10-13T04:42:15Z",
          "updatedAt": "2021-10-13T04:42:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 284,
      "id": "PR_kwDOD79ejs4tplIZ",
      "title": "Sort authors alphabetically and update e-mail",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/284",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T21:57:01Z",
      "updatedAt": "2023-04-03T09:09:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2f95f12c5f438cf582108b15d5fb5e60631c6dbf",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/update-mail",
      "headRefOid": "174dbcb5fe67793b39ba8a01a65cfe3734ba94c1",
      "closedAt": "2021-10-25T22:11:42Z",
      "mergedAt": "2021-10-25T22:11:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fd10c0397e50602611bddfeff0af0fb8b27c4115"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4vAhnZ",
          "commit": {
            "abbreviatedOid": "174dbcb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T22:11:37Z",
          "updatedAt": "2021-10-25T22:11:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 285,
      "id": "PR_kwDOD79ejs4tprdd",
      "title": "update to VOPRF 08",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/285",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T22:46:06Z",
      "updatedAt": "2023-04-03T09:09:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "fd10c0397e50602611bddfeff0af0fb8b27c4115",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/update-voprf-08",
      "headRefOid": "cf76da9c4199bd445ac95372d38a81d65eb900d0",
      "closedAt": "2021-10-25T22:46:46Z",
      "mergedAt": "2021-10-25T22:46:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "04473ca51110577d58b3c46067402678f1d329d7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4vAmmO",
          "commit": {
            "abbreviatedOid": "cf76da9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T22:46:39Z",
          "updatedAt": "2021-10-25T22:46:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 286,
      "id": "PR_kwDOD79ejs4ucTWd",
      "title": "Fixes several errors on input and output parameters.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/286",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After implementing OPAQUE I found several errors on the description of the algorithms.\r\nThis PR amends most of them, no changes on the algorithms nor test vectors.\r\nHope this PR helps to improve a bit the draft.",
      "createdAt": "2021-11-12T08:01:39Z",
      "updatedAt": "2022-02-03T21:39:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "02871345acefcb7aa9bc78c48c4f8b059761d0d2",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "fixInputs",
      "headRefOid": "b413b7cbf3168d2d0b2aa10a4f5bec32c7a79215",
      "closedAt": "2022-02-03T21:39:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "At a first quick look, it looks like this will change the vectors, since a DST is changed",
          "createdAt": "2021-11-17T23:34:04Z",
          "updatedAt": "2021-11-17T23:34:04Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> At a first quick look, it looks like this will change the vectors, since a DST is changed\r\n\r\nIt doesn't because the code was wrong. I decided to fix the DST rather than the code. This can be changed later, if needed.",
          "createdAt": "2021-11-18T06:58:17Z",
          "updatedAt": "2021-11-18T06:58:17Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There was 3 points I raised during this PR. They will be addressed later in a shorter PR.\r\nAlso, I reverted my changes on the state of the client and server, with the hope that it will be addressed in #291 .",
          "createdAt": "2021-11-18T21:52:18Z",
          "updatedAt": "2021-11-18T21:52:18Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @armfazh for your corrections! ",
          "createdAt": "2021-11-21T01:18:39Z",
          "updatedAt": "2021-11-21T01:18:39Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @armfazh \ud83d\udc4b \r\nWhat is the state of this PR? Should we expect an update soon? I'm happy to help with anything to go forward (no pressure \ud83d\ude09 )",
          "createdAt": "2021-12-27T17:14:05Z",
          "updatedAt": "2021-12-27T17:14:05Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "well, I think I need to rebase this first, also several changes will not apply anymore once #300 be merged.\r\n--sorry for late response.\r\n",
          "createdAt": "2022-01-10T06:49:57Z",
          "updatedAt": "2022-01-10T06:49:57Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Lots of changes has been added since this was opened. Closing now, I will open an issue if something was missing.",
          "createdAt": "2022-02-03T21:39:18Z",
          "updatedAt": "2022-02-03T21:39:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4wOvl4",
          "commit": {
            "abbreviatedOid": "2a9dd66"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "There's a lot of changes here and it's hard for me to make sense of some of them. In general, this looks fine, but I would prefer significantly smaller PRs. And I would prefer that aesthetic changes (like changing function parameters around) be reverted and left out of this PR.",
          "createdAt": "2021-11-17T21:44:21Z",
          "updatedAt": "2021-11-17T21:59:44Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n\r\nThe size of the envelope is a constant denoted as `Ne`. Its size may vary between key recovery methods.\r\n```",
              "createdAt": "2021-11-17T21:44:21Z",
              "updatedAt": "2021-11-17T21:59:44Z"
            },
            {
              "originalPosition": 87,
              "body": "```suggestion\r\nand uses it to perform a mutually authenticated key exchange. For both stages, client and \r\nserver agree on a configuration, which\r\n```",
              "createdAt": "2021-11-17T21:46:19Z",
              "updatedAt": "2021-11-17T21:59:44Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n```\r\nThis is redundant with text below in the registration overview.",
              "createdAt": "2021-11-17T21:50:42Z",
              "updatedAt": "2021-11-17T21:59:44Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\n                      RegistrationRequest\r\n```",
              "createdAt": "2021-11-17T21:51:58Z",
              "updatedAt": "2021-11-17T21:59:44Z"
            },
            {
              "originalPosition": 119,
              "body": "```suggestion\r\n                      RegistrationResponse\r\n```",
              "createdAt": "2021-11-17T21:52:06Z",
              "updatedAt": "2021-11-17T21:59:44Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n                      RegistrationRecord\r\n```",
              "createdAt": "2021-11-17T21:52:14Z",
              "updatedAt": "2021-11-17T21:59:44Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n                        KE1\r\n```",
              "createdAt": "2021-11-17T21:52:36Z",
              "updatedAt": "2021-11-17T21:59:44Z"
            },
            {
              "originalPosition": 155,
              "body": "```suggestion\r\n                        KE2\r\n```",
              "createdAt": "2021-11-17T21:52:43Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 158,
              "body": "```suggestion\r\n                        KE3\r\n```",
              "createdAt": "2021-11-17T21:52:49Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 171,
              "body": "```suggestion\r\nThese messages carry information of the concurrent execution of the\r\ncredential retrieval process and the authenticated key exchange:\r\n```",
              "createdAt": "2021-11-17T21:53:11Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 201,
              "body": "```suggestion\r\n- server_identity, The optional server identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:53:40Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 202,
              "body": "```suggestion\r\n- client_identity, The optional client identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:53:47Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 215,
              "body": "```suggestion\r\n- server_identity, The optional server identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:53:56Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 214,
              "body": "```suggestion\r\n- server_public_key, The encoded server public key for\r\nthe AKE protocol, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:54:07Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 216,
              "body": "```suggestion\r\n- client_identity, The optional client identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:54:13Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 226,
              "body": "```suggestion\r\n- server_identity, The optional server identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:54:20Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 227,
              "body": "```suggestion\r\n- client_identity, The optional client identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:54:27Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 306,
              "body": "```suggestion\r\n- server_identity, the optional server identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:54:48Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 307,
              "body": "```suggestion\r\n- client_identity, the optional client identity, an octet string.\r\n```",
              "createdAt": "2021-11-17T21:54:55Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 337,
              "body": "```suggestion\r\n# Online Authenticated Key Exchange {#online-phase}\r\n```\r\nOne output is a session key, after all.",
              "createdAt": "2021-11-17T21:55:25Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 346,
              "body": "```suggestion\r\nThis section describes the online authenticated key exchange protocol flow,\r\n```",
              "createdAt": "2021-11-17T21:55:42Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 473,
              "body": "Should this output type change?",
              "createdAt": "2021-11-17T21:57:53Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            },
            {
              "originalPosition": 745,
              "body": "ke1 was previously in the state. Why change that here?",
              "createdAt": "2021-11-17T21:58:39Z",
              "updatedAt": "2021-11-17T21:59:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wQHfu",
          "commit": {
            "abbreviatedOid": "2a9dd66"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T07:01:08Z",
          "updatedAt": "2021-11-18T07:01:08Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I used the convention in the previous section where constants are explicitly itemized. I suggest this change because finding this parameter in the middle of a sentence is more difficult to parse.",
              "createdAt": "2021-11-18T07:01:08Z",
              "updatedAt": "2021-11-18T07:01:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wQHsl",
          "commit": {
            "abbreviatedOid": "2a9dd66"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T07:02:26Z",
          "updatedAt": "2021-11-18T07:02:26Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I feel a lack of a section called Setup, like any other protocols has.",
              "createdAt": "2021-11-18T07:02:26Z",
              "updatedAt": "2021-11-18T07:02:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wQIGb",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T07:05:08Z",
          "updatedAt": "2021-11-18T07:05:09Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I changed this twice, I still didn't understand what is the convention.\r\n\r\nWhat must be on top of the arrow? the object type or an instance of such an object. I can change either way, but want to know what is the convention to follow.\r\n\r\n\r\n",
              "createdAt": "2021-11-18T07:05:09Z",
              "updatedAt": "2021-11-18T07:05:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wQIOw",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T07:05:56Z",
          "updatedAt": "2021-11-18T07:05:56Z",
          "comments": [
            {
              "originalPosition": 307,
              "body": "Does this applies to all occurrences of `*_identity`?",
              "createdAt": "2021-11-18T07:05:56Z",
              "updatedAt": "2021-11-18T07:05:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wQIoH",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T07:08:26Z",
          "updatedAt": "2021-11-18T07:08:27Z",
          "comments": [
            {
              "originalPosition": 337,
              "body": "My understanding of the draft is that during Online Authentication two tasks happen, and one of them is an Authenticated Key Exchange (AKE). However, Online Authentication, I think is a more general title for describing this big phase, later there is one section only of AKE.\r\n\r\n",
              "createdAt": "2021-11-18T07:08:27Z",
              "updatedAt": "2021-11-18T07:08:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wQJpP",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T07:14:50Z",
          "updatedAt": "2021-11-18T07:14:50Z",
          "comments": [
            {
              "originalPosition": 745,
              "body": "Because the `AKE client state` only carries values from the AKE.\r\nThe external function (the one that calls the AKE) is the one that knows how to build KE1 during Start().\r\n ",
              "createdAt": "2021-11-18T07:14:50Z",
              "updatedAt": "2021-11-18T07:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wQKEq",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T07:17:31Z",
          "updatedAt": "2021-11-18T07:17:32Z",
          "comments": [
            {
              "originalPosition": 473,
              "body": "not sure, change to what type? (didn't get your question, could you please elaborate)",
              "createdAt": "2021-11-18T07:17:32Z",
              "updatedAt": "2021-11-18T07:17:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wRujL",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T13:55:53Z",
          "updatedAt": "2021-11-18T13:55:53Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I don't know if we have a convention, but using the type here seems most clear.",
              "createdAt": "2021-11-18T13:55:53Z",
              "updatedAt": "2021-11-18T13:55:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wRulb",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T13:56:00Z",
          "updatedAt": "2021-11-18T13:56:00Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I don't think it's necessary.",
              "createdAt": "2021-11-18T13:56:00Z",
              "updatedAt": "2021-11-18T13:56:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wRut6",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T13:56:24Z",
          "updatedAt": "2021-11-18T13:56:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Well, it's not a function, so the sentence introducing the list would need to change if we were to take this suggestion.",
              "createdAt": "2021-11-18T13:56:24Z",
              "updatedAt": "2021-11-18T13:56:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wRu3u",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T13:56:53Z",
          "updatedAt": "2021-11-18T13:56:53Z",
          "comments": [
            {
              "originalPosition": 307,
              "body": "When used as an octet string, yes.",
              "createdAt": "2021-11-18T13:56:53Z",
              "updatedAt": "2021-11-18T13:56:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wRvJg",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T13:57:45Z",
          "updatedAt": "2021-11-18T13:57:45Z",
          "comments": [
            {
              "originalPosition": 337,
              "body": "OPAQUE is fundamentally a key exchange protocol, so the existing title seems more accurate.",
              "createdAt": "2021-11-18T13:57:45Z",
              "updatedAt": "2021-11-18T13:57:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wRvT3",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T13:58:16Z",
          "updatedAt": "2021-11-18T13:58:17Z",
          "comments": [
            {
              "originalPosition": 473,
              "body": "Well, the function returns something of type `Response`, not `KE2`.",
              "createdAt": "2021-11-18T13:58:17Z",
              "updatedAt": "2021-11-18T13:58:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wRve4",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T13:58:48Z",
          "updatedAt": "2021-11-18T13:58:48Z",
          "comments": [
            {
              "originalPosition": 745,
              "body": "This seems like an aesthetic change. Can we please keep these separate?",
              "createdAt": "2021-11-18T13:58:48Z",
              "updatedAt": "2021-11-18T13:58:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS0JM",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:28:23Z",
          "updatedAt": "2021-11-18T17:28:24Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I think it is necessary. Shall we move this discussion to the list?",
              "createdAt": "2021-11-18T17:28:23Z",
              "updatedAt": "2021-11-18T17:28:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS0ai",
          "commit": {
            "abbreviatedOid": "cc6cefd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:29:22Z",
          "updatedAt": "2021-11-18T17:29:23Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "No, I don't think so. This is an editorial consideration. ",
              "createdAt": "2021-11-18T17:29:23Z",
              "updatedAt": "2021-11-18T17:29:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS29-",
          "commit": {
            "abbreviatedOid": "a545cec"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:38:48Z",
          "updatedAt": "2021-11-18T17:38:49Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "updated the sentence. ",
              "createdAt": "2021-11-18T17:38:48Z",
              "updatedAt": "2021-11-18T17:38:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS4LJ",
          "commit": {
            "abbreviatedOid": "515717e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:42:59Z",
          "updatedAt": "2021-11-18T17:42:59Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Looks good!",
              "createdAt": "2021-11-18T17:42:59Z",
              "updatedAt": "2021-11-18T17:42:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS4OP",
          "commit": {
            "abbreviatedOid": "515717e"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:43:10Z",
          "updatedAt": "2021-11-18T17:43:10Z",
          "comments": [
            {
              "originalPosition": 473,
              "body": "No. It returns the result of calling `Response` function. (https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/515717e8b6f19d427d6190f99450a850cfb709aa/draft-irtf-cfrg-opaque.md?plain=1#L1496) \r\n",
              "createdAt": "2021-11-18T17:43:10Z",
              "updatedAt": "2021-11-18T17:43:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wPHBA",
          "commit": {
            "abbreviatedOid": "2a9dd66"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-11-17T23:35:58Z",
          "updatedAt": "2021-11-18T17:44:42Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@chris-wood hasn't this wording been discussed earlier ? (Can't remember the issue, I think it was with Hugo)",
              "createdAt": "2021-11-17T23:35:58Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 45,
              "body": "+1 with mentioning the the recovery method.\n\nThe recovery method is indeed abstracted, and in this specification we focus on the method that derives the client private key from the hardened OPRF output. Another method is the RKR encrypted envelope.\n\nIt makes therefore sense to keep mentioning it as it has an effect on the size of the envelope.",
              "createdAt": "2021-11-17T23:40:10Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 81,
              "body": "I like that !",
              "createdAt": "2021-11-17T23:41:28Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\nIn the second stage the client recovers its authentication material from the server\n```\n",
              "createdAt": "2021-11-17T23:42:07Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 190,
              "body": "```suggestion\n  e.g., \"example.com\". If not specified, it defaults to the server's public key.\n```\n",
              "createdAt": "2021-11-17T23:45:11Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\nOPAQUE consists of two stages: registration and online authenticated key exchange.\n```\n\nCf. comment from @chris-wood on line 923 :)",
              "createdAt": "2021-11-17T23:58:04Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 143,
              "body": "```suggestion\nThe online authenticated key exchange flow is shown below:\n```\n\nI suggest we stay consistent with comments on lines 483 and 923",
              "createdAt": "2021-11-18T00:01:35Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 395,
              "body": "Why leaving out Nok?",
              "createdAt": "2021-11-18T00:07:44Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 13,
              "body": "Why leaving out Nok?",
              "createdAt": "2021-11-18T00:08:12Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 430,
              "body": "```suggestion\n- client_identity, the optional client identity, an octet string.\n```\n",
              "createdAt": "2021-11-18T00:14:51Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 431,
              "body": "```suggestion\n- server_identity, the optional server identity, an octet string.\n```\n",
              "createdAt": "2021-11-18T00:15:10Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 419,
              "body": "KE1 can be stored in the client state and then retrieved in the client ake finalisation.",
              "createdAt": "2021-11-18T08:28:20Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 415,
              "body": "```suggestion\n5. Create KE1 ke1 with (request, auth_init)\n6. state.ke1 = ke1\n7. Output ke1\n```\n",
              "createdAt": "2021-11-18T08:31:34Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            },
            {
              "originalPosition": 391,
              "body": "This should be ke1",
              "createdAt": "2021-11-18T08:32:07Z",
              "updatedAt": "2021-11-18T17:44:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS5DT",
          "commit": {
            "abbreviatedOid": "515717e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:46:19Z",
          "updatedAt": "2021-11-18T17:46:19Z",
          "comments": [
            {
              "originalPosition": 473,
              "body": "Oh, right! Sheesh. We need to really fix the names in this spec. \ud83e\udd26 ",
              "createdAt": "2021-11-18T17:46:19Z",
              "updatedAt": "2021-11-18T17:46:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS5JR",
          "commit": {
            "abbreviatedOid": "515717e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T17:46:38Z",
          "updatedAt": "2021-11-18T17:46:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I totally don't care about the wording here, so both seem fine to me.",
              "createdAt": "2021-11-18T17:46:38Z",
              "updatedAt": "2021-11-18T17:46:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS_A2",
          "commit": {
            "abbreviatedOid": "515717e"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:09:17Z",
          "updatedAt": "2021-11-18T18:09:18Z",
          "comments": [
            {
              "originalPosition": 745,
              "body": "Not sure how to implement your suggestion.\r\n\r\nJust to add more context and information about the fix:\r\n\r\nThere are two states, one wrapping the other: \r\nA: The Main State: (https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/515717e8b6f19d427d6190f99450a850cfb709aa/draft-irtf-cfrg-opaque.md?plain=1#L988)\r\nwhich contains:\r\n- password, the input password; and\r\n- blind, the random blinding scalar returned by `Blind()`; and\r\n- B: client_ake_state, the client's AKE state if necessary.\r\n \r\nand B: the client_ake_state (https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/515717e8b6f19d427d6190f99450a850cfb709aa/draft-irtf-cfrg-opaque.md?plain=1#L1249)\r\ncontaining:\r\n- client_secret, an opaque byte string of length Nsk.\r\n\r\n---\r\n\r\nke1 must live in the state, yes. the question is in which one?\r\n\r\nWe cannot store ke1 in state B, because ke1 is constructed as (https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/515717e8b6f19d427d6190f99450a850cfb709aa/draft-irtf-cfrg-opaque.md?plain=1#L570\r\n)\r\n```\r\n- `KE1` is composed of the `CredentialRequest` and `AuthInit` messages.\r\n```\r\n\r\nAuthInit is created by the AKE, but CredentialRequest is not.\r\nSo the AKE cannot construct KE1, this is why KE1 must be passed as a parameter.\r\n\r\nHence, ke1 must live in the main state A. -- This part needed to be updated, and this is fixed now.\r\n",
              "createdAt": "2021-11-18T18:09:18Z",
              "updatedAt": "2021-11-18T18:09:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS_xG",
          "commit": {
            "abbreviatedOid": "e46f48c"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:12:20Z",
          "updatedAt": "2021-11-18T18:12:21Z",
          "comments": [
            {
              "originalPosition": 337,
              "body": "I am talking about the `Online Authentication phase`, which is a combination of several primitives, one of them is AKE (which seems to be the most important, but not the only one). ",
              "createdAt": "2021-11-18T18:12:21Z",
              "updatedAt": "2021-11-18T18:12:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wS_30",
          "commit": {
            "abbreviatedOid": "e46f48c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:12:46Z",
          "updatedAt": "2021-11-18T18:12:46Z",
          "comments": [
            {
              "originalPosition": 745,
              "body": "Well, this PR changes state from \"generic state\" to \"AKE client state,\" and I'm asking that we revert that change and address it separately. ",
              "createdAt": "2021-11-18T18:12:46Z",
              "updatedAt": "2021-11-18T18:12:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wTAQG",
          "commit": {
            "abbreviatedOid": "e46f48c"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:14:16Z",
          "updatedAt": "2021-11-18T18:14:16Z",
          "comments": [
            {
              "originalPosition": 419,
              "body": "yes, I just update the pr to do that.",
              "createdAt": "2021-11-18T18:14:16Z",
              "updatedAt": "2021-11-18T18:14:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wTBOO",
          "commit": {
            "abbreviatedOid": "e46f48c"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:17:37Z",
          "updatedAt": "2021-11-18T18:17:37Z",
          "comments": [
            {
              "originalPosition": 395,
              "body": "This parameter was not used",
              "createdAt": "2021-11-18T18:17:37Z",
              "updatedAt": "2021-11-18T18:17:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wTBxJ",
          "commit": {
            "abbreviatedOid": "65dbd73"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:19:45Z",
          "updatedAt": "2021-11-18T18:19:46Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I think it's not used, and/or its definition is not correct.",
              "createdAt": "2021-11-18T18:19:46Z",
              "updatedAt": "2021-11-18T18:19:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wTChj",
          "commit": {
            "abbreviatedOid": "65dbd73"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:22:46Z",
          "updatedAt": "2021-11-18T18:22:47Z",
          "comments": [
            {
              "originalPosition": 391,
              "body": "fixed.",
              "createdAt": "2021-11-18T18:22:46Z",
              "updatedAt": "2021-11-18T18:22:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wTFSf",
          "commit": {
            "abbreviatedOid": "81cc31f"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T18:34:00Z",
          "updatedAt": "2021-11-18T18:34:00Z",
          "comments": [
            {
              "originalPosition": 415,
              "body": "I fixed this, please double-check. I may missed something.",
              "createdAt": "2021-11-18T18:34:00Z",
              "updatedAt": "2021-11-18T18:34:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wTjbe",
          "commit": {
            "abbreviatedOid": "81cc31f"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T20:40:42Z",
          "updatedAt": "2021-11-18T20:40:42Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Reverted and will be discussed in #289 ",
              "createdAt": "2021-11-18T20:40:42Z",
              "updatedAt": "2021-11-18T20:40:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wTkM9",
          "commit": {
            "abbreviatedOid": "0a5191a"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-18T20:44:26Z",
          "updatedAt": "2021-11-18T20:44:27Z",
          "comments": [
            {
              "originalPosition": 337,
              "body": "After talked offline with Chris Wood, we agreed the current version is ok. So, I'm reverting.",
              "createdAt": "2021-11-18T20:44:27Z",
              "updatedAt": "2021-11-18T20:44:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wZB4i",
          "commit": {
            "abbreviatedOid": "b413b7c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-20T23:49:27Z",
          "updatedAt": "2021-11-20T23:49:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "It is used in `CreateCredentialResponse()`, 1st step, to derive the per-user OPRF key.",
              "createdAt": "2021-11-20T23:49:27Z",
              "updatedAt": "2021-11-20T23:49:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wZB5C",
          "commit": {
            "abbreviatedOid": "b413b7c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-20T23:50:24Z",
          "updatedAt": "2021-11-20T23:50:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "What do you suggest as parameters? Should we refer to the default parameters of the MHF?",
              "createdAt": "2021-11-20T23:50:24Z",
              "updatedAt": "2021-11-20T23:50:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wZCEk",
          "commit": {
            "abbreviatedOid": "b413b7c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-11-21T00:07:09Z",
          "updatedAt": "2021-11-21T01:16:50Z",
          "comments": [
            {
              "originalPosition": 431,
              "body": "`auth_finish` has not been defined, ke3 is already created",
              "createdAt": "2021-11-21T00:07:09Z",
              "updatedAt": "2021-11-21T01:16:50Z"
            },
            {
              "originalPosition": 488,
              "body": "Isn't `ServerFinalize(ke3)` sufficient?\r\n\r\nAn AKE could have more fields in ke3",
              "createdAt": "2021-11-21T00:08:34Z",
              "updatedAt": "2021-11-21T01:16:50Z"
            },
            {
              "originalPosition": 747,
              "body": "```suggestion\r\n- ke1, a KE1 message structure.\r\n- credential_response, a CredentialResponse structure.\r\n\r\n```",
              "createdAt": "2021-11-21T00:17:38Z",
              "updatedAt": "2021-11-21T01:16:50Z"
            },
            {
              "originalPosition": 747,
              "body": "This was already missing ! :)",
              "createdAt": "2021-11-21T00:18:01Z",
              "updatedAt": "2021-11-21T01:16:50Z"
            },
            {
              "originalPosition": 780,
              "body": "I suggest we keep genericity regarding K3, and define ServerFinish with taking a KE3 structure. KE3 holds AKE material only anyway. Other AKEs than 3DH could define their KE3 subfields themselves.",
              "createdAt": "2021-11-21T00:24:10Z",
              "updatedAt": "2021-11-21T01:16:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 287,
      "id": "PR_kwDOD79ejs4uq-0c",
      "title": "Add list of paper<>spec design differences",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/287",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This list includes notable design differences from the original paper description of OPAQUE made to accommodate the specification. This is done to help track the delta between the protocol which has been analyzed and that which is being specified in CFRG.\r\n\r\ncc @hugokraw ",
      "createdAt": "2021-11-17T18:49:02Z",
      "updatedAt": "2021-12-20T20:18:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "04473ca51110577d58b3c46067402678f1d329d7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/paper-spec-design-differences",
      "headRefOid": "bd50e79339db6f246be58b78c9651d8c012593d8",
      "closedAt": "2021-11-18T13:54:23Z",
      "mergedAt": "2021-11-18T13:54:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "02871345acefcb7aa9bc78c48c4f8b059761d0d2"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare suggestions applied.",
          "createdAt": "2021-11-17T19:53:03Z",
          "updatedAt": "2021-11-17T19:53:03Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Two more changes relative to the JKX'18 paper:\r\n- The masking of the envelope\r\n- JKX has a simplified analysis where the server builds all elements of the envelope for which it learns the password. The spec has the much more secure instantiation (suggested in JKX'18 but not analyzed) where the client computes the envelope and the server never sees the password.\r\n\r\nWe will need to justify (to CFRG) why these changes do not void the analysis. This justification is quite straightforward in all but two of the changes: The derivation of the user's private key from the output of the OPRF (rather than transported in the envelope) and the way the envelope is built at registration time. Both changes are analyzed in a manuscript by Hesse-Jarecki-Krawczyk-Wood that we could (probably should) post publicly. I will need first to check with the HJKW authors. \r\n\r\nBtw, these two changes actually strengthen the protocol. Obviously not sharing the password with the server during registration as (over) simplified in JKX18 (needed to match GMR UC formalism) is a *good* thing. And deriving the private key from the OPRF output removes the issue of RKR encryption and equivocability that were needed in the JKX18 analysis.",
          "createdAt": "2021-11-17T20:33:44Z",
          "updatedAt": "2021-11-17T20:33:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw I added your two suggestions.",
          "createdAt": "2021-11-17T20:47:07Z",
          "updatedAt": "2021-11-17T20:47:07Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me :)",
          "createdAt": "2021-11-17T23:29:40Z",
          "updatedAt": "2021-11-17T23:29:40Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to document how these changes relate to the original protocol as analyzed in JKX18, and how to extend the analysis to cover these changes:\r\n\r\n> The specification as written here differs from the original cryptographic design in [OPAQUE]. The following list enumerates important differences:\r\n\r\n> Clients construct envelope contents without revealing the password to the server, as described in Section 5, whereas the servers construct envelopes in [OPAQUE].\r\n\r\nThis change adds to the security of the protocol. [OPAQUE] considered the case where the envelope was constructed by the server for reasons of compatibility with previous UC modeling, no essential reason. A later paper, to be submitted shortly, analyzes the registration phase as specified here. This new paper can be posted if we are requested to do so.\r\n\r\n> Envelopes do not contain encrypted credentials. Instead, envelopes contain information used to derive client private key material for the AKE.\r\n\r\nThis variant is also analyzed in the new paper referred to in the previous item.  This change improves the assumption behind the protocol by getting rid of equivocability and random key robustness (RKR) for the encryption function (the latter property is only required for authentication and achieved by HMAC).\r\n\r\n> Envelopes are masked with a per-user masking key as a way of preventing client enumeration attacks. See Section 10.9 for more details.\r\n\r\nThis extension does not add to the security of OPAQUE as an aPAKE but only used to provide a defense against enumeration attacks. In the analysis, this key can be simulated as a (pseudo) random key.\r\n\r\n> Per-user OPRF keys are derived from a client identity and cross-user seed as a mitigation against client enumeration attacks. See Section 10.9 for more details.\r\n\r\nThe analysis of OPAQUE assumes OPRF keys of different users are independently random or pseudorandom. Deriving these keys via a single PRF (i.e., with a single cross-user key) applied to users' identities satisfies this assumption.\r\n\r\n> The protocol outputs an export key for the client in addition to shared session key that can be used for application-specific purposes.\r\n\r\nThis key is a pseudorandom value independent of other values in the protocol and have no influence in the security analysis (it can be simulated with a random output).\r\n\r\n> The protocol admits optional application-layer client and server identities. In the absence of these identities, client and server are authenticated against their public keys.\r\n\r\nBinding authentication to identities is part of the AKE part of OPAQUE. The type of identities and their semantics are application dependent and independent of the protocol analysis\r\n\r\n> The protocol admits application-specific context information configured out-of-band in the AKE transcript. This allows domain separation between different application uses of OPAQUE.\r\n\r\nThis is a mechanism for the AKE component and is best practice as for domain separation between different applications of the protocol.\r\n\r\n> Servers use a separate identifier for computing OPRF evaluations and indexing into the password file storage, called the credential_identifier. This allows clients to change their application-layer identity (client_identity) without inducing server-side changes, e.g., by changing an email address associated with a given account.\r\n\r\nThis mechanism is part of the derivation of OPRF keys via a single OPRF. As long as the derivation of different OPRF keys from a single OPRF have different PRF inputs, the protocol is secure. The choice of such inputs is up to the application.",
          "createdAt": "2021-12-20T20:18:08Z",
          "updatedAt": "2021-12-20T20:18:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4wOIpz",
          "commit": {
            "abbreviatedOid": "be015e6"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-11-17T18:52:00Z",
          "updatedAt": "2021-11-17T18:55:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\n- Envelopes do not contain encrypted credentials. Instead, envelopes contain information used to derive client private key material for the AKE.\n```\n",
              "createdAt": "2021-11-17T18:52:00Z",
              "updatedAt": "2021-11-17T18:55:08Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\n- Per-user OPRF keys are derived from a client identity and cross-user seed. This is done to mitigate against client enumeration attacks. See {{preventing-client-enumeration}} for more details.\n```\n",
              "createdAt": "2021-11-17T18:52:17Z",
              "updatedAt": "2021-11-17T18:55:08Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\n- The protocol outputs an export key for the client in addition to shared session key that can be used for application-specific purposes.\n```\n",
              "createdAt": "2021-11-17T18:53:22Z",
              "updatedAt": "2021-11-17T18:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wPE0t",
          "commit": {
            "abbreviatedOid": "bd50e79"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-17T23:19:45Z",
          "updatedAt": "2021-11-17T23:19:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 288,
      "id": "PR_kwDOD79ejs4urTzp",
      "title": "Update masking key description",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/288",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @hugokraw ",
      "createdAt": "2021-11-17T20:49:44Z",
      "updatedAt": "2021-11-21T20:16:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "04473ca51110577d58b3c46067402678f1d329d7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fix-masking-key-description",
      "headRefOid": "00616dee1a8de10cf9198eaf2d0250b25b10d247",
      "closedAt": "2021-11-20T00:56:41Z",
      "mergedAt": "2021-11-20T00:56:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9f5e675a5fafb3c30d0ac0d3e29f260ae375293b"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I see two places where the masking_key function is defined in English:\r\n- masking_key, an encryption key used by the server with the sole purpose \r\n  of defending against client enumeration attacks.\r\n- An encryption key used by the server to preserve confidentiality of the envelope during login\r\n  to defend against client enumeration attacks.\r\n\r\nLet's have only one definition (even if repeated in two places).\r\nIn any case use the first. The masking is not used for confidentiality of the envelope (this is not required). What the masking does is to re-randomize the envelope to avoid linkability of same-user logins and allow for fake envelopes as needed to prevent enumeration attacks.  This explanation can be added to the security considerations.\r\n\r\nAlso, _I would very much like_ to see in the Security Considerations a sentence saying that the use of the DeriveKeyPair function for computing the oprf_key is only needed as an artifact against enumeration attacks. The security of OPAQUE does not require this otherwise, i.e., it can choose OPRF keys for the different users as random independent (or pseudorandom)  keys. \r\n\r\nOne reason to say this is that choosing OPRF keys via DeriveKeyPair is suboptimal for threshold implementations of the OPRF function (this reason need not be said in this RFC except if we want to say something about threshold implementations).",
          "createdAt": "2021-11-21T20:16:58Z",
          "updatedAt": "2021-11-21T20:16:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4wPGjx",
          "commit": {
            "abbreviatedOid": "521af56"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T23:32:19Z",
          "updatedAt": "2021-11-17T23:32:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It may be implicit here, but isn't it useful to clarify that it's an encryption key ?",
              "createdAt": "2021-11-17T23:32:20Z",
              "updatedAt": "2021-11-17T23:32:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wPG8O",
          "commit": {
            "abbreviatedOid": "521af56"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T23:35:23Z",
          "updatedAt": "2021-11-17T23:35:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n- masking_key, an encryption key used by the server with the sole purpose \r\n```",
              "createdAt": "2021-11-17T23:35:23Z",
              "updatedAt": "2021-11-17T23:35:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wPG9X",
          "commit": {
            "abbreviatedOid": "521af56"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T23:35:31Z",
          "updatedAt": "2021-11-17T23:35:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n: An encryption key used by the server to preserve confidentiality of the envelope during login\r\n```",
              "createdAt": "2021-11-17T23:35:31Z",
              "updatedAt": "2021-11-17T23:35:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wPHAh",
          "commit": {
            "abbreviatedOid": "5f2c6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T23:35:54Z",
          "updatedAt": "2021-11-17T23:35:54Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I don't know if it's useful, but it probably doesn't hurt. Fix applied.",
              "createdAt": "2021-11-17T23:35:54Z",
              "updatedAt": "2021-11-17T23:35:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4wYrak",
          "commit": {
            "abbreviatedOid": "00616de"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-20T00:47:31Z",
          "updatedAt": "2021-11-20T00:47:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "PR_kwDOD79ejs4uvnZe",
      "title": "Make Setup phase explicit and indexable.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/292",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #289 ",
      "createdAt": "2021-11-18T23:54:37Z",
      "updatedAt": "2021-12-31T06:09:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "02871345acefcb7aa9bc78c48c4f8b059761d0d2",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "setup",
      "headRefOid": "c350ec87ef5913db173145fe3212ca577e7d3614",
      "closedAt": "2021-12-30T18:33:18Z",
      "mergedAt": "2021-12-30T18:33:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "626cf2c23ca8a9a234ddd92274b908cd1294f957"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4x0TaJ",
          "commit": {
            "abbreviatedOid": "c350ec8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like this, it's cleaner :)",
          "createdAt": "2021-12-18T18:45:13Z",
          "updatedAt": "2021-12-18T18:45:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4yMI6g",
          "commit": {
            "abbreviatedOid": "c350ec8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-30T18:33:13Z",
          "updatedAt": "2021-12-30T18:33:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 293,
      "id": "PR_kwDOD79ejs4u0PQi",
      "title": "update Cloudflare affiliation name",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/293",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood I believe this needs to be updated, correct?",
      "createdAt": "2021-11-21T18:23:51Z",
      "updatedAt": "2023-04-03T09:09:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9f5e675a5fafb3c30d0ac0d3e29f260ae375293b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/patch-cf-affiliation",
      "headRefOid": "bc0947d3a449abeb9e77489eaf651ce95296d6f2",
      "closedAt": "2021-12-01T00:05:00Z",
      "mergedAt": "2021-12-01T00:05:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a1308187baae56a472f0b52b771fade2b60598a0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 297,
      "id": "PR_kwDOD79ejs4wfUDk",
      "title": "minor typo fix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/297",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-04T02:00:51Z",
      "updatedAt": "2022-01-06T22:41:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "626cf2c23ca8a9a234ddd92274b908cd1294f957",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "typo-fix",
      "headRefOid": "c6141ad450ce0d36fd66708fd4d539ecb3ab6ab3",
      "closedAt": "2022-01-06T22:31:32Z",
      "mergedAt": "2022-01-06T22:31:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "05884b9524ca6ef08945e8b566dc617eabf2ac97"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4ybukw",
          "commit": {
            "abbreviatedOid": "c6141ad"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-06T22:30:12Z",
          "updatedAt": "2022-01-06T22:30:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 299,
      "id": "PR_kwDOD79ejs4woZ7j",
      "title": "Add rationale for paper<>spec differences.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/299",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @hugokraw, as this adds additional rationale from #287.",
      "createdAt": "2022-01-06T22:36:55Z",
      "updatedAt": "2022-01-10T15:04:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "05884b9524ca6ef08945e8b566dc617eabf2ac97",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/add-rationale",
      "headRefOid": "d6de7ddb92c84af8ce65d02bf60c325ce0074433",
      "closedAt": "2022-01-10T15:04:20Z",
      "mergedAt": "2022-01-10T15:04:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ca97f4ae8423494f0a1c7f6e22609a240e1b4b16"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(@bytemare I didn't mean to remove you as a reviewer -- double click or something? \ud83e\udd37 )",
          "createdAt": "2022-01-07T19:24:53Z",
          "updatedAt": "2022-01-07T19:24:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4yfAB1",
          "commit": {
            "abbreviatedOid": "d6de7dd"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-07T20:54:17Z",
          "updatedAt": "2022-01-07T20:54:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 300,
      "id": "PR_kwDOD79ejs4wocp-",
      "title": "Make pseudocode more readable",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/300",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Closes #244.",
      "createdAt": "2022-01-06T22:49:04Z",
      "updatedAt": "2022-02-02T17:31:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "956ad1eb191f7c6395f0cef51997237848677541",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/pythonic",
      "headRefOid": "9ac4f57bec24795b4b25b02a1d725b5f26fc09ac",
      "closedAt": "2022-02-02T17:31:12Z",
      "mergedAt": "2022-02-02T17:31:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f8e30d97662dfe2f953f65b0b178d620d2b35fba"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi, thoughts on readability?",
          "createdAt": "2022-01-19T15:13:12Z",
          "updatedAt": "2022-01-19T15:13:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4yd7JY",
          "commit": {
            "abbreviatedOid": "fc0c956"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-07T15:14:23Z",
          "updatedAt": "2022-01-07T15:14:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "#244 mentions the unification of capitalization in input argument comments, which is not in this PR. Is that planned for another PR?",
              "createdAt": "2022-01-07T15:14:23Z",
              "updatedAt": "2022-01-07T15:14:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4zXcxa",
          "commit": {
            "abbreviatedOid": "fc0c956"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall, really like the change! Just one comment about the tuple outputs.",
          "createdAt": "2022-01-25T05:00:37Z",
          "updatedAt": "2022-01-25T05:03:29Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think it is fine here, since we do not want to capitalize.",
              "createdAt": "2022-01-25T05:00:38Z",
              "updatedAt": "2022-01-25T05:03:29Z"
            },
            {
              "originalPosition": 95,
              "body": "While we are here, I kindof feel like it would be cleaner to do:\r\n`(_, client_public_key) = DeriveAuthKeyPair(seed)`\r\n\r\ninstead of:\r\n`_, client_public_key = DeriveAuthKeyPair(seed)`\r\n\r\nfor everywhere where DeriveAuthKeyPair is called.",
              "createdAt": "2022-01-25T05:02:33Z",
              "updatedAt": "2022-01-25T05:03:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4zsaOe",
          "commit": {
            "abbreviatedOid": "5e690b4"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T00:44:59Z",
          "updatedAt": "2022-01-31T00:44:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 301,
      "id": "PR_kwDOD79ejs4wroMN",
      "title": "Move up the name meaning",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/301",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I propose to move the name origin to the intro, where it makes more sense to me than in the notation section",
      "createdAt": "2022-01-07T23:49:00Z",
      "updatedAt": "2023-04-03T09:09:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "05884b9524ca6ef08945e8b566dc617eabf2ac97",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/move-name",
      "headRefOid": "abe9122597182a0f23060ff8da6a4040e7de4948",
      "closedAt": "2022-01-08T01:28:02Z",
      "mergedAt": "2022-01-08T01:28:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "855354fa80c3791870dd349909e3feb806562899"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4yfa5z",
          "commit": {
            "abbreviatedOid": "abe9122"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-08T01:27:54Z",
          "updatedAt": "2022-01-08T01:27:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 302,
      "id": "PR_kwDOD79ejs4wrwpp",
      "title": "remove reference to inner_env",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/302",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-08T02:18:14Z",
      "updatedAt": "2022-01-10T15:08:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "855354fa80c3791870dd349909e3feb806562899",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "cleanup",
      "headRefOid": "84a52c8ae610cbf5412fc788152ca9c1866a39bf",
      "closedAt": "2022-01-10T15:04:09Z",
      "mergedAt": "2022-01-10T15:04:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1126b74edd0d92949f7bb6010313e9b2e0ffc5d5"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch!",
          "createdAt": "2022-01-08T13:15:50Z",
          "updatedAt": "2022-01-08T13:15:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4yfo9n",
          "commit": {
            "abbreviatedOid": "84a52c8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-08T13:15:59Z",
          "updatedAt": "2022-01-08T13:15:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 303,
      "id": "PR_kwDOD79ejs4wsbpk",
      "title": "fix dst in DeriveAuthKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/303",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This follows the code https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/opaque_core.sage#L65",
      "createdAt": "2022-01-09T01:53:38Z",
      "updatedAt": "2022-01-10T15:07:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "855354fa80c3791870dd349909e3feb806562899",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "h2c-dst",
      "headRefOid": "90e68b5a2ef27764c5e3d0144194b8f6e1925232",
      "closedAt": "2022-01-10T15:03:33Z",
      "mergedAt": "2022-01-10T15:03:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "aefd7ca05e3db6a0d542435d14a0a64a45242ff6"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "This is being addressed in #286 ",
          "createdAt": "2022-01-09T18:28:43Z",
          "updatedAt": "2022-01-09T18:28:43Z"
        },
        {
          "author": "aldenml",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bytemare thanks for the review and for pointing out this is addressed in #286, however, that PR is big and I have no idea if the merge ETA is short. Btw, this was an important element in trying to match the test vector for`KE1`. If you have veto power, I can close this immediately, otherwise, I hope you don't mind if I keep it open until @chris-wood have the time to look at it.",
          "createdAt": "2022-01-10T01:04:53Z",
          "updatedAt": "2022-01-10T01:04:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I suspect #286 will be overcome by events, so let's land this now.",
          "createdAt": "2022-01-10T15:03:27Z",
          "updatedAt": "2022-01-10T15:03:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4yinJI",
          "commit": {
            "abbreviatedOid": "90e68b5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-10T15:03:08Z",
          "updatedAt": "2022-01-10T15:03:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 306,
      "id": "PR_kwDOD79ejs4ws7mZ",
      "title": "Add Record encryption to Security Consideration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/306",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "closes #240, #306, and #310\r\n\r\nThis suggests protecting the client's record during registration with HPKE.",
      "createdAt": "2022-01-09T18:10:41Z",
      "updatedAt": "2022-07-01T15:53:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "855354fa80c3791870dd349909e3feb806562899",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/hpke-record",
      "headRefOid": "31f106679c549b4716ebaebda9e5e06081979e80",
      "closedAt": "2022-07-01T15:53:52Z",
      "mergedAt": "2022-07-01T15:53:52Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "fdbfd38da23935e35ca986fa07111a26fcaac890"
      },
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I understand correctly, #310 makes this obsolete?",
          "createdAt": "2022-01-18T12:09:43Z",
          "updatedAt": "2022-01-18T12:09:52Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "putting this as draft, awaiting feedback on #310 ",
          "createdAt": "2022-01-25T22:10:12Z",
          "updatedAt": "2022-01-25T22:10:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4yjib9",
          "commit": {
            "abbreviatedOid": "09fbec8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think we can simplify this greatly and simply note that application-layer encryption is one possible way to implement the registration channel, no? @kevinlewi, @hugokraw, what do you think?",
          "createdAt": "2022-01-10T18:15:16Z",
          "updatedAt": "2022-01-10T18:15:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4y-xgF",
          "commit": {
            "abbreviatedOid": "09fbec8"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Agreed with @chris-wood ",
          "createdAt": "2022-01-18T11:58:33Z",
          "updatedAt": "2022-01-18T12:02:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "To keep in style with the nearby headers, this should be formatted by capitalizing the first letter of each word, perhaps even changing the text to: `Protecting the Registration Masking Key`",
              "createdAt": "2022-01-18T11:58:34Z",
              "updatedAt": "2022-01-18T12:02:16Z"
            },
            {
              "originalPosition": 22,
              "body": "Perhaps, to keep this short and avoid concrete recommendations, we can just replace this text (starting from like 1874) with \"Implementations should ensure that application-layer encryption is applied to this masking key in the last message of the registration phase.\"",
              "createdAt": "2022-01-18T12:00:59Z",
              "updatedAt": "2022-01-18T12:02:16Z"
            },
            {
              "originalPosition": 9,
              "body": "I would remove \"authenticity\" because it is redundant, or if it really needs to be there, at least replace with \"authentication\"",
              "createdAt": "2022-01-18T12:01:42Z",
              "updatedAt": "2022-01-18T12:02:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4y-zha",
          "commit": {
            "abbreviatedOid": "09fbec8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T12:06:44Z",
          "updatedAt": "2022-01-18T12:06:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "There's no authentication at the registration phase. The wording could be misleading.\n\nRegarding authenticity, it's with regard to server messages really coming from the server.",
              "createdAt": "2022-01-18T12:06:45Z",
              "updatedAt": "2022-01-18T12:06:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40hGpM",
          "commit": {
            "abbreviatedOid": "09fbec8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T01:57:07Z",
          "updatedAt": "2022-02-14T01:57:07Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "what do you think?",
              "createdAt": "2022-02-14T01:57:07Z",
              "updatedAt": "2022-02-14T01:57:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40hG88",
          "commit": {
            "abbreviatedOid": "09fbec8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T02:00:56Z",
          "updatedAt": "2022-02-14T02:00:57Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I'm not sure this really exposes the rationale of the recommandation",
              "createdAt": "2022-02-14T02:00:56Z",
              "updatedAt": "2022-02-14T02:00:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dRDW",
          "commit": {
            "abbreviatedOid": "060fb40"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mostly requesting simplifications.",
          "createdAt": "2022-05-21T00:30:40Z",
          "updatedAt": "2022-05-21T00:34:27Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nencryption key generated by the client on registration that is sent to the server over\r\nan authenticated channel, such as one provided by TLS {{RFC8446}}.\r\n```",
              "createdAt": "2022-05-21T00:30:40Z",
              "updatedAt": "2022-05-21T00:34:27Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nIn the event that this channel is compromised, this encryption key could be leaked\r\nto an attacker.\r\n```",
              "createdAt": "2022-05-21T00:31:47Z",
              "updatedAt": "2022-05-21T00:34:27Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nOne mitigation against this threat is to additionally encrypt the `RegistrationRecord` \r\nsent from client to server at the application layer using public key encryption, e.g., \r\nwith HPKE {{?RFC9180}}.\r\n```",
              "createdAt": "2022-05-21T00:33:02Z",
              "updatedAt": "2022-05-21T00:34:27Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n```\r\n\r\nI don't think we can keep this text since it would effectively yield a different protocol. Moreover, this is kind of redundant with the HPKE approach, so I don't think it adds much.",
              "createdAt": "2022-05-21T00:34:16Z",
              "updatedAt": "2022-05-21T00:34:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dyZo",
          "commit": {
            "abbreviatedOid": "d7d2ff2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T00:45:38Z",
          "updatedAt": "2022-05-22T00:45:38Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I'm not at all convinced that it yields a different protocol, as this only replaces the envelope encryption, itself an added component to the original OPAQUE protocol. I agree that the added complexity is out of scope for the document though, that's why we said we would mention it here.\r\n\r\ncf the discussion in #310",
              "createdAt": "2022-05-22T00:45:38Z",
              "updatedAt": "2022-05-22T00:45:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dya9",
          "commit": {
            "abbreviatedOid": "d7d2ff2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T00:47:27Z",
          "updatedAt": "2022-05-22T00:47:27Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I mean that the protocol mechanics change if this done rather than the existing encryption scheme. I agree that _functionally_ the protocol remains the same, but the implementation would be different. Hence, a different protocol.",
              "createdAt": "2022-05-22T00:47:27Z",
              "updatedAt": "2022-05-22T00:47:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dyey",
          "commit": {
            "abbreviatedOid": "060fb40"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T00:54:18Z",
          "updatedAt": "2022-05-22T00:54:19Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Would you accept a shorter, less detailed version of this paragraph stating this rationale? I think we should still mention that there _might_ be a problem for some threat models, and agree the countermeasures burden this spec",
              "createdAt": "2022-05-22T00:54:19Z",
              "updatedAt": "2022-05-22T00:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dyfM",
          "commit": {
            "abbreviatedOid": "8a46cd8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T00:55:19Z",
          "updatedAt": "2022-05-22T00:55:20Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Sure, but isn't that already covered by the HPKE suggestion? I don't think any more detail is useful.",
              "createdAt": "2022-05-22T00:55:19Z",
              "updatedAt": "2022-05-22T00:55:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dyqn",
          "commit": {
            "abbreviatedOid": "060fb40"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T01:13:30Z",
          "updatedAt": "2022-05-22T01:13:30Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Not really, the first addresses TLS compromission, and the second addresses the fact of having a client secret stored on the server. \r\n\r\nI updated the paragraph",
              "createdAt": "2022-05-22T01:13:30Z",
              "updatedAt": "2022-05-22T01:13:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dyul",
          "commit": {
            "abbreviatedOid": "a63f064"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T01:19:35Z",
          "updatedAt": "2022-05-22T01:19:35Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I still don't get it. In both cases public key encryption is used. I think the latter case should be removed entirely.",
              "createdAt": "2022-05-22T01:19:35Z",
              "updatedAt": "2022-05-22T01:19:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46dzKZ",
          "commit": {
            "abbreviatedOid": "060fb40"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T02:07:18Z",
          "updatedAt": "2022-05-22T02:07:18Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "In the first case, the record holding the masking key is encrypted on registration. On login, the current symmetric method is used.\r\n\r\nIn the second case, the whole symmetric encryption is dropped: the user replaces the symmetric key with a public key on registration (therefore meaning risk number one is thwarted without encryption of the record), and the server encrypts the envelope with that provided key. Here the server does not need to store a secret value.\r\n\r\nBoth mechanisms use public-key encryption, yes, but only the second one addresses both risks. That's why I'm insisting on its value :)",
              "createdAt": "2022-05-22T02:07:18Z",
              "updatedAt": "2022-05-22T02:07:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs49LWbA",
          "commit": {
            "abbreviatedOid": "fb27b7d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-01T15:45:52Z",
          "updatedAt": "2022-07-01T15:46:35Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nHowever, the details of this mechanism are out of scope\r\n```",
              "createdAt": "2022-07-01T15:45:52Z",
              "updatedAt": "2022-07-01T15:46:35Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-07-01T15:46:32Z",
              "updatedAt": "2022-07-01T15:46:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 311,
      "id": "PR_kwDOD79ejs4w1W4S",
      "title": "add a c implementation to readme",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/311",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello, for your consideration (relevant files):\r\n\r\nhttps://github.com/aldenml/ecc/blob/master/src/opaque.h\r\nhttps://github.com/aldenml/ecc/blob/master/src/opaque.c\r\nhttps://github.com/aldenml/ecc/blob/master/test/test_opaque.c",
      "createdAt": "2022-01-12T04:18:15Z",
      "updatedAt": "2022-01-19T19:04:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4f272470ffa03badde8cac48d7afc0fe9f76d777",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "add-c-impl",
      "headRefOid": "04c3347fac68e2697e0163f317efbd31461f9e36",
      "closedAt": "2022-01-19T15:12:14Z",
      "mergedAt": "2022-01-19T15:12:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2bd872eec80d1644542f6a6677b07bb45986ad50"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4zBCsk",
          "commit": {
            "abbreviatedOid": "04c3347"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-18T19:58:28Z",
          "updatedAt": "2022-01-18T19:58:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 313,
      "id": "PR_kwDOD79ejs4w2klC",
      "title": "Remove duplicate to_hex function in opaque_common.sage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/313",
      "state": "MERGED",
      "author": "jamesw1892",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-12T11:37:23Z",
      "updatedAt": "2022-01-18T18:01:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dc470751604dacc35d0b38b7857bc7b4a9a56e2d",
      "headRepository": "jamesw1892/OPAQUE",
      "headRefName": "patch-1",
      "headRefOid": "927797f5178e0f2c5bc3c783ee986568b0eaf888",
      "closedAt": "2022-01-18T16:57:15Z",
      "mergedAt": "2022-01-18T16:57:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4f272470ffa03badde8cac48d7afc0fe9f76d777"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4zASu9",
          "commit": {
            "abbreviatedOid": "927797f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2022-01-18T16:56:06Z",
          "updatedAt": "2022-01-18T16:56:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 314,
      "id": "PR_kwDOD79ejs4xHc9K",
      "title": "Document errors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/314",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This documents some currently known errors.\r\n\r\ncloses #256 and #312 ",
      "createdAt": "2022-01-16T23:20:33Z",
      "updatedAt": "2023-04-03T09:08:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0e479f1c26e068ebded7ce0135a395af8e473298",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/document-errors",
      "headRefOid": "a958c317a1d3731c36e35c21644acaa7cfb1153c",
      "closedAt": "2022-02-07T15:30:57Z",
      "mergedAt": "2022-02-07T15:30:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "245c42218e2a0f57fec8763f49b2bd4bd4b6a0d3"
      },
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As war as I can tell, this does not address #312. For example [`CreateRegistrationResponse`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.2-1) can fail with [`InverseError`](https://www.ietf.org/archive/id/draft-irtf-cfrg-voprf-08.html#section-5.1-2.3), which isn't mentioned here.",
          "createdAt": "2022-01-17T04:52:20Z",
          "updatedAt": "2022-01-17T04:52:20Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "> As war as I can tell, this does not address #312. For example [`CreateRegistrationResponse`](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5.2.2-1) can fail with [`InverseError`](https://www.ietf.org/archive/id/draft-irtf-cfrg-voprf-08.html#section-5.1-2.3), which isn't mentioned here.\n\n@daxpedda that's the POPRF error, correct?\nhttps://github.com/cfrg/draft-irtf-cfrg-voprf/pull/304 brings back the \"vanilla\" OPRF, which OPAQUE will use once that PR is merged. The server won't be subject to that error anymore",
          "createdAt": "2022-01-17T12:33:17Z",
          "updatedAt": "2022-01-17T12:33:17Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the explanation @bytemare, looking forward to that then!",
          "createdAt": "2022-01-17T13:21:03Z",
          "updatedAt": "2022-01-17T13:21:03Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking through cfrg/draft-irtf-cfrg-voprf#304, \"vanilla\" OPRF [`Blind`](https://cfrg.github.io/draft-irtf-cfrg-voprf/caw/all-three/draft-irtf-cfrg-voprf.html#section-3.3.1-2) can still produce a zero scalar. Is that something that should be addressed in the VOPRF spec or is that something that OPAQUE should handle? (I'm actually not sure if producing a zero scalar here would be a problem)",
          "createdAt": "2022-01-17T13:29:15Z",
          "updatedAt": "2022-01-17T13:29:15Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "note to self: add the OPRF InvalidInputError",
          "createdAt": "2022-01-31T00:58:02Z",
          "updatedAt": "2022-01-31T00:58:02Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@daxpedda We'd like to land this PR. Please don't hesitate if you think about other errors that we haven't covered here! :) ",
          "createdAt": "2022-02-03T15:44:22Z",
          "updatedAt": "2022-02-03T15:44:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4y5P_U",
          "commit": {
            "abbreviatedOid": "afb4609"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-17T04:53:02Z",
          "updatedAt": "2022-01-17T04:53:02Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nMACs exchanged during the AKE that might not verify. Additionally, given the statically sized nature\r\n```\r\nNot exactly sure, english isn't my first language.",
              "createdAt": "2022-01-17T04:53:02Z",
              "updatedAt": "2022-01-17T04:53:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4y6-HM",
          "commit": {
            "abbreviatedOid": "afb4609"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-17T12:12:58Z",
          "updatedAt": "2022-01-17T12:12:58Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Mine neither :) but you're correct !",
              "createdAt": "2022-01-17T12:12:58Z",
              "updatedAt": "2022-01-17T12:12:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4zB8o0",
          "commit": {
            "abbreviatedOid": "0becd7e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like this a lot! I'd like to move away from the Go-like naming convention, but otherwise, let's get this tidied up and landed.",
          "createdAt": "2022-01-19T01:20:43Z",
          "updatedAt": "2022-02-02T14:19:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I find this pretty Go-specific. Can we revert to the old form, where this would be \"InvalidEnvelopeMACError\"?",
              "createdAt": "2022-01-19T01:20:43Z",
              "updatedAt": "2022-02-02T14:19:20Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nconfigurations, and do not cover potential errors in other configurations. Participants MUST abort the\r\n```",
              "createdAt": "2022-02-02T14:15:17Z",
              "updatedAt": "2022-02-02T14:19:20Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nSome functions included in this specification are fallible. For example,\r\n```",
              "createdAt": "2022-02-02T14:15:37Z",
              "updatedAt": "2022-02-02T14:19:20Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nMACs exchanged during the AKE might fail verification, yielding an error. Additionally, protocol messages \r\nsent between client and server might not match their expected size, yielding a different error.\r\n```",
              "createdAt": "2022-02-02T14:16:55Z",
              "updatedAt": "2022-02-02T14:19:20Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nThe client can produce errors due to incorrect values in the messages it received. The following\r\ntable enumerates some of these errors, where they occur, and the reason for the error.\r\n```",
              "createdAt": "2022-02-02T14:17:42Z",
              "updatedAt": "2022-02-02T14:19:20Z"
            },
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nThe following table enumerates server errors that can occur, where they occur, and the reason for the error.\r\nIn this case, servers can only generate a single protocol error.\r\n```",
              "createdAt": "2022-02-02T14:18:32Z",
              "updatedAt": "2022-02-02T14:19:20Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nthese are not protocol errors, and are indicative. The following table enumerates server errors that can occur, where they occur, and the reason for the error.\r\n```",
              "createdAt": "2022-02-02T14:19:01Z",
              "updatedAt": "2022-02-02T14:19:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-kiF",
          "commit": {
            "abbreviatedOid": "9a832d3"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I was following this already, LGTM :+1:.",
          "createdAt": "2022-02-03T15:49:39Z",
          "updatedAt": "2022-02-03T15:49:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4z-o4a",
          "commit": {
            "abbreviatedOid": "9a832d3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think we need to sharpen some of the descriptions here, update some names, and mark how noted errors can be thrown in the rest of the doc.",
          "createdAt": "2022-02-03T16:01:38Z",
          "updatedAt": "2022-02-03T16:09:45Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\n| InvalidBlindedDataError              | Server | RegistrationRequest, Ke1  | Blinded data is an invalid element.                    |\r\n```",
              "createdAt": "2022-02-03T16:01:38Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\n| InvalidEvaluatedDataError            | Client | RegistrationResponse, Ke2 | Invalid OPRF key derivation.                       |\r\n```\r\nAlso, it doesn't look like this is actually raised in the spec?",
              "createdAt": "2022-02-03T16:03:01Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 92,
              "body": "Is this raised in the spec? I guess it's implicit, but we should probably note that otherwise.",
              "createdAt": "2022-02-03T16:03:12Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 94,
              "body": "What does \"invalid public key\" mean here? (Same comment as below)",
              "createdAt": "2022-02-03T16:03:59Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\n| InvalidMaskedLengthError    | ClientFinish                                           | Invalid masked response length. |\r\n```",
              "createdAt": "2022-02-03T16:04:58Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n| InvalidEnvelopeMACError     | ClientFinish                                           | Envelope authentication check failed.                                     |\r\n```\r\n\r\n(And likewise below?)",
              "createdAt": "2022-02-03T16:05:20Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 45,
              "body": "Can we rename this to \"HandshakeAuthenticationError\", \"ServerAuthenticationFailure,\" or similar? I don't know if we need to note \"AKE\" and \"MAC\".",
              "createdAt": "2022-02-03T16:07:16Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 131,
              "body": "Why would this be thrown from the protocol, rather than enforced as a pre-condition to LoginInit? (Also, what is the LoginInit stage? It's not listed in the doc.)",
              "createdAt": "2022-02-03T16:08:18Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            },
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n| InvalidInputError           | CreateRegistrationRequest, CreateCredentialRequest | OPRF input deterministically maps to the group identity element.         |\r\n```",
              "createdAt": "2022-02-03T16:08:58Z",
              "updatedAt": "2022-02-03T16:09:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-s23",
          "commit": {
            "abbreviatedOid": "9a832d3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T16:12:50Z",
          "updatedAt": "2022-02-03T16:12:50Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Isn't that more telling?\r\nI fear that ServerAuthenticationFailure is too vague and doesn't say what the actual error is. e.g. it could be mistaken with the server sending the wrong public key (or whatever - this would result in the same error). I like the precision of this wording to pinpoint what went wrong.",
              "createdAt": "2022-02-03T16:12:50Z",
              "updatedAt": "2022-02-03T16:12:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-tfY",
          "commit": {
            "abbreviatedOid": "9a832d3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T16:14:43Z",
          "updatedAt": "2022-02-03T16:14:44Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Yes, it's implicit. How do you suggest we should specify that?",
              "createdAt": "2022-02-03T16:14:44Z",
              "updatedAt": "2022-02-03T16:14:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-tsR",
          "commit": {
            "abbreviatedOid": "9a832d3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T16:15:21Z",
          "updatedAt": "2022-02-03T16:15:22Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Add a second table with the implicit exceptions that come from other specs?",
              "createdAt": "2022-02-03T16:15:21Z",
              "updatedAt": "2022-02-03T16:15:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-vN6",
          "commit": {
            "abbreviatedOid": "9a832d3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T16:19:47Z",
          "updatedAt": "2022-02-03T16:19:47Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Yes, I wanted to discuss this in the PR-draft stage. As stated, implementations must observe these conditions, and can raise these errors, since these conditions are necessary for the protocol to execute correctly",
              "createdAt": "2022-02-03T16:19:47Z",
              "updatedAt": "2022-02-03T16:19:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-vlp",
          "commit": {
            "abbreviatedOid": "9a832d3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T16:20:50Z",
          "updatedAt": "2022-02-03T16:20:50Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "I suppose LoginInit comes from my implementation, my bad! Amending right now ",
              "createdAt": "2022-02-03T16:20:50Z",
              "updatedAt": "2022-02-03T16:20:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-yap",
          "commit": {
            "abbreviatedOid": "da91ce2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T16:29:15Z",
          "updatedAt": "2022-02-03T16:29:15Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Yes, many are implicit.\r\n\r\nWhat about adding a dedicated table for implicit errors coming from other specs?",
              "createdAt": "2022-02-03T16:29:15Z",
              "updatedAt": "2022-02-03T16:29:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z_NHX",
          "commit": {
            "abbreviatedOid": "55c39e9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T17:46:41Z",
          "updatedAt": "2022-02-03T17:46:41Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Can't we just add these alongside the existing errors? I think it'd also be good to note these errors alongside errors that OPAQUE generates on its own.",
              "createdAt": "2022-02-03T17:46:41Z",
              "updatedAt": "2022-02-03T17:46:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z_NQX",
          "commit": {
            "abbreviatedOid": "55c39e9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T17:47:10Z",
          "updatedAt": "2022-02-03T17:47:11Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Maybe ServerAuthenticationMACError then?",
              "createdAt": "2022-02-03T17:47:10Z",
              "updatedAt": "2022-02-03T17:47:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40AJID",
          "commit": {
            "abbreviatedOid": "dd8fd15"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T21:49:46Z",
          "updatedAt": "2022-02-03T21:49:47Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "To me, it's not a valid point in the group. Would another name be more suitable?",
              "createdAt": "2022-02-03T21:49:46Z",
              "updatedAt": "2022-02-03T21:49:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40AJYV",
          "commit": {
            "abbreviatedOid": "dd8fd15"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T21:51:00Z",
          "updatedAt": "2022-02-03T21:51:00Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Note that it's different from the deserialization: an input can correctly deserialize, but if the config dictates a different group, than the deserialized input would not be valid for that config",
              "createdAt": "2022-02-03T21:51:00Z",
              "updatedAt": "2022-02-03T21:51:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40JTX8",
          "commit": {
            "abbreviatedOid": "279a8f2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T15:30:21Z",
          "updatedAt": "2022-02-07T15:30:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs40JTd6",
          "commit": {
            "abbreviatedOid": "279a8f2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T15:30:36Z",
          "updatedAt": "2022-02-07T15:30:38Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n- ServerAuthenticationError, the handshake fails.\r\n```",
              "createdAt": "2022-02-07T15:30:38Z",
              "updatedAt": "2022-02-07T15:30:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40JTih",
          "commit": {
            "abbreviatedOid": "279a8f2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T15:30:48Z",
          "updatedAt": "2022-02-07T15:30:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 315,
      "id": "PR_kwDOD79ejs4xHdsg",
      "title": "add OPAQUE version for implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/315",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think it's nice stealing that from VOPRF",
      "createdAt": "2022-01-16T23:38:53Z",
      "updatedAt": "2023-04-03T09:08:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dc470751604dacc35d0b38b7857bc7b4a9a56e2d",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/add-version-readme",
      "headRefOid": "5265c593379ec2abe429258ef9815bf92e568970",
      "closedAt": "2022-01-18T16:55:41Z",
      "mergedAt": "2022-01-18T16:55:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1c49d22ee1d184d2c430e4ff40dba5c3743937f4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4zASlm",
          "commit": {
            "abbreviatedOid": "5265c59"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-18T16:55:37Z",
          "updatedAt": "2022-01-18T16:55:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 316,
      "id": "PR_kwDOD79ejs4xM5cA",
      "title": "Adding back definition for SerializeElement",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/316",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #295.\r\n\r\nI decided to rename the function from `SerializePublicKey` to `SerializeElement` since the multiplication of the element with the scalar produces another element (not necessarily a \"public key\").",
      "createdAt": "2022-01-18T12:58:32Z",
      "updatedAt": "2022-01-18T16:55:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dc470751604dacc35d0b38b7857bc7b4a9a56e2d",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_back_serialize_element",
      "headRefOid": "e603515f1691fbc8b89937ae90e022f1880a88c2",
      "closedAt": "2022-01-18T16:55:20Z",
      "mergedAt": "2022-01-18T16:55:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9c3a9d7ce6d2b9f08abe0eb46736bc66b8bdef11"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4y_EcY",
          "commit": {
            "abbreviatedOid": "e603515"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-18T13:00:54Z",
          "updatedAt": "2022-01-18T13:00:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4zASdq",
          "commit": {
            "abbreviatedOid": "e603515"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-18T16:55:11Z",
          "updatedAt": "2022-01-18T16:55:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 317,
      "id": "PR_kwDOD79ejs4xcwpe",
      "title": "Expose export key after generating ke3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/317",
      "state": "MERGED",
      "author": "jamesw1892",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The client is meant to get an export key (in addition to the session key) from the registration flow but `generate_ke3` ignores the export key obtained by calling `core.recover_credentials` so it can't be retrieved. I save it to the instance so it can be retrieved in the same way as the session key.",
      "createdAt": "2022-01-22T22:37:02Z",
      "updatedAt": "2022-02-02T16:59:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2bd872eec80d1644542f6a6677b07bb45986ad50",
      "headRepository": "jamesw1892/OPAQUE",
      "headRefName": "patch-1",
      "headRefOid": "ff202bea34438339684fb3a4985599e60bbbb24f",
      "closedAt": "2022-02-02T14:07:04Z",
      "mergedAt": "2022-02-02T14:07:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "09c17ffc7b25a5aca55a6192a375142efe5fef70"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4zRlhh",
          "commit": {
            "abbreviatedOid": "ff202be"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-22T22:50:58Z",
          "updatedAt": "2022-01-22T22:50:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4z5CF7",
          "commit": {
            "abbreviatedOid": "ff202be"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T14:06:59Z",
          "updatedAt": "2022-02-02T14:06:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 318,
      "id": "PR_kwDOD79ejs4xdIJ-",
      "title": "`core.finalize_request` shouldn't require `Credentials` instance",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/318",
      "state": "MERGED",
      "author": "jamesw1892",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`core.finalize_request` requires a `Credentials` instance which it passes to `core.create_envelope` which uses `idS` and `idU` from it to create `CleartextCredentials`. However, a new client key pair is generated in `core.create_envelope` and used instead of the key pair in the `Credentials` instance.\r\n\r\nThis makes for rather confusing code where you need to generate a client key pair to create a `Credentials` instance to call `core.finalize_request`, but this is ignored and the record returned contains a different public key.\r\n\r\nThis was examplified in the `run_test_vector` method in `test_opaque_ake.sage` where on lines 158-160 (now lines 144-146), the public key generated earlier is overwritten with a different one. I have now simplified this test file.\r\n\r\nThis also brings the proof-of-concept in line with the document which only describes needing the client and server identity:\r\n\r\n- `create_envelope`: https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#name-envelope-creation\r\n- `finalize_request`: https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#name-finalizerequest\r\n\r\nOf course, the client and server identity can be `None` meaning the public keys are used instead (the server public key obtained from the response and the client public key generated in `core.create_envelope`).",
      "createdAt": "2022-01-23T10:33:18Z",
      "updatedAt": "2022-02-02T17:00:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2bd872eec80d1644542f6a6677b07bb45986ad50",
      "headRepository": "jamesw1892/OPAQUE",
      "headRefName": "patch-2",
      "headRefOid": "ac5f4aacd80454fe88b92de6e56dcc74d3cce2e7",
      "closedAt": "2022-02-02T14:09:49Z",
      "mergedAt": "2022-02-02T14:09:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f332eefcdcf2fc79e7c6089a379cc4463e026973"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good simplification in the reference implementation. Thanks!",
          "createdAt": "2022-02-02T14:09:46Z",
          "updatedAt": "2022-02-02T14:09:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 319,
      "id": "PR_kwDOD79ejs4xdeDN",
      "title": "Match `generate_ke1` and `generate_ke3` API to document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/319",
      "state": "MERGED",
      "author": "jamesw1892",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With client transcript creation split between `generate_ke1` and `generate_ke3`, extra arguments like `idU`, and `pkU` are required for `generate_ke1`. However, if done entirely in `generate_ke3` then they are only required for `generate_ke3`.\r\n\r\nThis brings the function arguments in line with the pseudocode in the document. Also, in the document, transcript (preamble) creation is done entirely in `ClientFinalize`: https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#name-3dh-client-functions\r\n\r\nAlso, this way `pkS` is not required for `generate_ke1` or `generate_ke3` since it is obtained from `core.recover_credentials` in `generate_ke3`.\r\n\r\nI can't think of a reason why the transcript creation needs to be split across the functions, but please let me know if there is. I hope you don't mind me submitting these pull requests! I've been trying to write a toy OPAQUE client extending this, but coudn't work out how to get `pkS` to give to `generate_ke1` without sending it separately to all the messages described in the document - after this change, I won't need it.",
      "createdAt": "2022-01-23T18:34:02Z",
      "updatedAt": "2022-02-02T17:00:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2bd872eec80d1644542f6a6677b07bb45986ad50",
      "headRepository": "jamesw1892/OPAQUE",
      "headRefName": "patch-3",
      "headRefOid": "43cd0f99327e87b7a4e4a40547c6197c78bcc949",
      "closedAt": "2022-02-02T14:13:32Z",
      "mergedAt": "2022-02-02T14:13:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "956ad1eb191f7c6395f0cef51997237848677541"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @jamesw1892,\r\n\r\nThe transcript hashing is split because (I think) it allows to implicitly keep the arguments in the running hash, instead of carrying the state outside the function. It's not actually hashing, just adding input to the buffer.\r\n\r\nAs you correctly identified, this behaviour is not described in the document, and rightfully so: the source of truth of the protocol specification is the document, and the client doesn't have access to some of these inputs.\r\nThe reference Python/Sage implementation is primarily there to provide proof-of-concept and generate test vectors, and so takes some liberties in its inner workings. On the other hand, our Go and Rust implementations hash the transcript in KE3 only.\r\n\r\nCould you open an issue first, next time you have questions or suggestions? So we can discuss it there before diving into PRs :)\r\n\r\nNevertheless, I think your point is valid, the POC should reflect the spec more closely, be it only to avoid confusion for implementers. ",
          "createdAt": "2022-01-24T17:41:04Z",
          "updatedAt": "2022-01-24T17:41:04Z"
        },
        {
          "author": "jamesw1892",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @bytemare \n\nThank you for looking at it, understood. I will certainly submit an issue next time. Would you like me to convert this into an issue too?",
          "createdAt": "2022-01-24T17:54:01Z",
          "updatedAt": "2022-01-24T17:54:01Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "No, it's ok :)\n\nLet's wait to see if @chris-wood and @kevinlewi have an opinion on this ",
          "createdAt": "2022-01-24T18:06:42Z",
          "updatedAt": "2022-01-24T18:06:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with PRs with out issues! And I think the intuition to treat the reference implementation as an extension of the spec is good. (We can probably go _further_ and make sure things are aligned.) ",
          "createdAt": "2022-02-02T14:11:15Z",
          "updatedAt": "2022-02-02T14:11:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4z5EOp",
          "commit": {
            "abbreviatedOid": "43cd0f9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T14:13:27Z",
          "updatedAt": "2022-02-02T14:13:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 320,
      "id": "PR_kwDOD79ejs4xd4jL",
      "title": "fixed server_secret, it is correctly/consistently called server_priva\u2026",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/320",
      "state": "MERGED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "\u2026te_keyshare instead",
      "createdAt": "2022-01-24T02:16:14Z",
      "updatedAt": "2022-02-02T14:06:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2bd872eec80d1644542f6a6677b07bb45986ad50",
      "headRepository": null,
      "headRefName": "fix-server-priv-keyshare",
      "headRefOid": "a16fa30a2fc15ac25ae6c0a1e094b0443ec77e97",
      "closedAt": "2022-02-02T14:06:33Z",
      "mergedAt": "2022-02-02T14:06:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b54768388d089c444759ada7afd85190c7e09778"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4zVlB0",
          "commit": {
            "abbreviatedOid": "64603b8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-24T17:26:29Z",
          "updatedAt": "2022-01-24T17:26:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4z5B6V",
          "commit": {
            "abbreviatedOid": "a16fa30"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T14:06:25Z",
          "updatedAt": "2022-02-02T14:06:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 322,
      "id": "PR_kwDOD79ejs4xjM96",
      "title": "Updating submodules in poc",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/322",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-25T10:36:19Z",
      "updatedAt": "2022-02-02T14:14:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2bd872eec80d1644542f6a6677b07bb45986ad50",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "updating_submodules",
      "headRefOid": "9ab6206d2f8a6bf7b23913a4d381633f8d67b69c",
      "closedAt": "2022-02-02T14:14:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm on it \ud83d\udc4d ",
          "createdAt": "2022-01-25T22:08:57Z",
          "updatedAt": "2022-01-25T22:08:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4zbvwQ",
          "commit": {
            "abbreviatedOid": "9ab6206"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T21:58:19Z",
          "updatedAt": "2022-01-25T21:58:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs4zbx3l",
          "commit": {
            "abbreviatedOid": "9ab6206"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "If we merge this PR as is, it will break the vectors. We should adapt to the OPRF update first",
          "createdAt": "2022-01-25T22:08:32Z",
          "updatedAt": "2022-01-25T22:08:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 325,
      "id": "PR_kwDOD79ejs4x_BhU",
      "title": "Replace MHF with key stretching function",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/325",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #308.",
      "createdAt": "2022-02-02T18:49:25Z",
      "updatedAt": "2022-02-03T14:14:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "98ef20634d53b1fade55135c2eee6485abb29306",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/mhf-to-key-stretch",
      "headRefOid": "529ddf346b3ed74eb1e46989a70e8bdb25c3b849",
      "closedAt": "2022-02-03T14:14:21Z",
      "mergedAt": "2022-02-03T14:14:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5932199c23a6e92c02fa48f18c73cc9527f57e71"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4z-AU0",
          "commit": {
            "abbreviatedOid": "529ddf3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T14:10:09Z",
          "updatedAt": "2022-02-03T14:10:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 326,
      "id": "PR_kwDOD79ejs4x_DNx",
      "title": "Masking as enumeration prevention",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/326",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #305.",
      "createdAt": "2022-02-02T18:56:35Z",
      "updatedAt": "2022-02-03T22:24:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5932199c23a6e92c02fa48f18c73cc9527f57e71",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/masking-as-enumeration-prevention",
      "headRefOid": "12eb19459932b279c5551691371747de79f219d6",
      "closedAt": "2022-02-03T22:24:16Z",
      "mergedAt": "2022-02-03T22:24:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7e17b61a80a094c30ace9c0d865114ac3932f9f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40AQSt",
          "commit": {
            "abbreviatedOid": "12eb194"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T22:23:51Z",
          "updatedAt": "2022-02-03T22:23:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 327,
      "id": "PR_kwDOD79ejs4x_For",
      "title": "Promote enumeration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/327",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #253.\r\n\r\ncc @hugokraw for awareness",
      "createdAt": "2022-02-02T19:15:29Z",
      "updatedAt": "2022-02-03T17:17:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5932199c23a6e92c02fa48f18c73cc9527f57e71",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/promote-enumeration",
      "headRefOid": "d83e3bc110418781baba78331304271eecc8ba26",
      "closedAt": "2022-02-03T17:17:03Z",
      "mergedAt": "2022-02-03T17:17:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0f51555627552e6168dd1c63c6eed54173b2cdac"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Two nits regarding terminology (just looking at this pull request changes):\r\n- The term \"offline registration\" seems to indicate that it is different than \"online registration\" - in actuality, in most case registration is \"online\".\r\n- \"interacting with the server to enumerate clients registered via the first phase\": I wonder how many people understand this use of the term \"enumerate\" - the attack is indeed called \"enumeration attack\" but the use of \"enumerate\" in seemingly non-technical English may not be obvious.",
          "createdAt": "2022-02-03T02:54:00Z",
          "updatedAt": "2022-02-03T02:54:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The term \"offline registration\" seems to indicate that it is different than \"online registration\" - in actuality, in most case registration is \"online\".\r\n\r\nThis was made to align terminology elsewhere in the draft. If we want to drop the \"offline\" and \"online\" distinction, we can do so in a followup PR.\r\n\r\n",
          "createdAt": "2022-02-03T14:16:52Z",
          "updatedAt": "2022-02-03T14:16:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> \"interacting with the server to enumerate clients registered via the first phase\": I wonder how many people understand this use of the term \"enumerate\" - the attack is indeed called \"enumeration attack\" but the use of \"enumerate\" in seemingly non-technical English may not be obvious.\r\n\r\nThis is a fair point. I updated the text to explain what enumeration is before using that term.",
          "createdAt": "2022-02-03T14:19:41Z",
          "updatedAt": "2022-02-03T14:19:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4z-0Hd",
          "commit": {
            "abbreviatedOid": "d83e3bc"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T16:34:14Z",
          "updatedAt": "2022-02-03T16:34:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 329,
      "id": "PR_kwDOD79ejs4x_pH_",
      "title": "Use the OPRF DeriveKeyPair function and update OPRF usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/329",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change uses the DeriveKeyPair function from the OPRF spec for both the OPRF key generation and authentication key generation. It also adds serialization steps to the pseudocode and reference implementation, as that is no longer handled by the OPRF API.\r\n\r\nCloses #328.\r\nCloses #241.",
      "createdAt": "2022-02-02T22:46:24Z",
      "updatedAt": "2022-02-04T15:18:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5932199c23a6e92c02fa48f18c73cc9527f57e71",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/more-voprf-alignment",
      "headRefOid": "c8ab7b3dea55445bb6ef1b98d22e4de3639ca367",
      "closedAt": "2022-02-04T15:18:54Z",
      "mergedAt": "2022-02-04T15:18:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5d18b291b1b19a004294c898cd09779a28ccecf1"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef I reverted the offending change in [eae5040](https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/329/commits/eae5040eec78f69eaf77a3e7b59900e40f1899ef). Thanks for pressing on this!",
          "createdAt": "2022-02-03T00:51:15Z",
          "updatedAt": "2022-02-03T00:51:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef are you able to verify the test vectors in this PR?",
          "createdAt": "2022-02-03T21:34:11Z",
          "updatedAt": "2022-02-03T21:34:11Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "with pleasure!",
          "createdAt": "2022-02-03T21:37:55Z",
          "updatedAt": "2022-02-03T21:37:55Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2022-02-03T21:43:06Z",
          "updatedAt": "2022-02-03T21:43:06Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this close #298 ?",
          "createdAt": "2022-02-03T22:07:31Z",
          "updatedAt": "2022-02-03T22:07:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Does this close #298 ?\r\n\r\nI don't think so. I'll address those in a followup change.",
          "createdAt": "2022-02-04T00:19:45Z",
          "updatedAt": "2022-02-04T00:19:45Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i checked, and updated my implementation. lgtm.",
          "createdAt": "2022-02-04T15:18:13Z",
          "updatedAt": "2022-02-04T15:18:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent! Merging.",
          "createdAt": "2022-02-04T15:18:50Z",
          "updatedAt": "2022-02-04T15:18:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4z-0h-",
          "commit": {
            "abbreviatedOid": "eae5040"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T16:35:28Z",
          "updatedAt": "2022-02-03T16:35:29Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "what does that do?",
              "createdAt": "2022-02-03T16:35:28Z",
              "updatedAt": "2022-02-03T16:35:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40AEjt",
          "commit": {
            "abbreviatedOid": "eae5040"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T21:28:55Z",
          "updatedAt": "2022-02-03T21:28:55Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "It fixes the deterministic test vector issue @stef pointed out. I'll address this (by removing it) in a future change that _does not_ make any protocol changes.",
              "createdAt": "2022-02-03T21:28:55Z",
              "updatedAt": "2022-02-03T21:28:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40ADKl",
          "commit": {
            "abbreviatedOid": "eae5040"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-02-03T21:23:50Z",
          "updatedAt": "2022-02-03T21:29:47Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "```suggestion\r\n  (oprf_key, _) = DeriveKeyPair(seed, \"OPAQUE-DeriveKeyPair\")\r\n```",
              "createdAt": "2022-02-03T21:23:50Z",
              "updatedAt": "2022-02-03T21:29:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40AFCE",
          "commit": {
            "abbreviatedOid": "eae5040"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-02-03T21:30:58Z",
          "updatedAt": "2022-02-03T21:31:14Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "```suggestion\r\n  (oprf_key, _) = DeriveKeyPair(seed, \"OPAQUE-DeriveKeyPair\")\r\n```",
              "createdAt": "2022-02-03T21:30:58Z",
              "updatedAt": "2022-02-03T21:31:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40AFwN",
          "commit": {
            "abbreviatedOid": "c8ab7b3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T21:34:16Z",
          "updatedAt": "2022-02-03T21:34:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 330,
      "id": "PR_kwDOD79ejs4x_wcE",
      "title": "Drop TripleDHIKM and inline the function instead",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/330",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #321.",
      "createdAt": "2022-02-02T23:40:17Z",
      "updatedAt": "2022-02-03T15:50:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5932199c23a6e92c02fa48f18c73cc9527f57e71",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/drop-tripledh",
      "headRefOid": "06367f151dca6ec12cd4d50e21556303e5b55f51",
      "closedAt": "2022-02-03T15:50:45Z",
      "mergedAt": "2022-02-03T15:50:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a79392fd622910fa5b47727602a147e389743ecc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4z-knp",
          "commit": {
            "abbreviatedOid": "06367f1"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T15:49:52Z",
          "updatedAt": "2022-02-03T15:49:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 331,
      "id": "PR_kwDOD79ejs4yByW8",
      "title": "Add more justification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/331",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This also sharpens the requirement for the MAC, stating that it must be collision resistant. (We missed this before.)\r\n\r\ncc @hugokraw ",
      "createdAt": "2022-02-03T13:59:16Z",
      "updatedAt": "2022-02-04T20:16:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5932199c23a6e92c02fa48f18c73cc9527f57e71",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/add-more-justification",
      "headRefOid": "310920338e1d831835bfe5bd9ac19d9b25797976",
      "closedAt": "2022-02-04T20:16:53Z",
      "mergedAt": "2022-02-04T20:16:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8c8002be55e5bdb17c9ae7be96e1be2d649c3b8a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs4z-p4E",
          "commit": {
            "abbreviatedOid": "350fad8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-02-03T16:04:23Z",
          "updatedAt": "2022-02-03T16:06:41Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "```suggestion\r\n  is a security (or privacy) risk.\r\n```",
              "createdAt": "2022-02-03T16:04:23Z",
              "updatedAt": "2022-02-03T16:06:41Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\n  enumeration is a security (or privacy) risk.\r\n```",
              "createdAt": "2022-02-03T16:04:53Z",
              "updatedAt": "2022-02-03T16:06:41Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n  has no influence in the security analysis (it can be simulated with a\r\n```",
              "createdAt": "2022-02-03T16:05:49Z",
              "updatedAt": "2022-02-03T16:06:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs4z-z27",
          "commit": {
            "abbreviatedOid": "2cb4773"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T16:33:27Z",
          "updatedAt": "2022-02-03T16:33:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs40EKOC",
          "commit": {
            "abbreviatedOid": "ce70c87"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T19:41:43Z",
          "updatedAt": "2022-02-04T20:06:58Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "We should post the paper (sent a message to the co-authors) and in any case mention it by name even if not posted (it provides some credibility)",
              "createdAt": "2022-02-04T19:41:43Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 87,
              "body": "would \"generate authentication keys during registration be better?",
              "createdAt": "2022-02-04T19:43:08Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 95,
              "body": "Change \"This extension does not add to\" to \"This extension is not needed for\"\r\nChange \"this key can be simulated\" to \"the masking key\"",
              "createdAt": "2022-02-04T19:45:33Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 96,
              "body": "I would replace 'seed' with 'PRF seed'",
              "createdAt": "2022-02-04T19:46:37Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 118,
              "body": "Change \"an additional identity alongside public authentication keys\"  to \"additional identities alongside their corresponding public authentication keys\"",
              "createdAt": "2022-02-04T19:50:13Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 132,
              "body": "I assume you meant 'via a single PRF' (twice above)",
              "createdAt": "2022-02-04T19:53:07Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 43,
              "body": "We may consider leaving this section in the RFC. It is a very useful list of rationales for design/spec choices (we should remove irrelevant explanations as the \"historical references\" to the draft-krawczyk and other Fang-Hao-motivated comments)",
              "createdAt": "2022-02-04T19:55:12Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 149,
              "body": "Change \"was left undefined\" with \"was not instantiated\"",
              "createdAt": "2022-02-04T19:57:58Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 160,
              "body": "change 'as described in {{security-analysis}}' with 'as recalled in {{security-analysis}}'",
              "createdAt": "2022-02-04T20:00:11Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 161,
              "body": "Change 'has not effect on\" to \"preserves\"",
              "createdAt": "2022-02-04T20:01:05Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            },
            {
              "originalPosition": 169,
              "body": "Replace 'rectifies' with 'fills'\r\n(I was very explicit about these essential details not being in scope in my i-d, so I object to 'rectify' :-)",
              "createdAt": "2022-02-04T20:03:41Z",
              "updatedAt": "2022-02-04T20:06:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40EQUt",
          "commit": {
            "abbreviatedOid": "ce70c87"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T20:08:30Z",
          "updatedAt": "2022-02-04T20:08:30Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Hah, fair :) ",
              "createdAt": "2022-02-04T20:08:30Z",
              "updatedAt": "2022-02-04T20:08:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 332,
      "id": "PR_kwDOD79ejs4yDQMU",
      "title": "added libopaque to implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/332",
      "state": "MERGED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "conforms to testvectors before the voprf09 update. proof:\r\nhttps://github.com/stef/libopaque/blob/master/src/tests/opaque-testvectors.c\r\n\r\nhas one deviation, did not implement the voprf evaluate function in anticipation of it going back to the original oprf variant. hence the output for that is hardcoded, but will be removed with the vporf09 update.",
      "createdAt": "2022-02-03T21:19:43Z",
      "updatedAt": "2022-02-04T15:19:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0f51555627552e6168dd1c63c6eed54173b2cdac",
      "headRepository": null,
      "headRefName": "add-libopaque-to-impls",
      "headRefOid": "ea13465b9ce2d17602b036896255cdb02380bc8a",
      "closedAt": "2022-02-04T15:19:12Z",
      "mergedAt": "2022-02-04T15:19:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "739e90ac495cb34c671de4bbfe0838a0b3b871f4"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Awesome! Should we hold this while #329 is ironed out?",
          "createdAt": "2022-02-03T21:25:19Z",
          "updatedAt": "2022-02-03T21:25:19Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i adapted to the changes in #329 and conform: https://github.com/stef/libopaque/commit/9d4aed3e65cb987527ef7298f366bf30fdd158a2",
          "createdAt": "2022-02-04T15:18:44Z",
          "updatedAt": "2022-02-04T15:18:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Lovely :) Merging this as well!",
          "createdAt": "2022-02-04T15:19:09Z",
          "updatedAt": "2022-02-04T15:19:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 333,
      "id": "PR_kwDOD79ejs4yHuks",
      "title": "Refactor error and implementation considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/333",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change refactors the error and implementation considerations as presented in #314, and also leaves a slot for us to address #312 in a followup change.",
      "createdAt": "2022-02-05T15:42:28Z",
      "updatedAt": "2022-02-07T15:29:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "dbz/document-errors",
      "baseRefOid": "dd8fd1585e1c60cb6182bb3f8f47939eb993afa5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/refactor-errors",
      "headRefOid": "a9c04b2de65833e9b938072706ffdd5ffd414ef9",
      "closedAt": "2022-02-07T15:29:22Z",
      "mergedAt": "2022-02-07T15:29:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ecff9cab67e5f3357264aa4dc118e3af06f3c6d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40GiWW",
          "commit": {
            "abbreviatedOid": "47fb65b"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T01:57:34Z",
          "updatedAt": "2022-02-07T01:57:35Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I thought we agreed on your suggestion here\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/pull/314#discussion_r798821465",
              "createdAt": "2022-02-07T01:57:34Z",
              "updatedAt": "2022-02-07T01:57:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40GijS",
          "commit": {
            "abbreviatedOid": "47fb65b"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T02:00:10Z",
          "updatedAt": "2022-02-07T02:00:11Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "```suggestion\r\nauthenticated key exchange protocol may fail because the client's password was\r\n```",
              "createdAt": "2022-02-07T02:00:10Z",
              "updatedAt": "2022-02-07T02:00:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40GjwO",
          "commit": {
            "abbreviatedOid": "47fb65b"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T02:15:56Z",
          "updatedAt": "2022-02-07T02:15:56Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I think we should also mention implicit errors originating from VOPRF (e.g. InvalidInputError) and hash-to-curve (if any)",
              "createdAt": "2022-02-07T02:15:56Z",
              "updatedAt": "2022-02-07T02:15:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40Gk-o",
          "commit": {
            "abbreviatedOid": "47fb65b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T02:31:04Z",
          "updatedAt": "2022-02-07T02:31:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Upon rereading things and making this PR I fell back to my original suggestion. I don't think it's important that the application know it's the MAC that failed here, and it's only guidance anyway. (An implementation could choose to be more specific.)",
              "createdAt": "2022-02-07T02:31:04Z",
              "updatedAt": "2022-02-07T02:31:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40GlGS",
          "commit": {
            "abbreviatedOid": "a9c04b2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T02:32:29Z",
          "updatedAt": "2022-02-07T02:32:29Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "`DeserializeElement` is one of those implicit OPRF errors. I don't think we need to be exhaustive with the list of implicit things here.\r\n\r\nI plan to address InvalidInputError and how OPAQUE should deal with it in response to #312.",
              "createdAt": "2022-02-07T02:32:29Z",
              "updatedAt": "2022-02-07T02:32:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs40JSlB",
          "commit": {
            "abbreviatedOid": "a9c04b2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T15:28:15Z",
          "updatedAt": "2022-02-07T15:28:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "PR_kwDOD79ejs4yLfUD",
      "title": "Remove RecoverPublicKey",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/335",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This wasn't used anywhere in the spec, so let's remove it.",
      "createdAt": "2022-02-07T15:37:04Z",
      "updatedAt": "2022-02-07T23:41:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "245c42218e2a0f57fec8763f49b2bd4bd4b6a0d3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/recover-public-key",
      "headRefOid": "b5d9782c828bb11887f6dfcf7b71f2f7af00227b",
      "closedAt": "2022-02-07T23:41:36Z",
      "mergedAt": "2022-02-07T23:41:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "46393f322137f94d95a6fd1cfa3b7eff7b0cf6f0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40K83y",
          "commit": {
            "abbreviatedOid": "b5d9782"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T21:49:34Z",
          "updatedAt": "2022-02-07T21:49:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 338,
      "id": "PR_kwDOD79ejs4yjOHd",
      "title": "Correct `oprf_seed` length in POC test",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/338",
      "state": "MERGED",
      "author": "jamesw1892",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An `oprf_seed` is generated 3 times in `test_opaque_ake.sage`. The other two times, the correct length, `Nh` (hash digest size), is used, but here, `Nok` (OPRF private key size) was used instead.\r\n\r\nIn `default_opaque_configuration`, these are different so it does make a difference.\r\n\r\nThe draft states it should be `Nh`, e.g.: in this paragraph: https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-07.html#section-5-1",
      "createdAt": "2022-02-11T21:33:12Z",
      "updatedAt": "2022-02-13T22:03:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "883b58490320b8d6728185ae3cb360bd73aa0a5c",
      "headRepository": "jamesw1892/OPAQUE",
      "headRefName": "patch-1",
      "headRefOid": "ebebf8b106fcd008b3c820baa73dfca1e7dd8721",
      "closedAt": "2022-02-12T15:52:52Z",
      "mergedAt": "2022-02-12T15:52:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "12ac66a0c352e6195900fa9cb79ddc6e3c41726f"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i suppose this change also affects all test vectors for this test-case, so these need to be adjusted as well?",
          "createdAt": "2022-02-11T21:39:43Z",
          "updatedAt": "2022-02-11T21:39:43Z"
        },
        {
          "author": "jamesw1892",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> i suppose this change also affects all test vectors for this test-case, so these need to be adjusted as well?\r\n\r\nYes it does, thank you for spotting!",
          "createdAt": "2022-02-11T21:44:28Z",
          "updatedAt": "2022-02-11T21:44:28Z"
        },
        {
          "author": "jamesw1892",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Thanks! Can you please also copy these updated vectors (in `poc/vectors/formatted.txt`) into the main specification file? If it's easier for you, I can do that in a followup change.\r\n\r\n@chris-wood Done, I didn't realise they needed to be updated there too.",
          "createdAt": "2022-02-12T15:52:02Z",
          "updatedAt": "2022-02-12T15:52:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No problem =) By the way, @jamesw1892, are you working on an implementation? If so, can I encourage you to add it to our [list of implementations](https://github.com/cfrg/draft-irtf-cfrg-opaque#implementations)?",
          "createdAt": "2022-02-12T15:53:38Z",
          "updatedAt": "2022-02-12T15:53:38Z"
        },
        {
          "author": "jamesw1892",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> No problem =) By the way, @jamesw1892, are you working on an implementation? If so, can I encourage you to add it to our [list of implementations](https://github.com/cfrg/draft-irtf-cfrg-opaque#implementations)?\r\n\r\n@chris-wood I'm not sure if you would class it as an implementation. It's just an extension of this reference implementation to a client and server program to make it clear what needs to be done by each party. It doesn't re-write functionality in the reference implementation. You can see it here if interested: https://github.com/jamesw1892/OPAQUE/tree/master/poc#extended-opaque-proof-of-concept",
          "createdAt": "2022-02-12T16:00:33Z",
          "updatedAt": "2022-02-12T18:14:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@jamesw1892 @stef FYI when I generate test vectors based on this branch locally I get results that differ from what's been merged. @jamesw1892 is it possible your submodule references were behind? (I'll fix this in a new PR.)",
          "createdAt": "2022-02-13T21:51:05Z",
          "updatedAt": "2022-02-13T21:51:05Z"
        },
        {
          "author": "jamesw1892",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I'm not sure what has caused it, but if you get different test vectors, definitely go with what you get. I thought my submodules were up to date but am fairly new to submodules. I generated the test vectors from my OPAQUE repo where I have made other changes, but I don't think I have made changes specifically to any code used to generate the test vectors.",
          "createdAt": "2022-02-13T22:03:33Z",
          "updatedAt": "2022-02-13T22:03:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40gPH5",
          "commit": {
            "abbreviatedOid": "f90a96e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! Can you please also copy these updated vectors (in `poc/vectors/formatted.txt`) into the main specification file? If it's easier for you, I can do that in a followup change.",
          "createdAt": "2022-02-12T15:36:45Z",
          "updatedAt": "2022-02-12T15:37:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "PR_kwDOD79ejs4ynG3W",
      "title": "Remove lingering MHF references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/339",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These were missed previously. I'll update the test vector labels in a followup change.",
      "createdAt": "2022-02-12T15:35:09Z",
      "updatedAt": "2022-02-13T21:34:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "883b58490320b8d6728185ae3cb360bd73aa0a5c",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "more-mhf-trim",
      "headRefOid": "c32a2cb262d86496ecad516a9ae15413a810721d",
      "closedAt": "2022-02-13T21:34:35Z",
      "mergedAt": "2022-02-13T21:34:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "99b6b24b46411a5269a8ca1b8c2cf1c3360b3dfa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40g6fm",
          "commit": {
            "abbreviatedOid": "c32a2cb"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-13T21:01:47Z",
          "updatedAt": "2022-02-13T21:01:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 340,
      "id": "PR_kwDOD79ejs4yvj11",
      "title": "MHF to KSF throughout",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/340",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And fix an issue with the generated vectors in #338. And update to the latest voprf submodule while we're at it.\r\n\r\ncc @stef, @jamesw1892 ",
      "createdAt": "2022-02-13T21:56:22Z",
      "updatedAt": "2022-02-14T18:37:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "99b6b24b46411a5269a8ca1b8c2cf1c3360b3dfa",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ksf-in-code",
      "headRefOid": "eb699ddfb91f64ea90c9ed5463b0e7fa1e619acc",
      "closedAt": "2022-02-14T14:19:42Z",
      "mergedAt": "2022-02-14T14:19:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c2c452e9caf69321cfd4ae4ef288b57b821f6d16"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'll have a look later tonight.",
          "createdAt": "2022-02-14T14:31:59Z",
          "updatedAt": "2022-02-14T14:31:59Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'm confused what exactly caused the change of the testvectors? as far as i see @jamesw1892 change f90a96e60d681c0f888d0bb93558b898376ff69d only affected: https://github.com/jamesw1892/OPAQUE/blob/ebebf8b106fcd008b3c820baa73dfca1e7dd8721/poc/test_opaque_ake.sage#L94 which should not affect the very first set of test vectors, since not even the pwdU (iloveopaque) matches in that function with the pwdU in the first testvector (batteryhorsestaple...) i looked at this PR but couldn't find why the test vectors changed. i also looked here, maybe the VOPRF changed in any way, but even here https://github.com/cfrg/draft-irtf-cfrg-voprf/compare/f1f8e0fb1f1d1eceb6cd40875240289b514c1674...015e34156e33daf1d75b693064952aed0f694f20 i couldn't find anything. would you please point out what changed, where and why? it would also be great in the future to mark commits that change the test vectors so that it is easier to find out why.",
          "createdAt": "2022-02-14T17:33:20Z",
          "updatedAt": "2022-02-14T17:33:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think their test vectors were run with an older version of the VOPRF repository. I ran them with the updated version. \r\n\r\n> On Feb 14, 2022, at 9:33 AM, Stefan Marsiske ***@***.***> wrote:\r\n> \r\n> \r\n> i'm confused what exactly caused the change of the testvectors? as far as i see @jamesw1892 change f90a96e only affected: https://github.com/jamesw1892/OPAQUE/blob/ebebf8b106fcd008b3c820baa73dfca1e7dd8721/poc/test_opaque_ake.sage#L94 which should not affect the very first set of test vectors, since not even the pwdU (iloveopaque) matches in that function with the pwdU in the first testvector (batteryhorsestaple...) i looked at this PR but couldn't find why the test vectors changed. i also looked here, maybe the VOPRF changed in any way, but even here ***@***.*** i couldn't find anything. would you please point out what changed, where and why? it would also be great in the future to mark commits that change the test vectors so that it is easier to find out why.\r\n> \r\n> \u2014\r\n> Reply to this email directly, view it on GitHub, or unsubscribe.\r\n> You are receiving this because you modified the open/close state.\r\n> \r\n\r\n",
          "createdAt": "2022-02-14T17:34:18Z",
          "updatedAt": "2022-02-14T17:34:27Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, but why did the testvectors change since the last time? i'm looking at this: https://github.com/cfrg/draft-irtf-cfrg-opaque/commits/eb699ddfb91f64ea90c9ed5463b0e7fa1e619acc/poc/vectors/vectors.json - and in this list my impl is conforming to eae5040eec78f69eaf77a3e7b59900e40f1899ef, after that there is only jamesw1892 change, and the change from this PR here. i when i run compare between these commits i get this: https://github.com/cfrg/draft-irtf-cfrg-opaque/compare/eae5040eec78f69eaf77a3e7b59900e40f1899ef..eb699ddfb91f64ea90c9ed5463b0e7fa1e619acc i am unable to see where there is a change that mandates the change of the text vectors. maybe it's lost in the noise, please help see me what i fail to see",
          "createdAt": "2022-02-14T17:47:08Z",
          "updatedAt": "2022-02-14T17:47:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not really sure how to clarify this further for you. The oprf_seed change did change the test vectors, but it appears as though the test vectors produced in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/338 used an incorrect version of the voprf submodule since. So this PR fixed that. ",
          "createdAt": "2022-02-14T17:53:04Z",
          "updatedAt": "2022-02-14T17:53:04Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes the oprf_seed change did affect the testcase: \"test_registration_and_authentication()\" which uses \"iloveopaque\" as a pwdU, so that should leave the testvector where the password \"batteryhorse...\" alone and unaffected, and yet even there the testvectors changed.",
          "createdAt": "2022-02-14T17:56:00Z",
          "updatedAt": "2022-02-14T17:56:00Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ooooh i get it. the changed testcase is called before the testcase that i'm verifying, so that means that the random byte stream is offset... can we please just fix the random bytestream instead please?",
          "createdAt": "2022-02-14T17:57:08Z",
          "updatedAt": "2022-02-14T17:57:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. That will happen in a future change. \n\n> On Feb 14, 2022, at 9:57 AM, Stefan Marsiske ***@***.***> wrote:\n> \n> \n> ooooh i get it. the changed testcase is called before the testcase that i'm verifying, so that means that the random byte stream is offset... can we please just fix the random bytestream instead please?\n> \n> \u2014\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> You are receiving this because you modified the open/close state.\n> \n\n",
          "createdAt": "2022-02-14T17:57:56Z",
          "updatedAt": "2022-02-14T17:57:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "test vectors should never change without a good reason. please?",
          "createdAt": "2022-02-14T17:57:57Z",
          "updatedAt": "2022-02-14T17:57:57Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this causes a lot of extra and unnecessary work for implementers.",
          "createdAt": "2022-02-14T17:59:42Z",
          "updatedAt": "2022-02-14T17:59:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That\u2019s a fine ideal, but we\u2019ve never actually made that commitment. As I said, we will do our best to see that this is done. Patience, please.\n\n> On Feb 14, 2022, at 9:58 AM, Stefan Marsiske ***@***.***> wrote:\n> \n> \n> test vectors should never change without a good reason. please?\n> \n> \u2014\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> You are receiving this because you modified the open/close state.\n> \n\n",
          "createdAt": "2022-02-14T17:59:55Z",
          "updatedAt": "2022-02-14T17:59:55Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hrmpf i see, Nh > Nok, so there is no easy fix. well, the cheapest fix would be to just use the famous debian rng...",
          "createdAt": "2022-02-14T18:11:06Z",
          "updatedAt": "2022-02-14T18:11:06Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the cleanest would be of course if the poc would read the input values from the testvectors itself.",
          "createdAt": "2022-02-14T18:27:45Z",
          "updatedAt": "2022-02-14T18:27:45Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "in the short-run i think the cheapest would be to just read Nok bytes from the rng to restore the stream, and use that value twice so it gets the expected NH length.",
          "createdAt": "2022-02-14T18:37:27Z",
          "updatedAt": "2022-02-14T18:37:27Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i mean in jamesw1892 one line fix.",
          "createdAt": "2022-02-14T18:37:47Z",
          "updatedAt": "2022-02-14T18:37:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40hF9s",
          "commit": {
            "abbreviatedOid": "eb699dd"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Checked :) lgtm",
          "createdAt": "2022-02-14T01:48:06Z",
          "updatedAt": "2022-02-14T01:48:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 342,
      "id": "PR_kwDOD79ejs4yz3WC",
      "title": "fix deviation of the test-vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/342",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "see discussion in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/340",
      "createdAt": "2022-02-14T19:54:38Z",
      "updatedAt": "2022-02-20T18:00:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "c2c452e9caf69321cfd4ae4ef288b57b821f6d16",
      "headRepository": null,
      "headRefName": "stef/fix-test-vecs",
      "headRefOid": "f06dc69633e062af246b590ad80c8c7fd0871d6b",
      "closedAt": "2022-02-20T18:00:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "it seems to fix the testvectors compared to the last change of them: https://github.com/cfrg/draft-irtf-cfrg-opaque/compare/eae5040eec78f69eaf77a3e7b59900e40f1899ef...stef:stef/fix-test-vecs",
          "createdAt": "2022-02-14T19:59:58Z",
          "updatedAt": "2022-02-14T19:59:58Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i agree, it's not the right fix for the generic problem. but it is a quick and dirty fix for the last instantiation of it.",
          "createdAt": "2022-02-15T21:25:13Z",
          "updatedAt": "2022-02-15T21:25:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40q4Y2",
          "commit": {
            "abbreviatedOid": "f06dc69"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the addition, but this isn't the right fix to the problem. We need to change how randomness is plumbed into the protocol participants, and I'll do that soon!",
          "createdAt": "2022-02-15T21:13:14Z",
          "updatedAt": "2022-02-15T21:13:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 343,
      "id": "PR_kwDOD79ejs4y1s-E",
      "title": "Add opaque-ts TypeScript library.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/343",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A TypeScript implementation can be found at https://github.com/cloudflare/opaque-ts\r\nwhich is complaint with published [draft-irtf-cfrg-opaque-07](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-opaque-07).",
      "createdAt": "2022-02-15T07:58:14Z",
      "updatedAt": "2022-02-15T21:13:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "c2c452e9caf69321cfd4ae4ef288b57b821f6d16",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "addTSLibrary",
      "headRefOid": "aebdae7d65e8aaeac38f75c8bb18c5acb1814094",
      "closedAt": "2022-02-15T21:13:44Z",
      "mergedAt": "2022-02-15T21:13:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "160b19931b97308c4d571269de95ba6167f1b7f2"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! \ud83c\udf89 ",
          "createdAt": "2022-02-15T21:13:37Z",
          "updatedAt": "2022-02-15T21:13:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs40q4dL",
          "commit": {
            "abbreviatedOid": "aebdae7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-15T21:13:31Z",
          "updatedAt": "2022-02-15T21:13:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 344,
      "id": "PR_kwDOD79ejs4y8tYI",
      "title": "Plumb fixed randomness into each test vector.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/344",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change ensures that each test vector is run with the same fixed seed that is used to initialize a randomness seed that's distinct for each client and server. (Client and server share the same randomness during registration, but we can easily change that if desired.) We can also use a different seed for each test vector if desired.\r\n\r\ncc @stef, @armfazh ",
      "createdAt": "2022-02-16T19:53:23Z",
      "updatedAt": "2022-03-07T15:36:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "160b19931b97308c4d571269de95ba6167f1b7f2",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fix-test-vector-randomness",
      "headRefOid": "c8f858d015836ea555543611fa845fe128264653",
      "closedAt": "2022-03-07T15:36:52Z",
      "mergedAt": "2022-03-07T15:36:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "661eff66d932255195802ff3dca6ba40edb12f19"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I ran `make vectors` and obtained the same test vectors. My only suggestion is to add a readme.md with compilation instructions.",
          "createdAt": "2022-02-16T20:19:15Z",
          "updatedAt": "2022-02-16T20:20:52Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "awesome! however there is still a problem if within a testcase the size/order/number of inputs changes. that will also throw of the rng output. i understand that it's difficult to hardcode the input vectors especially in the submodules of voprf and h2c. but then, that's exactly what we implementers also do in our code where we verify the testvectors.",
          "createdAt": "2022-02-16T21:45:21Z",
          "updatedAt": "2022-02-16T21:45:21Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'm gonna check this tomorrow.\r\n",
          "createdAt": "2022-02-16T22:00:55Z",
          "updatedAt": "2022-02-16T22:00:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> awesome! however there is still a problem if within a testcase the size/order/number of inputs changes. that will also throw of the rng output. i understand that it's difficult to hardcode the input vectors especially in the submodules of voprf and h2c. but then, that's exactly what we implementers also do in our code where we verify the testvectors.\r\n\r\nYeah, I'm open to suggestions to hear how we might improve this using the new plumbing. @stef, when you have a moment, can you point me to your tests that you wrote?",
          "createdAt": "2022-02-16T22:31:33Z",
          "updatedAt": "2022-02-16T22:31:33Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sure, here is my test code: https://github.com/stef/libopaque/blob/master/src/tests/opaque-testvectors.c - and in my opaque implementation https://github.com/stef/libopaque/blob/master/src/opaque.c i have all over the place ifdefed code like this:\r\n```\r\n#ifdef CFRG_TEST_VEC\r\n  // \"oprf_key\": \"3dc1f2c5212510244924ab97b10c19f8b0f0d9444295de5e7d2c9b9f8f8edf09\",\r\n  unsigned char rtest[] = {\r\n       0x3d, 0xc1, 0xf2, 0xc5, 0x21, 0x25, 0x10, 0x24,\r\n       0x49, 0x24, 0xab, 0x97, 0xb1, 0x0c, 0x19, 0xf8,\r\n       0xb0, 0xf0, 0xd9, 0x44, 0x42, 0x95, 0xde, 0x5e,\r\n       0x7d, 0x2c, 0x9b, 0x9f, 0x8f, 0x8e, 0xdf, 0x09\r\n  };\r\n  unsigned int rtest_len = 32;\r\n  memcpy(kU,rtest,rtest_len);\r\n#else\r\n  crypto_core_ristretto255_scalar_random(kU);\r\n#endif\r\n```\r\n\r\nyou can imagine how much effort it is to always update the testvectors when them change...",
          "createdAt": "2022-02-16T22:37:58Z",
          "updatedAt": "2022-02-16T22:37:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Are you open to PRs against that repo to try and make this a bit easier and more automated?",
          "createdAt": "2022-02-16T22:39:15Z",
          "updatedAt": "2022-02-16T22:39:15Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sure, but this affects at least also aldens ecc implemenation, cannot imagine that the others do not suffer also from similar problems, but i haven't looked at the other impls...",
          "createdAt": "2022-02-16T22:42:30Z",
          "updatedAt": "2022-02-16T22:42:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> sure, but this affects at least also aldens ecc implemenation, cannot imagine that the others do not suffer also from similar problems, but i haven't looked at the other impls...\r\n\r\nYep, for sure. I'm trying to figure out what's the best approach here that balances everyone's concerns. I'll hold this PR open until we get a chance to look at other implementations and how they're dealing with test vectors.",
          "createdAt": "2022-02-16T22:44:19Z",
          "updatedAt": "2022-02-16T22:44:19Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In the opaque-ke implementation, we have inner functions which are called by both the \"real implementation\" and the testing of the test vectors, for instance, when the real implementation has to sample randomness, but the test vectors already specify the randomness.\r\n\r\nThen, the test cases just parse the test vectors and call these inner functions with the corresponding arguments. Changing the test vectors is not too hard to deal with because we just dump them into this file: https://github.com/novifinancial/opaque-ke/blob/main/src/tests/opaque_vectors.rs\r\n\r\nand they get parsed and the tests are run here: https://github.com/novifinancial/opaque-ke/blob/main/src/tests/test_opaque_vectors.rs\r\n\r\nSo maybe each implementation needs to write a parser in order to keep up with the latest test vectors.",
          "createdAt": "2022-02-16T22:54:36Z",
          "updatedAt": "2022-02-16T22:54:36Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "btw is there any reason that the inputs have to be totally random? can they not be some constant? or some constants? that would make things much easier on all accounts...\r\n",
          "createdAt": "2022-02-16T22:55:34Z",
          "updatedAt": "2022-02-16T22:55:34Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "for example i have this for my own testcases:\r\n\r\n```c\r\n#ifdef NORANDOM\r\nvoid a_randombytes(void* const buf, const size_t len) {\r\n  size_t i;\r\n  for(i=0;i<len;i++) ((uint8_t*)buf)[i]=i&0xff;\r\n}\r\n````",
          "createdAt": "2022-02-16T22:58:05Z",
          "updatedAt": "2022-02-16T22:58:31Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i added a new tool to libopaque which generates a header file with the test vectors and thus makes updating them much easier: https://github.com/stef/libopaque/commit/74207f7459236c4b687bc53da4e1c1eca404d817\r\n\r\nusing this i was able to verify the testvectors in this PR.\r\n\r\nhaving said this, i think that input test vectors should only change if there is a good reason for this, either because the specification document changes and mandates this, or if there was a bug in the poc generating the test vectors, but even then the number of vectors that change should be kept to a minimum. this is useful for us to detect any errors, which would be hidden if the input vectors change.",
          "createdAt": "2022-02-17T23:59:48Z",
          "updatedAt": "2022-02-17T23:59:48Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "My approach is to use the `vectors.json` file directly. In my tests, I parse the file, load the configuration, use the input values, run the protocol for the multiple suites, and during execution I compare with the intermediate and output values. The testing calls the external API and verifies internal intermediate values (I do the same for VOPRF).\r\nHere's that code: https://github.com/bytemare/opaque/blob/main/tests/vectors_test.go\r\n\r\nIn this instance, I just had to replace the `vectors.json` file and it executed smoothly, I didn't have to change anything in my implementation or tests.",
          "createdAt": "2022-02-18T01:57:43Z",
          "updatedAt": "2022-02-18T02:02:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs402q7m",
          "commit": {
            "abbreviatedOid": "c8f858d"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T01:42:50Z",
          "updatedAt": "2022-02-18T01:42:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 349,
      "id": "PR_kwDOD79ejs41r8Ws",
      "title": "fix some artifacts",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/349",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I found some inconsistencies that needed to be addressed.",
      "createdAt": "2022-04-05T20:58:33Z",
      "updatedAt": "2022-04-11T21:38:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "661eff66d932255195802ff3dca6ba40edb12f19",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/fix-draft-artifacts",
      "headRefOid": "429240aeaf88075fc9860e62dcff56d357c29788",
      "closedAt": "2022-04-11T14:19:32Z",
      "mergedAt": "2022-04-11T14:19:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "818df0028fdc0a64f1a9e301cfc6c0b227049b3d"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare do you intend to make more changes, or is this ready for review?",
          "createdAt": "2022-04-06T16:23:18Z",
          "updatedAt": "2022-04-06T16:23:18Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood yes, sorry, it's ready for review",
          "createdAt": "2022-04-09T21:37:22Z",
          "updatedAt": "2022-04-09T21:37:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs436gpY",
          "commit": {
            "abbreviatedOid": "429240a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-11T14:19:26Z",
          "updatedAt": "2022-04-11T14:19:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 350,
      "id": "PR_kwDOD79ejs42Clb3",
      "title": "Minor editorial edits to dependencies section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/350",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Minor edits that fix grammar, keep consistent wording style, etc.",
      "createdAt": "2022-04-12T00:35:50Z",
      "updatedAt": "2022-04-15T01:55:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "818df0028fdc0a64f1a9e301cfc6c0b227049b3d",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "minor_edits_1",
      "headRefOid": "b4558323bd089429c72cc40eb9d8e89a084f1787",
      "closedAt": "2022-04-15T01:55:55Z",
      "mergedAt": "2022-04-15T01:55:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "367965e6f7d1be4dc5ecbbb8fa621f678effe4d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs439AMV",
          "commit": {
            "abbreviatedOid": "310fc23"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T00:36:47Z",
          "updatedAt": "2022-04-12T00:37:43Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I removed this second sentence because it isn't true everywhere (since we use \"OPAQUE-DeriveAuthKeyPair\" for one instance).",
              "createdAt": "2022-04-12T00:36:47Z",
              "updatedAt": "2022-04-12T00:37:43Z"
            },
            {
              "originalPosition": 26,
              "body": "This line is repeated already from 362, so I thought it appropriate to remove",
              "createdAt": "2022-04-12T00:37:22Z",
              "updatedAt": "2022-04-12T00:37:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs44Nm0R",
          "commit": {
            "abbreviatedOid": "b455832"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-15T01:55:50Z",
          "updatedAt": "2022-04-15T01:55:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 351,
      "id": "PR_kwDOD79ejs42Csj-",
      "title": "Removing key recovery mechanism from dependencies section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/351",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed offline, I think this should be kept just as a subroutine, but not a dependency, since it is not defined external to the OPAQUE protocol.",
      "createdAt": "2022-04-12T01:17:16Z",
      "updatedAt": "2022-04-17T22:30:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "818df0028fdc0a64f1a9e301cfc6c0b227049b3d",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "remove_key_recovery_dep",
      "headRefOid": "3da13c401a4a275ffa6bd598b03c96a7c4974d1f",
      "closedAt": "2022-04-17T22:30:59Z",
      "mergedAt": "2022-04-17T22:30:59Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "fa2c17dd13ddd3d4e97d32b98e84d846361d90b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs44Nm7J",
          "commit": {
            "abbreviatedOid": "3da13c4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-15T01:57:10Z",
          "updatedAt": "2022-04-15T01:57:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 352,
      "id": "PR_kwDOD79ejs42aLQ-",
      "title": "Removing AKE deps section and defining KE1/KE2/KE3 structs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/352",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed offline, this will remove the \"Authenticated Key Exchange (AKE) Protocol\" subsection from the \"Cryptographic Dependencies\" section. This also means removing the definitions of the subroutines \"AuthInit\", \"AuthResponse\", \"AuthFinish\".\r\n\r\nThis is also an opportunity to clearly define the structs KE1, KE2, and KE3 in the \"AKE Messages\" section.\r\n\r\nPartially addresses #336, but I think in order to complete #336, we should also re-order the sections in the Online AKE stage slightly, so that we aren't at any point referencing things that haven't yet been defined. This means moving the \"Credential Retrieval\" subsection up top, followed by \"AKE messages\", followed by \"Client Authentication Functions\" and \"Server Authentication Functions\". Not addressing this reordering in this PR, but will do so in a follow-up one.",
      "createdAt": "2022-04-19T09:07:25Z",
      "updatedAt": "2022-04-26T01:38:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "fa2c17dd13ddd3d4e97d32b98e84d846361d90b4",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "remove_ake_deps",
      "headRefOid": "85a79949c580574f1b3187b99808f12655b5ed53",
      "closedAt": "2022-04-26T01:38:16Z",
      "mergedAt": "2022-04-26T01:38:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3977e9ae3a911144a90271ce84cad72b6945a8a2"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This change looks good, but does it match the reference implementation?",
          "createdAt": "2022-04-20T13:54:46Z",
          "updatedAt": "2022-04-20T13:54:46Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood : These changes have no impact on the implementation, as they are purely editorial.\r\n\r\n@bytemare : Please take a look at the latest updates here. As discussed offline, I have kept the AuthInit/AuthResponse structs (renamed AuthInit to AuthRequest though), so that KE1 and KE2 only have two elements. I moved the text about explaining the structure of KE1/KE2 to be within the AKE messages section.",
          "createdAt": "2022-04-22T02:23:45Z",
          "updatedAt": "2022-04-22T02:23:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I understand that it's editorial, but I'm asking if the new names and types match that which we use in the reference implementation.",
          "createdAt": "2022-04-22T02:38:41Z",
          "updatedAt": "2022-04-22T02:38:41Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I understand that it's editorial, but I'm asking if the new names and types match that which we use in the reference implementation.\r\n\r\nAh I see. Yes, just checked the poc/ directory, and there was no mention of AuthInit/AuthResponse/AuthFinish previously (since we referred to their parameters directly in the ref implementation), so I don't believe anything needs to change there. Thanks for the clarification! :)",
          "createdAt": "2022-04-22T02:42:21Z",
          "updatedAt": "2022-04-22T02:42:21Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood -- this should be ready to merge!",
          "createdAt": "2022-04-26T00:32:12Z",
          "updatedAt": "2022-04-26T00:32:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs44aQrt",
          "commit": {
            "abbreviatedOid": "2fdffa6"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T23:06:29Z",
          "updatedAt": "2022-04-19T23:06:30Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Why remove this?",
              "createdAt": "2022-04-19T23:06:29Z",
              "updatedAt": "2022-04-19T23:06:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs44afhW",
          "commit": {
            "abbreviatedOid": "2fdffa6"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-04-20T00:30:14Z",
          "updatedAt": "2022-04-20T00:39:44Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "```suggestion\r\n  uint8 blinded_element[Noe];\r\n```",
              "createdAt": "2022-04-20T00:30:14Z",
              "updatedAt": "2022-04-20T00:39:44Z"
            },
            {
              "originalPosition": 87,
              "body": "```suggestion\r\nblinded_element: A serialized OPRF blinded element of fixed size Noe.\r\n```",
              "createdAt": "2022-04-20T00:31:52Z",
              "updatedAt": "2022-04-20T00:39:44Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n  uint8 evaluated_message[Noe];\r\n  uint8 masking_nonce[Nn];\r\n  uint8 masked_response[Npk + Ne];\r\n```",
              "createdAt": "2022-04-20T00:32:29Z",
              "updatedAt": "2022-04-20T00:39:44Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nclient_keyshare : Serialized client ephemeral key share of fixed size Npk.\r\n```",
              "createdAt": "2022-04-20T00:34:21Z",
              "updatedAt": "2022-04-20T00:39:44Z"
            },
            {
              "originalPosition": 103,
              "body": "evaluated_message: A serialized OPRF evaluated element of fixed size Noe.\r\n\r\nmasking_nonce: A nonce used for the confidentiality of the masked_response field of fixed size Nn.\r\n\r\nmasked_response: An encrypted form of the server's public key and the client's `Envelope` structure of fixed size Npk + Ne.",
              "createdAt": "2022-04-20T00:38:46Z",
              "updatedAt": "2022-04-20T00:39:44Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nclient_mac: An authentication tag computed over the handshake transcript of fixed size Nm.\r\n```",
              "createdAt": "2022-04-20T00:39:15Z",
              "updatedAt": "2022-04-20T00:39:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs44dUAo",
          "commit": {
            "abbreviatedOid": "2fdffa6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-20T13:55:25Z",
          "updatedAt": "2022-04-20T13:55:25Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "It doesn't seem to add any value (to me, after not having looked at it for quite some time).",
              "createdAt": "2022-04-20T13:55:25Z",
              "updatedAt": "2022-04-20T13:55:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs44sthC",
          "commit": {
            "abbreviatedOid": "85a7994"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-24T20:11:40Z",
          "updatedAt": "2022-04-24T20:11:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs44x-mm",
          "commit": {
            "abbreviatedOid": "85a7994"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-26T01:38:11Z",
          "updatedAt": "2022-04-26T01:38:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 353,
      "id": "PR_kwDOD79ejs42-zDd",
      "title": "Auth ClientFinalize prototype should return export_key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/353",
      "state": "MERGED",
      "author": "cdrubin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update pseudocode prototype for function ClientFinalize to match the rest of the document which has it return the `export_key`",
      "createdAt": "2022-04-28T22:27:41Z",
      "updatedAt": "2022-05-06T10:54:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3977e9ae3a911144a90271ce84cad72b6945a8a2",
      "headRepository": "cdrubin/draft-irtf-cfrg-opaque",
      "headRefName": "master",
      "headRefOid": "9b0c2a110de7cd6ae77be9abeb4f1297366363e1",
      "closedAt": "2022-05-06T10:54:03Z",
      "mergedAt": "2022-05-06T10:54:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fbcb58299b6327b3327fc8d38a21e579de1a79d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs45IqJZ",
          "commit": {
            "abbreviatedOid": "9b0c2a1"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks for the catch!",
          "createdAt": "2022-05-01T10:24:29Z",
          "updatedAt": "2022-05-01T10:24:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 354,
      "id": "PR_kwDOD79ejs43IJrg",
      "title": "Various editorial changes + fixing typos",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/354",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "1) Added a reference to the AKE stage being also called the \"login stage\" in various parts in the document\r\n2) Found some places where `RegistrationUpload` was still being referenced, and changed it to `RegistrationRecord`\r\n3) Reformatted parts where parameters are laid out, conforming them all into one of two formats:\r\n- parameter: A parameter with some description.\r\nor\r\n- parameter, a parameter with some description.\r\n(Some places had unnecessary capitalization / missing periods, spaces between colon and parameter, etc.)\r\n4) Added backticks around all named parameters that were referenced outside of a codeblock\r\n",
      "createdAt": "2022-05-01T10:22:45Z",
      "updatedAt": "2022-05-06T10:56:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3977e9ae3a911144a90271ce84cad72b6945a8a2",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "editorial",
      "headRefOid": "d6741906871219fd0370b6e2adabbd0dad5fe2eb",
      "closedAt": "2022-05-06T10:56:45Z",
      "mergedAt": "2022-05-06T10:56:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "78b3e81eceb98202a0fd32afa36c158392c97ecd"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Lots of improvements in here! \ud83c\udf89 ",
          "createdAt": "2022-05-06T10:56:41Z",
          "updatedAt": "2022-05-06T10:56:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs45fOga",
          "commit": {
            "abbreviatedOid": "d674190"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-06T10:56:18Z",
          "updatedAt": "2022-05-06T10:56:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 355,
      "id": "PR_kwDOD79ejs437_8w",
      "title": "Reordering AKE subsections",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/355",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This finishes the last portion of #352, in which I wanted to reorder the subsections slightly in the AKE portion to make things more clear.\r\n\r\nBefore this change, we had the following ordering of subsections in AKE:\r\n\r\n\"Online Authenticated Key Exchange\" main section with protocol description at a high level \r\n- \"Client Authentication Functions\" subsection\r\n- \"Server Authentication Functions\" subsection\r\n- \"Credential Retrieval\" subsection\r\n- \"AKE Protocol\"\r\n  - \"AKE Messages\" section, this is where KE1, KE2, KE3 are defined\r\n  - \"3DH Client Functions\" subsection\r\n  - \"3DH Server Functions\" subsection\r\n\r\nSo the main problem was that the first two subsections, Client/Server Authentication Functions, were outputting messages that were only defined in the \"AKE Messages\" subsection, which was much later.\r\n\r\nThis seems like quite a different structure from the Registration portion, which is currently organized like:\r\n\r\n\"Client Credential Storage and Key Recovery\" main section\r\n\"Offline Registration\" main section\r\n- \"Registration Messages\" subsection\r\n- \"Registration Functions\" subsection\r\n\r\nwhich is a way simpler layout.\r\n\r\n\r\n--------\r\n\r\nSo the change I am making here is to:\r\n1) Combine the \"Client Authentication Functions\" and \"Server Authentication Functions\" into one subsection, called \"AKE Functions\", so that it matches up with the layout of registration\r\n2) Put \"AKE Messages\" as the section immediately following the main protocol description, followed by the new \"AKE Functions\" subsection\r\n3) Leave the remainder of the subsections as-is in terms of ordering. So the new layout looks like this now:\r\n\r\n\"Online Authenticated Key Exchange\" main section with protocol description at a high level \r\n- \"AKE Messages\" subsection\r\n- \"AKE Functions\" subsection\r\n- \"Credential Retrieval\" subsection\r\n- \"AKE Protocol\"\r\n  - \"3DH Client Functions\" subsection\r\n  - \"3DH Server Functions\" subsection\r\n  \r\n  Hope this makes sense!\r\n  \r\n  In making this change, there were also some smaller adjustments I made, as well:\r\n  - renamed the 3dh functions from \"Start\" to \"AuthStart\", \"Response\" to \"AuthRespond\" (it should be at least be a verb), \"ClientFinalize\" to \"AuthClientFinalize\", and \"ServerFinalize\" to \"AuthServerFinalize\"\r\n  - I also added a definition for ServerFinish, which simply calls AuthServerFinalize, but this was previously a completely undefined function\r\n  - Added text at the beginning of the \"AKE Functions\" subsection to clarify that the subroutines that we call there are defined in later sections\r\n\r\nBtw, a change I was tempted to make, but did not end up making was to combine the \"3DH client functions\" and \"3DH server functions\" also into one section. We don't seem to be doing the splitting of client vs. server functions elsewhere anymore (especially after this change), so it is necessary that we do it in the very last section?\r\n",
      "createdAt": "2022-05-17T08:18:29Z",
      "updatedAt": "2022-05-20T05:46:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "78b3e81eceb98202a0fd32afa36c158392c97ecd",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "reorder_ake_subsections",
      "headRefOid": "000337fbe7fa78618c3d625346bb2ef3cb993185",
      "closedAt": "2022-05-20T05:46:09Z",
      "mergedAt": "2022-05-20T05:46:09Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "acfa39d663e9280af530496403f1a0779676ee80"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs46X8bk",
          "commit": {
            "abbreviatedOid": "2af82e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with one suggestion for a rename. This is indeed a better layout in my opinion!",
          "createdAt": "2022-05-19T23:11:15Z",
          "updatedAt": "2022-05-19T23:11:44Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Should we make `AuthStart` be `AuthClientStart` (and similar for AuthRespond) so the roles are explicit?",
              "createdAt": "2022-05-19T23:11:15Z",
              "updatedAt": "2022-05-19T23:11:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs46YP-V",
          "commit": {
            "abbreviatedOid": "2af82e2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-20T02:00:12Z",
          "updatedAt": "2022-05-20T02:00:13Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Good idea! Updated in the latest commit.",
              "createdAt": "2022-05-20T02:00:13Z",
              "updatedAt": "2022-05-20T02:00:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 357,
      "id": "PR_kwDOD79ejs44Lqdt",
      "title": "Add prose to section headers to guide the reader",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/357",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #334.",
      "createdAt": "2022-05-20T11:00:00Z",
      "updatedAt": "2022-05-21T00:29:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "6982436b2d58f92ffe4556d5e8a9312cad5a32e6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/intros",
      "headRefOid": "d36a49435b933520bc7a636a288cb62c0fa64ff5",
      "closedAt": "2022-05-21T00:29:04Z",
      "mergedAt": "2022-05-21T00:29:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "34c689d0d03b4b2a731f3a84bdf73185828519a0"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> We are doing backticks for all function and message names, right? Just checking... I did not mark all of the ones towards the end of the file, but if this is the case, please update!\r\n\r\nBackticked everything! Will resolve conflicts and then merge.",
          "createdAt": "2022-05-21T00:27:55Z",
          "updatedAt": "2022-05-21T00:27:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs46bYzI",
          "commit": {
            "abbreviatedOid": "cd71063"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T14:58:50Z",
          "updatedAt": "2022-05-20T14:58:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs46dQYb",
          "commit": {
            "abbreviatedOid": "cd71063"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We are doing backticks for all function and message names, right? Just checking... I did not mark all of the ones towards the end of the file, but if this is the case, please update!\r\n\r\nOtherwise, looks good :)",
          "createdAt": "2022-05-21T00:14:07Z",
          "updatedAt": "2022-05-21T00:18:25Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "These should be displayed using backticks right?",
              "createdAt": "2022-05-21T00:14:07Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 52,
              "body": "Same here regarding backticks, though I see we are less consistent about function names and backticking them. Can you also backtick any occurrences of function names?",
              "createdAt": "2022-05-21T00:15:08Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 120,
              "body": "backticks for ClientInit and KE1",
              "createdAt": "2022-05-21T00:15:36Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 131,
              "body": "ServerInit, KE1, KE2 backticks",
              "createdAt": "2022-05-21T00:15:59Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 141,
              "body": "ClientFinish, KE3 backticks",
              "createdAt": "2022-05-21T00:16:09Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 156,
              "body": "ServerFinish backticks",
              "createdAt": "2022-05-21T00:16:24Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 157,
              "body": "KE3 backticks",
              "createdAt": "2022-05-21T00:16:39Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 174,
              "body": "CredentialRequest and CredentialResponse backticks",
              "createdAt": "2022-05-21T00:17:06Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 185,
              "body": "Backticks for function names",
              "createdAt": "2022-05-21T00:17:16Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            },
            {
              "originalPosition": 190,
              "body": "Backticks for function names and message names",
              "createdAt": "2022-05-21T00:17:27Z",
              "updatedAt": "2022-05-21T00:18:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 358,
      "id": "PR_kwDOD79ejs44Ls_W",
      "title": "Fix some bugs point out offline",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/358",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "No corresponding issue.",
      "createdAt": "2022-05-20T11:10:53Z",
      "updatedAt": "2022-05-21T00:22:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "acfa39d663e9280af530496403f1a0779676ee80",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/some-bugs",
      "headRefOid": "ef13567ac989bf901c2a1e8c9781032094f003ad",
      "closedAt": "2022-05-21T00:22:17Z",
      "mergedAt": "2022-05-21T00:22:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6982436b2d58f92ffe4556d5e8a9312cad5a32e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs46bkXP",
          "commit": {
            "abbreviatedOid": "ef13567"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T15:32:25Z",
          "updatedAt": "2022-05-20T15:32:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs46dQnj",
          "commit": {
            "abbreviatedOid": "ef13567"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2022-05-21T00:19:56Z",
          "updatedAt": "2022-05-21T00:19:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "PR_kwDOD79ejs44fjDq",
      "title": "fix expired url signature",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/360",
      "state": "MERGED",
      "author": "afbase",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The url referenced is a signed url that expired (see code below).  I replaced it with a url that  is permanent.  the url does 301 but it 301's to a signed url that is created upon the request\r\n# permanent url\r\n```bash\r\n curl -L -vvv \"https://www.whatsapp.com/security/WhatsApp_Security_Encrypted_Backups_Whitepaper.pdf\"\r\n*   Trying 157.240.22.53:443...\r\n* TCP_NODELAY set\r\n* Connected to www.whatsapp.com (157.240.22.53) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/certs/ca-certificates.crt\r\n  CApath: /etc/ssl/certs\r\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):\r\n* TLSv1.3 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.3 (IN), TLS handshake, CERT verify (15):\r\n* TLSv1.3 (IN), TLS handshake, Finished (20):\r\n* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.3 (OUT), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.3 / TLS_CHACHA20_POLY1305_SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: C=US; ST=California; L=Menlo Park; O=Facebook, Inc.; CN=*.whatsapp.net\r\n*  start date: Mar  5 00:00:00 2022 GMT\r\n*  expire date: Jun  3 23:59:59 2022 GMT\r\n*  subjectAltName: host \"www.whatsapp.com\" matched cert's \"*.whatsapp.com\"\r\n*  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=DigiCert SHA2 High Assurance Server CA\r\n*  SSL certificate verify ok.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x56047695e8c0)\r\n> GET /security/WhatsApp_Security_Encrypted_Backups_Whitepaper.pdf HTTP/2\r\n> Host: www.whatsapp.com\r\n> user-agent: curl/7.68.0\r\n> accept: */*\r\n>\r\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n< HTTP/2 301\r\n< vary: Accept-Encoding\r\n< set-cookie: wa_lang_pref=en; expires=Thu, 02-Jun-2022 02:23:23 GMT; Max-Age=604800; path=/; domain=.whatsapp.com; secure\r\n< set-cookie: wa_ul=46238afc-a1ee-4d23-b814-edb29c4829b4; expires=Sat, 25-May-2024 02:23:23 GMT; Max-Age=63072000; path=/; domain=.www.whatsapp.com; secure; httponly\r\n< location: https://scontent-sjc3-1.xx.fbcdn.net/v/t39.8562-6/241394876_546674233234181_8907137889500301879_n.pdf?_nc_cat=108&ccb=1-7&_nc_sid=ad8a9d&_nc_ohc=Ftgo5r_SdYEAX8FhK4j&_nc_ht=scontent-sjc3-1.xx&oh=00_AT_tn4hSzMPsNjvtYVrlGKQ_hphdCa8xhRy8nRyZtEHzRw&oe=629490E6\r\n< document-policy: force-load-at-top\r\n< cross-origin-resource-policy: rollout\r\n< pragma: no-cache\r\n< cache-control: private, no-cache, no-store, must-revalidate\r\n< expires: Sat, 01 Jan 2000 00:00:00 GMT\r\n< x-content-type-options: nosniff\r\n< x-xss-protection: 0\r\n< x-frame-options: DENY\r\n< strict-transport-security: max-age=31536000; preload; includeSubDomains\r\n< content-type: text/html; charset=\"utf-8\"\r\n< x-fb-debug: KCaq4jT8xN+paygEbZKm7/8PLgcM+XoUAp1gSmWwQ+ZkWWZqg4gruqInRPge2QKyzQtl8aniYM/ePo9HqsFWLw==\r\n< content-length: 0\r\n< priority: u=3,i\r\n< x-fb-trip-id: 1679558926\r\n< date: Thu, 26 May 2022 02:23:23 GMT\r\n< alt-svc: h3=\":443\"; ma=86400,h3-29=\":443\"; ma=86400\r\n<\r\n* Connection #0 to host www.whatsapp.com left intact\r\n* Issue another request to this URL: 'https://scontent-sjc3-1.xx.fbcdn.net/v/t39.8562-6/241394876_546674233234181_8907137889500301879_n.pdf?_nc_cat=108&ccb=1-7&_nc_sid=ad8a9d&_nc_ohc=Ftgo5r_SdYEAX8FhK4j&_nc_ht=scontent-sjc3-1.xx&oh=00_AT_tn4hSzMPsNjvtYVrlGKQ_hphdCa8xhRy8nRyZtEHzRw&oe=629490E6'\r\n*   Trying 157.240.22.25:443...\r\n* TCP_NODELAY set\r\n* Connected to scontent-sjc3-1.xx.fbcdn.net (157.240.22.25) port 443 (#1)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/certs/ca-certificates.crt\r\n  CApath: /etc/ssl/certs\r\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):\r\n* TLSv1.3 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.3 (IN), TLS handshake, CERT verify (15):\r\n* TLSv1.3 (IN), TLS handshake, Finished (20):\r\n* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.3 (OUT), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.3 / TLS_CHACHA20_POLY1305_SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: C=US; ST=California; L=Menlo Park; O=Facebook, Inc.; CN=*.facebook.com\r\n*  start date: Mar  5 00:00:00 2022 GMT\r\n*  expire date: Jun  3 23:59:59 2022 GMT\r\n*  subjectAltName: host \"scontent-sjc3-1.xx.fbcdn.net\" matched cert's \"*.xx.fbcdn.net\"\r\n*  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=DigiCert SHA2 High Assurance Server CA\r\n*  SSL certificate verify ok.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x56047695e8c0)\r\n> GET /v/t39.8562-6/241394876_546674233234181_8907137889500301879_n.pdf?_nc_cat=108&ccb=1-7&_nc_sid=ad8a9d&_nc_ohc=Ftgo5r_SdYEAX8FhK4j&_nc_ht=scontent-sjc3-1.xx&oh=00_AT_tn4hSzMPsNjvtYVrlGKQ_hphdCa8xhRy8nRyZtEHzRw&oe=629490E6 HTTP/2\r\n> Host: scontent-sjc3-1.xx.fbcdn.net\r\n> user-agent: curl/7.68.0\r\n> accept: */*\r\n>\r\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n< HTTP/2 200\r\n< last-modified: Wed, 08 Sep 2021 19:29:18 GMT\r\n< accept-ranges: bytes\r\n< content-type: application/pdf\r\n< x-haystack-needlechecksum: 1093967180\r\n< x-needle-checksum: 2876820207\r\n< content-digest: adler32=2876820207\r\n< timing-allow-origin: *\r\n< cross-origin-resource-policy: cross-origin\r\n< cache-control: max-age=1209600, no-transform\r\n< content-length: 610383\r\n< x-fb-trip-id: 664085054\r\n< date: Thu, 26 May 2022 02:23:23 GMT\r\n< alt-svc: h3=\":443\"; ma=86400,h3-29=\":443\"; ma=86400\r\n<\r\nWarning: Binary output can mess up your terminal. Use \"--output -\" to tell\r\nWarning: curl to output it to your terminal anyway, or consider \"--output\r\nWarning: <FILE>\" to save to a file.\r\n* Failed writing body (0 != 1492)\r\n* stopped the pause stream!\r\n* Connection #1 to host scontent-sjc3-1.xx.fbcdn.net left intact\r\n```\r\n# expired url\r\n\r\n```bash\r\ncurl -L -vvv \"https://scontent.whatsapp.net/v/t39.8562-34/241394876_546674233234181_8907137889500301879_n.pdf/WhatsApp_Security_Encrypted_Backups_Whitepaper.pdf?ccb=1-5&_nc_sid=2fbf2a&_nc_ohc=Y3PFzd-3LG4AX9AdA8_&_nc_ht=scontent.whatsapp.net&oh=01_AVwwbFhPNWAn-u9VV4wqetjL2T9rX2pDmXwlk0aus4YrKA&oe=620029BC\"\r\n*   Trying 157.240.22.53:443...\r\n* TCP_NODELAY set\r\n* Connected to scontent.whatsapp.net (157.240.22.53) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/certs/ca-certificates.crt\r\n  CApath: /etc/ssl/certs\r\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):\r\n* TLSv1.3 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.3 (IN), TLS handshake, CERT verify (15):\r\n* TLSv1.3 (IN), TLS handshake, Finished (20):\r\n* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.3 (OUT), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.3 / TLS_CHACHA20_POLY1305_SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: C=US; ST=California; L=Menlo Park; O=Facebook, Inc.; CN=*.whatsapp.net\r\n*  start date: Mar  5 00:00:00 2022 GMT\r\n*  expire date: Jun  3 23:59:59 2022 GMT\r\n*  subjectAltName: host \"scontent.whatsapp.net\" matched cert's \"*.whatsapp.net\"\r\n*  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=DigiCert SHA2 High Assurance Server CA\r\n*  SSL certificate verify ok.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x55aa806c88c0)\r\n> GET /v/t39.8562-34/241394876_546674233234181_8907137889500301879_n.pdf/WhatsApp_Security_Encrypted_Backups_Whitepaper.pdf?ccb=1-5&_nc_sid=2fbf2a&_nc_ohc=Y3PFzd-3LG4AX9AdA8_&_nc_ht=scontent.whatsapp.net&oh=01_AVwwbFhPNWAn-u9VV4wqetjL2T9rX2pDmXwlk0aus4YrKA&oe=620029BC HTTP/2\r\n> Host: scontent.whatsapp.net\r\n> user-agent: curl/7.68.0\r\n> accept: */*\r\n>\r\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 100)!\r\n< HTTP/2 403\r\n< access-control-allow-origin: *\r\n< proxy-status: http_request_error; e_clientaddr=\"AcIcw49dU5SXoSgm2qhCY9JOdwmk-g7c4eL0YvmM8gcKjeRWt7VTcDw0p4fVzJHBz7BNUQkP4PCN6wgU\"; e_fb_vipaddr=\"AcJD9xXeefcgDQNsMeLor06rEBtY3O4Qu4Uy2BEpNq-YQtMM3MM_rIFmYmmf_RM9T73Yo-GGZA\"; e_fb_builduser=\"AcJHKIOsCvuc8JAokZdFbf1WJK0zju-kg0oqibai1hjBjNwvnJviyTFnV7gkAUH63L8\"; e_fb_binaryversion=\"AcJeNSI_2YNqiSMB0sQx46y2BsFAPGHJPVj1aqitKyii94gZGThfoa2JLee-QHcZ7ZSBof14-3P603u-kFsFSgBAxdOZvmTCELg\"; e_proxy=\"AcJ5u76IEcc742pAwBj8e53fZT3EECWrxuU4RZJKEgZmcH6JJqJ-qQjVHaC6pwKY4cNzgVM7NKYXS_rH\"\r\n< content-type: text/plain\r\n< content-length: 21\r\n< server: proxygen-bolt\r\n< x-fb-trip-id: 1679558926\r\n< date: Thu, 26 May 2022 02:08:31 GMT\r\n< alt-svc: h3=\":443\"; ma=86400,h3-29=\":443\"; ma=86400\r\n<\r\n* Connection #0 to host scontent.whatsapp.net left intact\r\n```",
      "createdAt": "2022-05-26T02:25:45Z",
      "updatedAt": "2022-06-14T10:24:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "34c689d0d03b4b2a731f3a84bdf73185828519a0",
      "headRepository": "afbase/draft-irtf-cfrg-opaque",
      "headRefName": "afbase/whatsapp-link",
      "headRefOid": "d9decb6bb9e38a043f45f5e1e8428b94d27ab9e8",
      "closedAt": "2022-06-14T10:24:11Z",
      "mergedAt": "2022-06-14T10:24:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b5e98567a72cc56c7997ef758b6e332519320be7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs478HjC",
          "commit": {
            "abbreviatedOid": "d9decb6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-14T10:23:58Z",
          "updatedAt": "2022-06-14T10:23:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 362,
      "id": "PR_kwDOD79ejs44rN2s",
      "title": "Separates ClientState and ServerState from ClientAkeState and ServerAkeState",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/362",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #291.\r\n\r\nAdding in formal definitions for `ClientState`, `ServerState`, `ClientAkeState`, and `ServerAkeState`.\r\n\r\nNote that for the password field, which can be variable-length, I set the type to `opaque password<1..2^16-1>`, even though this is not a strict requirement. I also set blind to be `opaque blind<1..2^16-1>`. Let me know if these should be changed!\r\n\r\n",
      "createdAt": "2022-05-30T11:11:21Z",
      "updatedAt": "2022-06-05T07:47:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "34c689d0d03b4b2a731f3a84bdf73185828519a0",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_state",
      "headRefOid": "a2127dbf1a654821b027c2e2c7dee149c5a94974",
      "closedAt": "2022-06-05T07:47:36Z",
      "mergedAt": "2022-06-05T07:47:36Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "d7fb2bb8df4371160d46ffb0f13c690e1f69332a"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i agree with Chris that these are implementation specific. so **none** of this should be binding. however i see value\r\n  - for implementers as a kind of checklist,\r\n  - for interoperability for suggesting minimum/maximum size for variable sized fields - this would enable converters between different implementations,\r\n  - most importantly lifetime, sensitivity/confidentiality of these fields (for example can they be serialized to storage, do they need to be encrypted, will they lose importance after the next step, etc)\r\n\r\ni understand that much of this is already specified through-out of this document, and thus i think this is merely a convenience feature for implementers who don't have to piece this information together from various parts of the spec. i guess that's a lot of words for saying put this whole thing into a non-binding appendix.",
          "createdAt": "2022-05-30T14:08:44Z",
          "updatedAt": "2022-05-30T14:08:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback. I agree that it shouldn't be required for implementations to implement this state. However, shouldn't we still have struct definitions for these, since they are referenced in the functions? Just going off of the discussion in Issue #291 which brought this to our attention in the first place...\r\n\r\nComment from @armfazh :\r\n> So, either formally specifying what the state contains, or removing at all the state structure are both good alternatives. Currently, it is specified something in between.",
          "createdAt": "2022-05-30T23:11:39Z",
          "updatedAt": "2022-05-30T23:11:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, shouldn't we still have struct definitions for these, since they are referenced in the functions? \n\nNo, I don't think so. It is sufficient to simply say what the data structure must contain. It is not necessary to say anything about how that data structure is implemented. ",
          "createdAt": "2022-05-30T23:13:07Z",
          "updatedAt": "2022-05-30T23:13:07Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, got it. Alright, I committed your suggestions which removed the formal specifications. This PR then doesn't do too much, other than separate ClientState/ServerState from ClientAkeState/ServerAkeState. \r\n\r\nAre we still good to close #291 after this lands?",
          "createdAt": "2022-05-30T23:18:21Z",
          "updatedAt": "2022-05-30T23:18:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs469jTh",
          "commit": {
            "abbreviatedOid": "5a90041"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The actual data structure is an implementation-specific decision and should not be mandated like this, so I think we ought to remove some details and just say list the things that can be referenced. ",
          "createdAt": "2022-05-30T11:33:52Z",
          "updatedAt": "2022-05-30T11:35:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-30T11:33:53Z",
              "updatedAt": "2022-05-30T11:35:30Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-30T11:34:05Z",
              "updatedAt": "2022-05-30T11:35:30Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nThe client AKE state `ClientAkeState` mentioned in {{online-phase}} has the\r\n```",
              "createdAt": "2022-05-30T11:34:28Z",
              "updatedAt": "2022-05-30T11:35:30Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-30T11:34:36Z",
              "updatedAt": "2022-05-30T11:35:30Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-30T11:34:47Z",
              "updatedAt": "2022-05-30T11:35:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs47LDfm",
          "commit": {
            "abbreviatedOid": "a2127db"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-01T22:36:16Z",
          "updatedAt": "2022-06-01T22:36:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 364,
      "id": "PR_kwDOD79ejs45jCD1",
      "title": "Fixing return types for AKE and 3DH functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/364",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses inconsistencies found in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/356\r\n\r\nNote that we need to slightly change how inner_ke2 works (https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/363), to be done in a follow-up PR.",
      "createdAt": "2022-06-13T09:26:57Z",
      "updatedAt": "2022-06-14T10:24:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d7fb2bb8df4371160d46ffb0f13c690e1f69332a",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_returns",
      "headRefOid": "27a5dee81e9add60b36f6db5a4fc959e1cb8053c",
      "closedAt": "2022-06-14T10:24:44Z",
      "mergedAt": "2022-06-14T10:24:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b0e1708280db595210c4e1642903549334831a51"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs478Hvt",
          "commit": {
            "abbreviatedOid": "27a5dee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-14T10:24:40Z",
          "updatedAt": "2022-06-14T10:24:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 365,
      "id": "PR_kwDOD79ejs4575PG",
      "title": "Fixing references to inner_ke2 by adjusting preamble parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/365",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There is an outdated reference in the definition of the `AuthServerRespond` function to an `ike2` parameter.\r\n\r\nThere used to be a struct called \"inner ke2\" which was used here. Instead, I am adjusting the parameters passed to the `Preamble` function to just accept the three fields needed to construct the preamble.\r\n\r\nThis also fixes all calls to `Preamble` to pass the three parameters individually.\r\n\r\nCloses #363.",
      "createdAt": "2022-06-20T09:56:10Z",
      "updatedAt": "2022-06-20T14:54:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "b0e1708280db595210c4e1642903549334831a51",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_ike2",
      "headRefOid": "57ed1b57ee7373926fa4fd0b6343b9f2fc294ef0",
      "closedAt": "2022-06-20T14:54:41Z",
      "mergedAt": "2022-06-20T14:54:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "52beedb73fd58b5f469298e7027abd9f73e5cf4d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs48WFG3",
          "commit": {
            "abbreviatedOid": "57ed1b5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-20T14:54:35Z",
          "updatedAt": "2022-06-20T14:54:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 366,
      "id": "PR_kwDOD79ejs46o9lV",
      "title": "Update test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/366",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... in preparation for a new version.",
      "createdAt": "2022-06-30T13:02:20Z",
      "updatedAt": "2022-07-04T15:05:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "52beedb73fd58b5f469298e7027abd9f73e5cf4d",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/update-vectors",
      "headRefOid": "58844c3034e48391bf6aba21c2611f00c93427ec",
      "closedAt": "2022-07-01T18:13:36Z",
      "mergedAt": "2022-07-01T18:13:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f594f2c4def012268d27201194ddfe8692fb71e0"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "only the voprf version has to be incremented to have this pass?",
          "createdAt": "2022-06-30T14:19:54Z",
          "updatedAt": "2022-06-30T14:19:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef yep, I believe so.",
          "createdAt": "2022-06-30T14:23:50Z",
          "updatedAt": "2022-06-30T14:23:50Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Works on my side \u2714\ufe0f ",
          "createdAt": "2022-07-01T15:32:27Z",
          "updatedAt": "2022-07-01T15:32:27Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "wfm2",
          "createdAt": "2022-07-04T15:05:40Z",
          "updatedAt": "2022-07-04T15:05:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs49LTNv",
          "commit": {
            "abbreviatedOid": "58844c3"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-01T15:32:45Z",
          "updatedAt": "2022-07-01T15:32:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 367,
      "id": "PR_kwDOD79ejs46uDrC",
      "title": "Simplify and fix some typos",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/367",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-01T16:43:17Z",
      "updatedAt": "2022-07-01T17:59:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "fdbfd38da23935e35ca986fa07111a26fcaac890",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/minor-fixes",
      "headRefOid": "ee8898ce4e9f9bf4a270ee1169aee76f092d09da",
      "closedAt": "2022-07-01T16:59:40Z",
      "mergedAt": "2022-07-01T16:59:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "669b3c1da53824f36e69db5ac155d7c80280ac06"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs49LnHS",
          "commit": {
            "abbreviatedOid": "ee8898c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-01T16:59:32Z",
          "updatedAt": "2022-07-01T16:59:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 368,
      "id": "PR_kwDOD79ejs46uWLb",
      "title": "Note fallible functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/368",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #312.",
      "createdAt": "2022-07-01T18:11:00Z",
      "updatedAt": "2022-07-05T19:15:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9fe33fb4b0c5d57ad9a09621af122144d19ac44f",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/failures",
      "headRefOid": "3500c3a99ab2be95aded01735f0bb49633905b68",
      "closedAt": "2022-07-05T19:15:36Z",
      "mergedAt": "2022-07-05T19:15:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4c36aa9eede4f12c3d0cdbce196e9256af930671"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is a good one. is this complete?",
          "createdAt": "2022-07-01T18:59:57Z",
          "updatedAt": "2022-07-01T18:59:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "What does complete mean here?",
          "createdAt": "2022-07-01T19:00:39Z",
          "updatedAt": "2022-07-01T19:00:39Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oops sorry, i mean is this all functions that can fail and all that can which should be retried?",
          "createdAt": "2022-07-01T19:02:26Z",
          "updatedAt": "2022-07-01T19:02:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on the discussion in the corresponding issue, I believe so!",
          "createdAt": "2022-07-01T19:03:07Z",
          "updatedAt": "2022-07-01T19:03:07Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "eh. i missed that. /o\\ \r\nsorry, my focus is elsewhere now :/",
          "createdAt": "2022-07-01T19:15:48Z",
          "updatedAt": "2022-07-01T19:15:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No worries :-)",
          "createdAt": "2022-07-01T19:16:16Z",
          "updatedAt": "2022-07-01T19:16:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 372,
      "id": "PR_kwDOD79ejs4-vhop",
      "title": "Removing references to Ne parameter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/372",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #369.\r\n\r\nReplaces instances of `Ne` with `Nn + Nm`. Thanks for the catch @crockeea!",
      "createdAt": "2022-09-12T00:52:16Z",
      "updatedAt": "2022-10-03T16:57:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c36aa9eede4f12c3d0cdbce196e9256af930671",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_ne",
      "headRefOid": "879b8a740ad05b2b6ed096f88b524cc8f0157c5b",
      "closedAt": "2022-10-03T16:57:16Z",
      "mergedAt": "2022-10-03T16:57:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ceeb4e7bdde479995b62d3a4a918595dd9584948"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5Bxg6A",
          "commit": {
            "abbreviatedOid": "879b8a7"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-12T05:31:35Z",
          "updatedAt": "2022-09-12T05:31:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 373,
      "id": "PR_kwDOD79ejs4-vi1K",
      "title": "Removing reference to internal mode in configuration strings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/373",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #370.\r\n\r\nccing @stef for pointing out the change and @bytemare as an FYI for the original PR that introduced the string\r\n\r\nAs stated in the issue, I believe this \"internal\" string should be omitted. It was introduced in https://github.com/cfrg/draft-irtf-cfrg-opaque/commit/950f2f0586dd03a2b3ffab11008c21a4d0d3f12b back when there was an \"external\" and \"internal\" mode for the envelope configuration portion of the protocol. Now that we no longer have those, we should have removed this internal configuration reference, but failed to.\r\n\r\n",
      "createdAt": "2022-09-12T01:03:11Z",
      "updatedAt": "2022-10-03T16:57:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c36aa9eede4f12c3d0cdbce196e9256af930671",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_internal_mode",
      "headRefOid": "70691d29693781149f07758931d42e212080b6ca",
      "closedAt": "2022-10-03T16:57:33Z",
      "mergedAt": "2022-10-03T16:57:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "798978f93134c15e4850fced13db13d6ed347c76"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5BxhNP",
          "commit": {
            "abbreviatedOid": "70691d2"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-12T05:33:44Z",
          "updatedAt": "2022-09-12T05:33:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5DRwPf",
          "commit": {
            "abbreviatedOid": "70691d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-03T16:57:29Z",
          "updatedAt": "2022-10-03T16:57:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 374,
      "id": "PR_kwDOD79ejs4-0tqw",
      "title": "Rename \"ephemeral key share\" to \"ephemeral public key\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/374",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #371.\r\n\r\nSee the discussion in #371 for more context. Note that this only changes the prose describing the variable names, and not the variable names themselves.\r\n\r\ncc'ing @stef for feedback",
      "createdAt": "2022-09-12T23:39:21Z",
      "updatedAt": "2022-10-03T17:03:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c36aa9eede4f12c3d0cdbce196e9256af930671",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "rename_keyshare",
      "headRefOid": "8c5d508b50c3ea3e3fb88a10c3a6685707ccbe31",
      "closedAt": "2022-10-03T17:03:58Z",
      "mergedAt": "2022-10-03T17:03:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f6f458234d546b6f10fd43f5cb7b3ece75be33e1"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "great thanks! only nit, for me it's the variable names also that are confusing. everytime i look at the testvectors, most of the variables are obvious, but the keyshare vars are always confusing me. would it be a big thing to also rename them?",
          "createdAt": "2022-09-13T15:05:48Z",
          "updatedAt": "2022-09-13T15:05:48Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef: Personally, I'm reluctant to do the variable renaming because I think it is too big of a change at this point. But perhaps if others chime in with an opinion on whether or not it's worth the variable renaming, we could consider it? @bytemare @chris-wood ",
          "createdAt": "2022-09-14T04:55:57Z",
          "updatedAt": "2022-09-14T04:55:57Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not against, for consistency I think it's better to also rename the vectors.\n(New implementors or readers might get a bit confused)",
          "createdAt": "2022-09-14T04:59:46Z",
          "updatedAt": "2022-09-14T04:59:46Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Here are the four variables we would need to rename:\r\n- `server_keyshare`\r\n- `client_keyshare`\r\n- `server_private_keyshare`\r\n- `client_private_keyshare`\r\n\r\nFor context, these names were originally decided on in https://github.com/cfrg/draft-irtf-cfrg-opaque/commit/87c3287dc789eda67dcb93fbd481334025c71cc6 , where their previous names were:\r\n- `epkS`, `epkU`, `eskS`, `eskU`\r\n\r\nAny proposals for what each of these should be renamed to? Some options that come to mind:\r\n1) `client_e_pk`, `client_e_sk`, `server_e_pk`, `server_e_sk`\r\n2) `client_ephemeral_public_key`, `client_ephemeral_private_key`, `server_ephemeral_public_key`, `server_ephemeral_private_key`",
          "createdAt": "2022-09-14T05:18:37Z",
          "updatedAt": "2022-09-14T05:18:37Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think it is too big of a change at this point. \r\n\r\nwhy do you think so? for existing implementations nothing changes. it helps clarity.\r\n\r\nboth of your proposals are good, but since this is a spec, clarity and expressiveness should trump brevity so i would prefer the 2nd. but i also have to admit that in my code i still use the names from 87c3287 - which i think despite their cryptic shortness are still more expressive than keyshare.",
          "createdAt": "2022-09-14T10:44:44Z",
          "updatedAt": "2022-09-14T10:44:44Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oh i see the sage ref impl needs to be changed i guess?",
          "createdAt": "2022-09-14T10:46:07Z",
          "updatedAt": "2022-09-14T10:46:07Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the implementation itself (the code which produces the test vectors) would also need to be adjusted accordingly. I'd like to wait and see until we have others chime in with thoughts on this here before making the change. IMO although the name keyshare may not be 100% illustrative as a variable name, it doesn't seem to significantly detract from a reader understanding the protocol (given that we also define the variable as being the ephemeral public/private key already).",
          "createdAt": "2022-09-15T08:51:57Z",
          "updatedAt": "2022-09-15T08:51:57Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> IMO although the name keyshare may not be 100% illustrative as a variable name, it doesn't seem to significantly detract from a reader understanding the protocol (given that we also define the variable as being the ephemeral public/private key already).\r\n\r\ntrue, it only confuses when working with the test vectors.",
          "createdAt": "2022-09-15T10:17:23Z",
          "updatedAt": "2022-09-15T10:17:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5B3q6m",
          "commit": {
            "abbreviatedOid": "8c5d508"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-13T04:38:36Z",
          "updatedAt": "2022-09-13T04:38:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5DRyLJ",
          "commit": {
            "abbreviatedOid": "8c5d508"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-03T17:03:45Z",
          "updatedAt": "2022-10-03T17:03:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 377,
      "id": "PR_kwDOD79ejs5Bg4e5",
      "title": "Fix inaccuracies in function definitions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/377",
      "state": "MERGED",
      "author": "n-l-i",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-25T16:05:33Z",
      "updatedAt": "2022-12-06T10:43:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f6f458234d546b6f10fd43f5cb7b3ece75be33e1",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "304f5fe13e86e7a315727ca5b356b987dabc351c",
      "closedAt": "2022-12-06T10:43:58Z",
      "mergedAt": "2022-12-06T10:43:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c9ca293611f56367ce653aa9aa371211f1cea85f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5FZgrp",
          "commit": {
            "abbreviatedOid": "304f5fe"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is great. Thank you very much for catching these and making the contribution!",
          "createdAt": "2022-11-02T02:25:31Z",
          "updatedAt": "2022-11-02T02:25:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5H5zW7",
          "commit": {
            "abbreviatedOid": "304f5fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-06T10:43:53Z",
          "updatedAt": "2022-12-06T10:43:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 378,
      "id": "PR_kwDOD79ejs5CBEV-",
      "title": "Changing recommended config from scrypt to argon2id",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/378",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/376",
      "createdAt": "2022-11-02T02:27:34Z",
      "updatedAt": "2022-12-08T20:55:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "c9ca293611f56367ce653aa9aa371211f1cea85f",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "recommend_argon",
      "headRefOid": "e62da3828a3dcf5556731f10d50b466d1a59c9ea",
      "closedAt": "2022-12-08T20:55:22Z",
      "mergedAt": "2022-12-08T20:55:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "30a4fc37c7a09971c3b737c9368077607971f0d8"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Added `Argon2id(t=1, p=4, m=2^21)` into the recommendation.",
          "createdAt": "2022-12-08T18:25:20Z",
          "updatedAt": "2022-12-08T18:25:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5H50jd",
          "commit": {
            "abbreviatedOid": "57e7f28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-12-06T10:46:19Z",
          "updatedAt": "2022-12-06T10:46:22Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "We need to include parameters for Argon2id here, since this is a recommended profile that applications are meant to be able to use without doing anything else.",
              "createdAt": "2022-12-06T10:46:19Z",
              "updatedAt": "2022-12-06T10:46:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5H54SI",
          "commit": {
            "abbreviatedOid": "57e7f28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-06T10:54:59Z",
          "updatedAt": "2022-12-06T10:55:00Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "In particular, I think we ought to go with the FIRST RECOMMENDED option in RFC9106. Those options were recommended for a reason, and it makes sense to me that we reuse them here under the same reasoning.",
              "createdAt": "2022-12-06T10:54:59Z",
              "updatedAt": "2022-12-06T10:55:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5IKh5g",
          "commit": {
            "abbreviatedOid": "36e41b7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-08T20:13:36Z",
          "updatedAt": "2022-12-08T20:13:37Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n- OPRF(P-256, SHA-256), HKDF-SHA-256, HMAC-SHA-256, SHA-256, Argon2id(t=1, p=4, m=2^21), P-256\r\n```",
              "createdAt": "2022-12-08T20:13:37Z",
              "updatedAt": "2022-12-08T20:13:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5IKh94",
          "commit": {
            "abbreviatedOid": "e62da38"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-08T20:13:52Z",
          "updatedAt": "2022-12-08T20:13:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 379,
      "id": "PR_kwDOD79ejs5D2B-R",
      "title": "Add missing close paren to Recover()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/379",
      "state": "MERGED",
      "author": "soatok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-11-28T23:19:47Z",
      "updatedAt": "2022-12-04T17:58:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f6f458234d546b6f10fd43f5cb7b3ece75be33e1",
      "headRepository": "soatok/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "dff9a87365d49628f0cd06d20612b229466ac454",
      "closedAt": "2022-12-04T17:13:05Z",
      "mergedAt": "2022-12-04T17:13:05Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "5dfd1ca75fb92555265637febdf8c57762a006a3"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch! Thank you @soatok !\r\n\r\nI don't think this needs further review, merging.",
          "createdAt": "2022-12-04T17:12:55Z",
          "updatedAt": "2022-12-04T17:12:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 380,
      "id": "PR_kwDOD79ejs5Fvjlr",
      "title": "change the oprf api server dependency to BlindEvaluate",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/380",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I found this while trying to match the test vectors and following the POC implementation.",
      "createdAt": "2022-12-19T02:49:06Z",
      "updatedAt": "2023-01-12T13:08:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "30a4fc37c7a09971c3b737c9368077607971f0d8",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "use-blind-evaluate",
      "headRefOid": "a0e70fb551ed1aa9b984338633b6ce7e6f14d178",
      "closedAt": "2023-01-12T12:15:19Z",
      "mergedAt": "2023-01-12T12:15:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e4342946b696376923ce7160731d938bd1a934ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5KPLT0",
          "commit": {
            "abbreviatedOid": "a0e70fb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-12T12:15:12Z",
          "updatedAt": "2023-01-12T12:15:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 381,
      "id": "PR_kwDOD79ejs5Io2zt",
      "title": "minor improvement in the ServerInit input documentation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/381",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-27T01:38:50Z",
      "updatedAt": "2023-02-08T13:35:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e4342946b696376923ce7160731d938bd1a934ff",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "param-doc",
      "headRefOid": "d88550abb122617b89decf0484198f8d28ef7b5e",
      "closedAt": "2023-02-08T11:34:25Z",
      "mergedAt": "2023-02-08T11:34:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a66c97448b7fff8b9a99be984ded474d5c1fe2a3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5M1Fi1",
          "commit": {
            "abbreviatedOid": "d88550a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T11:34:20Z",
          "updatedAt": "2023-02-08T11:34:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 383,
      "id": "PR_kwDOD79ejs5JXpIR",
      "title": "Adapt OPRF calls to take into account new IDs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/383",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates the dependencies to the new VOPRF updates and therefore updates the vectors.",
      "createdAt": "2023-02-06T19:18:45Z",
      "updatedAt": "2023-04-03T09:08:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e4342946b696376923ce7160731d938bd1a934ff",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/update-voprf-20",
      "headRefOid": "0eb51051d24482242d1b0617c5ae415537f56822",
      "closedAt": "2023-02-08T11:34:08Z",
      "mergedAt": "2023-02-08T11:34:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6b9bb476c90ae344839a0c3946c547137f25f30c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5Mz4-3",
          "commit": {
            "abbreviatedOid": "0eb5105"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Awesome!",
          "createdAt": "2023-02-08T08:20:43Z",
          "updatedAt": "2023-02-08T08:20:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5M1Fbs",
          "commit": {
            "abbreviatedOid": "0eb5105"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T11:34:02Z",
          "updatedAt": "2023-02-08T11:34:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 385,
      "id": "PR_kwDOD79ejs5Kpru_",
      "title": "Use the correct request in CreateCredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/385",
      "state": "MERGED",
      "author": "fmarier",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There are two `request` members inside the `KE1` struct. The one that `CreateCredentialResponse()` needs is `credential_request`.",
      "createdAt": "2023-02-24T00:34:17Z",
      "updatedAt": "2023-03-10T18:16:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a66c97448b7fff8b9a99be984ded474d5c1fe2a3",
      "headRepository": "fmarier/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "2376d76d9c8b2cc4b2eb64c7bb2ab1360d88543c",
      "closedAt": "2023-03-10T18:16:33Z",
      "mergedAt": "2023-03-10T18:16:33Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "ff73c5fc9c37a51ae12e46902fe67b0333e8c5c9"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch!",
          "createdAt": "2023-03-10T16:06:04Z",
          "updatedAt": "2023-03-10T16:06:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5PlKlF",
          "commit": {
            "abbreviatedOid": "2376d76"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T16:05:50Z",
          "updatedAt": "2023-03-10T16:05:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 387,
      "id": "PR_kwDOD79ejs5KxlV8",
      "title": "Small improvements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/387",
      "state": "MERGED",
      "author": "mitar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-26T14:53:49Z",
      "updatedAt": "2023-03-10T18:19:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a66c97448b7fff8b9a99be984ded474d5c1fe2a3",
      "headRepository": "mitar/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "85d543924163c5c09eeee774f4d132daa85f27e4",
      "closedAt": "2023-03-10T18:19:23Z",
      "mergedAt": "2023-03-10T18:19:23Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "f3622b2fbc96a715cc566316fb496fba57a7d4f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5PlbKG",
          "commit": {
            "abbreviatedOid": "85d5439"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T16:41:44Z",
          "updatedAt": "2023-03-10T16:41:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5PmGyK",
          "commit": {
            "abbreviatedOid": "85d5439"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM as well, thank you!",
          "createdAt": "2023-03-10T18:19:15Z",
          "updatedAt": "2023-03-10T18:19:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 396,
      "id": "PR_kwDOD79ejs5LRohi",
      "title": "Fix h2c submodule",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/396",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n - Removes duplicated submodule for h2c. Better to use the one inside the voprf module.\r\n - ~Exports more values to make the Fake case reproducible. No changes on test vectors, just more verbose info for the `Fake=True` cases.~",
      "createdAt": "2023-03-04T03:44:48Z",
      "updatedAt": "2023-03-20T18:53:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f3622b2fbc96a715cc566316fb496fba57a7d4f9",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "armfazh/fixDuplicateH2C",
      "headRefOid": "a6f303ea0cd203a7eb8b43205fe12f3c1b80d9ec",
      "closedAt": "2023-03-20T18:53:42Z",
      "mergedAt": "2023-03-20T18:53:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ac1f7746855cdcdeb42f64256f463a67b94d8fa3"
      },
      "comments": [
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It wasn't required at all. Test vectors are ok as is.\r\nI just update this PR with changes only for h2c submodule.",
          "createdAt": "2023-03-14T15:35:03Z",
          "updatedAt": "2023-03-14T15:35:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @armfazh! Merging.",
          "createdAt": "2023-03-20T18:53:38Z",
          "updatedAt": "2023-03-20T18:53:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5PlUvF",
          "commit": {
            "abbreviatedOid": "f682e86"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Works for me ! Thank you :)",
          "createdAt": "2023-03-10T16:31:04Z",
          "updatedAt": "2023-03-10T16:31:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5PmMpI",
          "commit": {
            "abbreviatedOid": "f682e86"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@armfazh: Thanks! I'm struggling to understand the need for the changes to make the fake case reproducible, though...\r\n\r\nWhy do we need to include the input parameters to generate KE1 (e.g. password, client_nonce, etc.), and view KE1 as an output (as opposed to an input)? Shouldn't KE1 be an input, and KE2 be the only output?",
          "createdAt": "2023-03-10T18:35:53Z",
          "updatedAt": "2023-03-10T18:35:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5P4Kgu",
          "commit": {
            "abbreviatedOid": "a6f303e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM! Thanks!",
          "createdAt": "2023-03-14T19:16:04Z",
          "updatedAt": "2023-03-14T19:16:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5QQ3ZZ",
          "commit": {
            "abbreviatedOid": "a6f303e"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T19:43:08Z",
          "updatedAt": "2023-03-17T19:43:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good catch! I must have forgotten to commit that",
              "createdAt": "2023-03-17T19:43:08Z",
              "updatedAt": "2023-03-17T19:43:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QQ3j6",
          "commit": {
            "abbreviatedOid": "a6f303e"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-17T19:43:22Z",
          "updatedAt": "2023-03-17T19:43:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5Qa1_u",
          "commit": {
            "abbreviatedOid": "a6f303e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-20T18:53:27Z",
          "updatedAt": "2023-03-20T18:53:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 397,
      "id": "PR_kwDOD79ejs5Lnbp2",
      "title": "Clarifications about Threshold OPRF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/397",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Addresses and closes #389 and #390",
      "createdAt": "2023-03-08T23:22:19Z",
      "updatedAt": "2023-03-27T16:25:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a66c97448b7fff8b9a99be984ded474d5c1fe2a3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/some-clarifications",
      "headRefOid": "7a79256f8a1c079c7d5da6e21ff7c87c163cd690",
      "closedAt": "2023-03-22T12:54:14Z",
      "mergedAt": "2023-03-22T12:54:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "52074e81fe24eff96849490c8daecfb2c1c92a51"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I commented on this issue (\"distributing the server\") in the repository,\n#389\n\nIf you rephrase, please let me know so I take a look (hopefully, you will\nnot want to eliminate it)\n\n\nOn Tue, Mar 21, 2023 at 7:40\u202fAM Christopher Wood ***@***.***>\nwrote:\n\n> ***@***.**** commented on this pull request.\n> ------------------------------\n>\n> In draft-irtf-cfrg-opaque.md\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/397#discussion_r1143247313>\n> :\n>\n> > @@ -2127,10 +2126,11 @@ disclose their passwords to the server, even during registration. Note that a co\n>  server can run an exhaustive offline dictionary attack to validate guesses for the client's\n>  password; this is inevitable in any aPAKE protocol. (OPAQUE enables defense against such\n>\n> @bytemare <https://github.com/bytemare> will you be able to update this\n> text?\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/397#discussion_r1143247313>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXTZNZSKF25AIMCD7OLW5GHUBANCNFSM6AAAAAAVUL6DIA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-03-21T15:55:35Z",
          "updatedAt": "2023-03-21T15:55:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare can you run `make fix-lint` to tidy up whitespace?",
          "createdAt": "2023-03-21T22:44:11Z",
          "updatedAt": "2023-03-21T22:44:11Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, one more comment. I suggest the following edit  (marked in italics)\n\nThe authors suggest implementing the OPRF phase as a Threshold OPRF\n{{TOPPSS}}, effectively forcing an attacker to act online or to control at\nleast t key shares, where t is the threshold number of shares necessary to\nrecombine the secret OPRF key*, and only then be able to* run an offline\ndictionary attack.\n\nYou may or may not comment also in the following point:\nIf the OPRF servers are separate from the authentication server then\nfinding all n shares still does not help since you cannot run the dictionary\nattack without the server's database.\n\nOn Wed, Mar 22, 2023 at 8:54\u202fAM Christopher Wood ***@***.***>\nwrote:\n\n> Merged #397 <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/397>\n> into master.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/397#event-8816475276>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXUDEXDKNEKVVDJLVSLW5LZAFANCNFSM6AAAAAAVUL6DIA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-03-22T18:55:05Z",
          "updatedAt": "2023-03-22T18:55:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5PmOsZ",
          "commit": {
            "abbreviatedOid": "4b23fa0"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:41:34Z",
          "updatedAt": "2023-03-10T18:43:33Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "`out of scope of this document` -> `out of scope for this document`",
              "createdAt": "2023-03-10T18:41:34Z",
              "updatedAt": "2023-03-10T18:43:33Z"
            },
            {
              "originalPosition": 16,
              "body": "Can we keep it still as just one sentence?\r\n\r\n`...servers are compromised {{JKX18}}. The details...`\r\n\r\n-> \r\n\r\n`...servers are compromised {{JKX18}}, but the details...`",
              "createdAt": "2023-03-10T18:42:40Z",
              "updatedAt": "2023-03-10T18:43:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PoniA",
          "commit": {
            "abbreviatedOid": "4b23fa0"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-12T16:01:32Z",
          "updatedAt": "2023-03-12T16:01:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Sure",
              "createdAt": "2023-03-12T16:01:32Z",
              "updatedAt": "2023-03-12T16:01:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Ponkt",
          "commit": {
            "abbreviatedOid": "4b23fa0"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-12T16:02:43Z",
          "updatedAt": "2023-03-12T16:02:43Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\ud83d\udc4d ",
              "createdAt": "2023-03-12T16:02:43Z",
              "updatedAt": "2023-03-12T16:02:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PsX0t",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-13T13:17:22Z",
          "updatedAt": "2023-03-13T13:17:27Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Since threshold OPAQUE is out of scope and, as far as I know, would require protocol changes, I would just remove this entire sentence (\"(OPAQUE enables ... compromised {{JKX18}}.)\") from the document.",
              "createdAt": "2023-03-13T13:17:23Z",
              "updatedAt": "2023-03-13T13:17:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PshwU",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T13:38:32Z",
          "updatedAt": "2023-03-13T13:38:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "that depends on how you define protocol changes, yes a parameter to oprf_finalize would be larger (since it contains the blinded/evaluated shares that need to be combined before unblinding) but besides that the only thing that needs change is oprf_evaluate which acts as a proxy to the shareholders. but yeah that still doesn't put threshold in scope of this spec. which is a pity though (same for the oprf spec which lacks threshold variant, and would make this whole thing easier also in opaque). \r\n\r\nanyway i would leave mentioning this mitigation in here but declare it out of scope for this spec.",
              "createdAt": "2023-03-13T13:38:32Z",
              "updatedAt": "2023-03-13T13:38:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Psit9",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T13:40:14Z",
          "updatedAt": "2023-03-13T13:40:15Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Minimally, clients would need to be aware of the different threshold servers and then generate messages for each. Right now, there is exactly one server in the protocol, and doing anything different seems like it would pretty clearly require a change.",
              "createdAt": "2023-03-13T13:40:14Z",
              "updatedAt": "2023-03-13T13:40:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Ps_2a",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:32:25Z",
          "updatedAt": "2023-03-13T14:32:25Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "oh, actually! no, it is possible to do everything in oprf_evaluate! and nothing in the oprf_evaluate fn params would change, oprf_evaluate would simply act as a proxy that distributes the evaluation among the shareholders and then combines the result and returns that as the result of oprf_evaluate. from the opaque perspective this would be completely \"opaque\" and noone would have any idea if the oprf output is a threshold or non-threshold version. yes, of course oprf_evaluate would need to know about the shareholders and the threshold. but that is an oprf_evaluate internal setting and can be totally ignored by opaque.",
              "createdAt": "2023-03-13T14:32:25Z",
              "updatedAt": "2023-03-13T14:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtA6b",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:34:11Z",
          "updatedAt": "2023-03-13T14:34:11Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "i will implement this asap!",
              "createdAt": "2023-03-13T14:34:11Z",
              "updatedAt": "2023-03-13T14:34:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtBKB",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:34:41Z",
          "updatedAt": "2023-03-13T14:34:41Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "That sort of deployment is indeed possible, but I don't think it faithfully captures the intent of the paper here. The proxy server can still be compromised, such as a single server could, to make everything fall apart. I claim that \"true\" benefits to adding threshold support only come if the client is actually a participant in that protocol.",
              "createdAt": "2023-03-13T14:34:41Z",
              "updatedAt": "2023-03-13T14:34:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtBR0",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:34:56Z",
          "updatedAt": "2023-03-13T14:34:56Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "and i'm sure i will still satisfy the testvectors and will not have to change anything except for oprf_evaluate!\r\n",
              "createdAt": "2023-03-13T14:34:56Z",
              "updatedAt": "2023-03-13T14:34:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtBu_",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:35:50Z",
          "updatedAt": "2023-03-13T14:35:51Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@stef see above -- I suspect we have different mental models for how one might use a threshold OPRF here.",
              "createdAt": "2023-03-13T14:35:50Z",
              "updatedAt": "2023-03-13T14:35:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtB9v",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:36:16Z",
          "updatedAt": "2023-03-13T14:36:16Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "btw i don't think it is necessary to use a dkg for generating the oprf key, it is enough to just have the key generated by the opaque server and have it distributed, ok, that would be another change in the protocol, during registration. but again, not in opaque itself, but in the oprf implementation.",
              "createdAt": "2023-03-13T14:36:16Z",
              "updatedAt": "2023-03-13T14:36:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtHGH",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:42:35Z",
          "updatedAt": "2023-03-13T14:42:36Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "~> That sort of deployment is indeed possible, but I don't think it faithfully captures the intent of the paper here. The proxy server can still be compromised, such as a single server could, to make everything fall apart. I claim that \"true\" benefits to adding threshold support only come if the client is actually a participant in that protocol.~\r\n\r\n~hmmm right, if the opaque server and the threshold-oprf shareholder servers are all under the control of the attacker then this:~\r\n\r\n~> server can run an exhaustive offline dictionary attack to validate guesses for the client's\r\npassword~\r\n\r\n~will still work. but if the oprf shareholders are not under the attackers control, then it is a mitigation.~\r\n\r\n~but then the other solution where the combination of the shares happens in oprf_finalize also makes no difference even though it happens at the client, since that can be also faked by the offline bruteforcing server.~",
              "createdAt": "2023-03-13T14:42:35Z",
              "updatedAt": "2023-03-13T15:24:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtJ8W",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T14:46:15Z",
          "updatedAt": "2023-03-13T14:46:16Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "~ok, ok, i'm holding my horses. but now i wanna know how to do this to claim the true benefits of a toprf. @hugokraw can you enlighten us please?~",
              "createdAt": "2023-03-13T14:46:15Z",
              "updatedAt": "2023-03-13T15:24:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtV_J",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T15:01:09Z",
          "updatedAt": "2023-03-13T15:01:10Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "hmmm, actually reading the paper:\r\n\r\n> Threshold implementation. We comment on a simple extension of OPAQUE\r\n> that can be very valuable in large deployments, namely, the ability to implement\r\n> the OPRF phase as a Threshold OPRF [28]. In this case, an attacker needs to\r\n> break into a threshold of servers to be able to impersonate the servers to the user\r\n> or to run an offline dictionary attack. Such an implementation requires no user-\r\n> side changes, i.e., the user does not need to know if the system is implemented\r\n> with one or multiple servers.\r\n\r\nthis refers to:\r\nS. Jarecki, A. Kiayias, H. Krawczyk, and J. Xu. TOPPSS: Cost-minimal password-protected secret sharing  based on threshold OPRF. In Applied Cryptology and Network Security \u2013 ACNS 2017, pages 39\u201358. Springer, 2017.\r\n\r\nwhich says this:\r\n\r\n> This contribution is based on the observation that a more efficient PPSS can result from replacing the  OPRF used in the protocols of [18,19] with its threshold (or multi-party) counterpart which we define as Threshold OPRF (T-OPRF).\r\n",
              "createdAt": "2023-03-13T15:01:09Z",
              "updatedAt": "2023-03-13T15:01:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PtZ4n",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T15:07:31Z",
          "updatedAt": "2023-03-13T15:07:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "i'm stupid:\r\n\r\n> if the opaque server and the threshold-oprf shareholder servers are all under the control of the attacker then this\r\n\r\nis counter to the whole idea of a threshold system. if we give all the shares to the same shareholder, then why do we split up the secret in the first place.\r\n\r\nso i guess this toprf proxy based solution is the mitigation against server offline bruteforce attacks that Hugo et al were alluding to.\r\n\r\ni guess i'm going to implement this anyhow.",
              "createdAt": "2023-03-13T15:07:31Z",
              "updatedAt": "2023-03-13T15:07:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5PwEw7",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:47:37Z",
          "updatedAt": "2023-03-13T21:47:38Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "i just figured if we don't trust the opaque server then a dkg is necessary.",
              "createdAt": "2023-03-13T21:47:37Z",
              "updatedAt": "2023-03-13T21:47:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QQ8LI",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-17T19:51:39Z",
          "updatedAt": "2023-03-17T19:51:40Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@chris-wood I understand your point, but I advocate for still mentioning it since the paper talks about it.\r\n\r\nThe current phrase can be misleading, so I suggest adding to `10.1. Notable Design Differences` that this spec does not consider thresholding. What do you think?\r\n",
              "createdAt": "2023-03-17T19:51:39Z",
              "updatedAt": "2023-03-17T19:51:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QSZ4l",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-18T13:36:38Z",
          "updatedAt": "2023-03-18T13:36:38Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I'd be OK mentioning it in the notable design differences section.",
              "createdAt": "2023-03-18T13:36:38Z",
              "updatedAt": "2023-03-18T13:36:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qew_a",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T11:40:36Z",
          "updatedAt": "2023-03-21T11:40:36Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@bytemare will you be able to update this text? ",
              "createdAt": "2023-03-21T11:40:36Z",
              "updatedAt": "2023-03-21T11:40:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QjgiG",
          "commit": {
            "abbreviatedOid": "ca3f005"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T22:41:30Z",
          "updatedAt": "2023-03-21T22:41:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Please let me know what you think :) ",
              "createdAt": "2023-03-21T22:41:30Z",
              "updatedAt": "2023-03-21T22:41:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qjgxv",
          "commit": {
            "abbreviatedOid": "c625eff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-21T22:42:51Z",
          "updatedAt": "2023-03-21T22:43:27Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\n  the OPRF phase as a Threshold OPRF {{TOPPSS}}, effectively forcing an\r\n```",
              "createdAt": "2023-03-21T22:42:51Z",
              "updatedAt": "2023-03-21T22:43:27Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n  attacker to act online or to control at least t key shares, where t is the threshold\r\n  number of shares necessary to recombine the secret OPRF key. This implementation\r\n```",
              "createdAt": "2023-03-21T22:43:19Z",
              "updatedAt": "2023-03-21T22:43:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qjot_",
          "commit": {
            "abbreviatedOid": "c625eff"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T23:25:54Z",
          "updatedAt": "2023-03-21T23:25:54Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "not only on server compromise, but also the server itself it is more than honest-but-curious.",
              "createdAt": "2023-03-21T23:25:54Z",
              "updatedAt": "2023-03-21T23:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qjv8y",
          "commit": {
            "abbreviatedOid": "c625eff"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-22T00:11:47Z",
          "updatedAt": "2023-03-22T00:11:47Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Thanks!",
              "createdAt": "2023-03-22T00:11:47Z",
              "updatedAt": "2023-03-22T00:11:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qjx4C",
          "commit": {
            "abbreviatedOid": "df5bc77"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-22T00:25:16Z",
          "updatedAt": "2023-03-22T00:25:16Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "excuses! i was confusing when i wrote \r\n> more than honest-but-curious\r\n\r\nwhich i intended to mean that the server is more \"evil\" than honest-but-curious. i guess, a better phrase would've been to just say: maliciuos. not sure if this really makes any difference, but in my understanding there is two cases: 1/ the server is compromised by an outside attacker who has then access to all the \"records\" and starts bruteforcing those and 2/ the server is operated by a malicious actor who is bruteforcing records entrusted to it. semantics,  schmemantics, dunno if it is necessary to complicate things in this regard. either way the server is compromised i guess. so let's leave it at that?\r\napologies again for being confusing and causing more work than needed.",
              "createdAt": "2023-03-22T00:25:16Z",
              "updatedAt": "2023-03-22T13:33:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QkHDk",
          "commit": {
            "abbreviatedOid": "df5bc77"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-22T02:45:43Z",
          "updatedAt": "2023-03-22T02:45:54Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "You should say explicitly that reconstructing the key does not represent a break of the system but only the ability to run offline dictionary attacks. That is, to be able to impersonate a user, an attacker needs to break into at least t OPRF servers and then run a dictionary attack against the specific user's password. Even breaking into all servers, still requires an exhaustive offline dictionary attack against the user's password. \r\n(Note to selves: It is a VERY STRONG protection.)",
              "createdAt": "2023-03-22T02:45:43Z",
              "updatedAt": "2023-03-22T02:45:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qnb5q",
          "commit": {
            "abbreviatedOid": "df5bc77"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-22T12:53:55Z",
          "updatedAt": "2023-03-22T12:53:56Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\n  the secret OPRF key and run an offline dictionary attack. This implementation only affects the server and changes\r\n```",
              "createdAt": "2023-03-22T12:53:55Z",
              "updatedAt": "2023-03-22T12:53:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RB19F",
          "commit": {
            "abbreviatedOid": "df5bc77"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-27T16:25:52Z",
          "updatedAt": "2023-03-27T16:25:53Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "No problem :) I totally understand your point. If you find a way to express this clearly please don't hesitate to open a PR!",
              "createdAt": "2023-03-27T16:25:53Z",
              "updatedAt": "2023-03-27T16:25:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 401,
      "id": "PR_kwDOD79ejs5Mf3td",
      "title": "Remove KSF parameters and mention config updates",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/401",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #400\r\nCloses #399 \r\nCloses #398 \r\nCloses #394 \r\nCloses #392",
      "createdAt": "2023-03-20T23:11:55Z",
      "updatedAt": "2023-03-22T12:25:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ac1f7746855cdcdeb42f64256f463a67b94d8fa3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ksf-and-updates",
      "headRefOid": "815634b5984d5a6a6aa12ac1e8bc31fe846ddd2b",
      "closedAt": "2023-03-22T12:25:49Z",
      "mergedAt": "2023-03-22T12:25:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a6be0e9cabe5a3cc22363d59ee4864f8188ebc0a"
      },
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This doesn't address the issue in #400 and only partially addresses #398 (by removing `params`):\r\nthe question of what size of salt to use. Specifically to either use none if allowed by the spec or to use all zeroes.",
          "createdAt": "2023-03-21T12:02:41Z",
          "updatedAt": "2023-03-21T12:02:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The point of this change is that the choice of KSF parameters is _entirely up the application_. It is not something that OPAQUE specifies. Thus, I believe it addresses all the issues referenced.",
          "createdAt": "2023-03-21T12:05:59Z",
          "updatedAt": "2023-03-21T12:05:59Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with that approach, imo OPAQUE should not deal with KSF parameters.\r\n\r\nBut there is a problem we might want to address one way or another: currently there is no consensus on the salt issue and it will eventually lead to incompatible implementations (e.g. https://github.com/facebook/opaque-ke/pull/275).\r\n\r\nIt would help to add a note just saying what to do here, which is actually still unclear. If I had nothing else but the spec to go by, I would not use a salt at all, which no implementation I know of does.\r\n\r\nIf it's still decided that we don't want to mention a salt at all in the spec, I would suggest an alternative solution. Currently Argon2 is the recommended algorithm, like the other recommended algorithms (P-*, Ristretto255), maybe adding test vectors would help. This was requested in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/399, I assume the idea was rejected because we don't want to make it look like specific KSF parameters are suggested?",
          "createdAt": "2023-03-21T12:15:22Z",
          "updatedAt": "2023-03-21T12:16:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> But there is a problem we might want to address one way or another: currently there is no consensus on the salt issue and it will eventually lead to incompatible implementations (e.g. https://github.com/facebook/opaque-ke/pull/275).\r\n\r\nThis isn't a problem for OPAQUE to solve -- it's a problem for applications using OPAQUE to solve. \r\n\r\n> It would help to add a note just saying what to do here, which is actually still unclear. If I had nothing else but the spec to go by, I would not use a salt at all, which no implementation I know of does.\r\n> \r\n> If it's still decided that we don't want to mention a salt at all in the spec, I would suggest an alternative solution. Currently Argon2 is the recommended algorithm, like the other recommended algorithms (P-*, Ristretto255), maybe adding test vectors would help. This was requested in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/399, I assume the idea was rejected because we don't want to make it look like specific KSF parameters are suggested?\r\n\r\nWe didn't add test vectors for argon2id because it would have made the test vectors more expensive to run.\r\n\r\nThat said, I do now see your point that the recommended configuration for Argon2id is _under specified_ in the configuration section. It doesn't say, for example, what the output length should be, what the salt should be, etc. I think we can address that with some additional text. Stay tuned.",
          "createdAt": "2023-03-21T12:31:39Z",
          "updatedAt": "2023-03-21T12:31:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I believe the latest change addresses the concerns, and I believe it matches that which @kevinlewi implemented in `opaque-ke`. @kevinlewi, can you please confirm? I had to dig into the argon2 crate to see what the output tag length was, and it appears to be 32 bytes by default. ",
          "createdAt": "2023-03-21T12:45:22Z",
          "updatedAt": "2023-03-21T12:45:22Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In `opaque-ke` the output size is determined by the input size, which is the output size of the hash function used in the OPRF. So `Nh`, according to the spec.\r\n\r\nI was wondering how that happened, but I found other implementations which did the same: [stef's implementation](https://github.com/stef/libopaque/blob/3ff26cd7fd5fa618361c33cf0c0c7e563a252a71/src/opaque.c#L208-L212), for example, did this too.\r\n\r\nThis is another point implementations have silently agreed on without the specification. This problem seems to get bigger as we go :laughing:.\r\n\r\nI have to say that personally I don't have a stake in this, my use-cases don't require compatibility between multiple implementations, I'm using the same on both sides. Maybe somebody else with an actual stake in this will have more to say.",
          "createdAt": "2023-03-21T13:21:28Z",
          "updatedAt": "2023-03-21T13:21:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not really sure I understand why we're nit picking the exact values here. At the end of the day, these are not something OPAQUE mandates, and so applications can choose whatever they want. ",
          "createdAt": "2023-03-21T13:37:33Z",
          "updatedAt": "2023-03-21T13:37:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To hopefully avoid further nit picks, I just made the output length be `Nh` and set associated data to `nil`. ",
          "createdAt": "2023-03-21T13:39:13Z",
          "updatedAt": "2023-03-21T13:39:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5QcBlW",
          "commit": {
            "abbreviatedOid": "172a962"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-20T23:18:59Z",
          "updatedAt": "2023-03-20T23:18:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5QfmyN",
          "commit": {
            "abbreviatedOid": "eb8ab06"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T13:27:30Z",
          "updatedAt": "2023-03-21T13:27:31Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "That would add another point: associated data.",
              "createdAt": "2023-03-21T13:27:30Z",
              "updatedAt": "2023-03-21T13:27:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qfoqk",
          "commit": {
            "abbreviatedOid": "eb8ab06"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T13:30:07Z",
          "updatedAt": "2023-03-21T13:30:07Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "X is the associated data here.",
              "createdAt": "2023-03-21T13:30:07Z",
              "updatedAt": "2023-03-21T13:30:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QfrmC",
          "commit": {
            "abbreviatedOid": "eb8ab06"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T13:35:11Z",
          "updatedAt": "2023-03-21T13:35:11Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Yes, what I meant to say is that this would add another parameter that is not specified by the spec which will have to be silently agreed on to make implementations compatible.\r\n\r\nBasically, until now associated data was left empty (I didn't check more implementations, but kevinlewi's and stef's is empty), now, implementations will probably use `RFCXXXX` as their associated data for all KSF's, even though the spec doesn't say you should do that.",
              "createdAt": "2023-03-21T13:35:11Z",
              "updatedAt": "2023-03-21T13:35:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QjsIn",
          "commit": {
            "abbreviatedOid": "815634b"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T23:45:46Z",
          "updatedAt": "2023-03-21T23:45:47Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "~May I suggest to use argon2id but with short `m`, for example instead `m = 2^21` set `m=8`.~\r\nI mean, any parametrization for argon makes sense, provided that the test vectors cover the argon function, instead of using Identity.",
              "createdAt": "2023-03-21T23:45:46Z",
              "updatedAt": "2023-03-21T23:47:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QlIek",
          "commit": {
            "abbreviatedOid": "815634b"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry for the delays in getting to this review, but overall looks good to me!\r\n\r\nAlthough I am probably just reiterating @chris-wood's points: I think that aligning implementations on the usage of OPAQUE with specific key stretching functions is outside of the scope of this spec.\r\n\r\nThis applies to mentioning anything about KSF salt length (for example), which some applications that use OPAQUE may want to align on... but I see as still being outside of the spec scope.",
          "createdAt": "2023-03-22T08:01:41Z",
          "updatedAt": "2023-03-22T08:01:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 402,
      "id": "PR_kwDOD79ejs5MicMJ",
      "title": "Registration requires integrity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/402",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #393\r\n\r\n@hugokraw -- can you please confirm this is correct?",
      "createdAt": "2023-03-21T11:59:41Z",
      "updatedAt": "2023-03-22T12:25:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ac1f7746855cdcdeb42f64256f463a67b94d8fa3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "chris-wood-patch-1",
      "headRefOid": "77bcd4a2c64a446a387a3b53f133950323a8b466",
      "closedAt": "2023-03-22T12:25:10Z",
      "mergedAt": "2023-03-22T12:25:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8d0136241921462eebc08547b0f43dc6d93ca248"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @hugokraw! There was one other generic use of confidentiality that I corrected to also note integrity needs.",
          "createdAt": "2023-03-21T15:22:43Z",
          "updatedAt": "2023-03-21T15:22:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5Qgf0P",
          "commit": {
            "abbreviatedOid": "61fcbb7"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Yes, integrity is needed. In an active  man-in-the-middle scenario there is no confidentiality without integrity (in the sense of confidentiality = authenticated encryption). If we use confidentiality (generically rather than with an explicitly defined mechanism) elsewhere, it needs to be understood as including integrity or as \"authenticated encryption\".",
          "createdAt": "2023-03-21T14:59:38Z",
          "updatedAt": "2023-03-21T14:59:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5QjZMU",
          "commit": {
            "abbreviatedOid": "77bcd4a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-21T22:08:10Z",
          "updatedAt": "2023-03-21T22:08:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5Qk_O6",
          "commit": {
            "abbreviatedOid": "77bcd4a"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-22T07:34:58Z",
          "updatedAt": "2023-03-22T07:34:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 403,
      "id": "PR_kwDOD79ejs5Mifhz",
      "title": "Remove unused ristretto implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/403",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We pull in the ristretto implementation from the dependent libraries.",
      "createdAt": "2023-03-21T12:07:22Z",
      "updatedAt": "2023-03-22T12:25:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ac1f7746855cdcdeb42f64256f463a67b94d8fa3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-unused-ristretto",
      "headRefOid": "201a74077b77129e216ce5817fa80e3224ed25ed",
      "closedAt": "2023-03-22T12:25:26Z",
      "mergedAt": "2023-03-22T12:25:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2b2a15e06d3ca4a48325d5f225e2c4c7725b6cc0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 404,
      "id": "PR_kwDOD79ejs5MkQmY",
      "title": "Add x25519 AKE test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/404",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This did introduce some editorial changes to accommodate the x25519 AKE, but I don't think they're unreasonable. The actual reference implementation needs to be cleaned up somewhat, but I think we can at least use this to test for interop for the time being. I'll work on cleaning up the code in a bit, so, starting as a draft now.\r\n\r\nCloses #238\r\n\r\ncc @daxpedda ",
      "createdAt": "2023-03-21T16:32:19Z",
      "updatedAt": "2023-05-22T19:52:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7b23be528bee6332cb268803db4d9c502755e4e0",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/x25519-vectors",
      "headRefOid": "7360d5754cf6c2dcbeacbdeb4f0d6e33a39bfb91",
      "closedAt": "2023-05-22T19:52:37Z",
      "mergedAt": "2023-05-22T19:52:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "727b9acb908dce296e15bc14a53a7d04ba9604d0"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "lgtm. thank you for this effort!",
          "createdAt": "2023-03-21T16:40:57Z",
          "updatedAt": "2023-03-21T16:40:57Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's pretty amazing @chris-wood! :tada:\r\n\r\nGonna report back as soon as I figure out why I couldn't make them work in `opaque-ke`.",
          "createdAt": "2023-03-21T23:43:03Z",
          "updatedAt": "2023-03-21T23:43:03Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just to be clear, this effort is about\r\na) instantiating a 3DH with X25519 (a.k.a RFC7748), or \r\nb) using the prime subgroup of Curve25519, (just like the NIST PXXX curves).\r\nor something else?",
          "createdAt": "2023-03-21T23:51:28Z",
          "updatedAt": "2023-03-21T23:51:28Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/404/commits/0253cbb7f78a0b56fd183895556828da832aed74 updated the `draft-irtf-cfrg-opaque.md` but not the other files, I am assuming the new ones are correct?",
          "createdAt": "2023-03-22T16:36:05Z",
          "updatedAt": "2023-03-22T16:36:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> just to be clear, this effort is about\n> \n> a) instantiating a 3DH with X25519 (a.k.a RFC7748), or \n> \n> b) using the prime subgroup of Curve25519, (just like the NIST PXXX curves).\n> \n> or something else?\n\n@armfazh it's about option (a) =)",
          "createdAt": "2023-03-22T16:41:45Z",
          "updatedAt": "2023-03-22T16:41:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> [0253cbb](https://github.com/cfrg/draft-irtf-cfrg-opaque/commit/0253cbb7f78a0b56fd183895556828da832aed74) updated the `draft-irtf-cfrg-opaque.md` but not the other files, I am assuming the new ones are correct?\r\n\r\n@daxpedda I added clamping and updated the vectors in the latest commit.\r\n\r\n@kevinlewi, @daxpedda: I'm going to promote this draft to a real PR now. I think it's ready to go. ",
          "createdAt": "2023-03-23T15:29:37Z",
          "updatedAt": "2023-03-23T15:29:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare can you please take another look?",
          "createdAt": "2023-03-23T15:30:29Z",
          "updatedAt": "2023-03-23T15:30:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Spec changes:\r\n- Renamed \"ScalarMult(k, B)\" to \"DiffieHellman(k, B)\" to more accurately reflect that we are doing a DH operation in the places where it is mentioned in the spec\r\n- Renamed the group's display name from \"x25519\" to \"curve25519\" in the test vectors\r\n- Synced latest test vectors into spec\r\n\r\nSage POC code changes:\r\n- Fixed clamping issue\r\n- Added test to ensure that private key outputs for curve25519 are always clamped\r\n- Added back `client_public_keyshare` into the inputs for each test vector (was mistakenly removed in #404)",
          "createdAt": "2023-05-21T05:52:55Z",
          "updatedAt": "2023-05-22T00:33:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5QjH2I",
          "commit": {
            "abbreviatedOid": "13e681f"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-21T21:07:21Z",
          "updatedAt": "2023-03-21T21:16:12Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "This function also puts out the public key",
              "createdAt": "2023-03-21T21:07:21Z",
              "updatedAt": "2023-03-21T21:16:12Z"
            },
            {
              "originalPosition": 97,
              "body": "I'm not sure why that phrase is here",
              "createdAt": "2023-03-21T21:09:45Z",
              "updatedAt": "2023-03-21T21:16:12Z"
            },
            {
              "originalPosition": 65,
              "body": "Do we need this?",
              "createdAt": "2023-03-21T21:11:10Z",
              "updatedAt": "2023-03-21T21:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QjTMa",
          "commit": {
            "abbreviatedOid": "13e681f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T21:46:38Z",
          "updatedAt": "2023-03-21T21:46:39Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Nope -- removed!",
              "createdAt": "2023-03-21T21:46:38Z",
              "updatedAt": "2023-03-21T21:46:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QjTN_",
          "commit": {
            "abbreviatedOid": "13e681f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T21:46:44Z",
          "updatedAt": "2023-03-21T21:46:44Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Leftover. Removed.",
              "createdAt": "2023-03-21T21:46:44Z",
              "updatedAt": "2023-03-21T21:46:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QjTQq",
          "commit": {
            "abbreviatedOid": "13e681f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T21:46:50Z",
          "updatedAt": "2023-03-21T21:46:51Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Yep, fixed!",
              "createdAt": "2023-03-21T21:46:51Z",
              "updatedAt": "2023-03-21T21:46:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QpLyo",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-22T15:59:28Z",
          "updatedAt": "2023-03-22T15:59:29Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Why does this differ from the other groups?\r\nBecause OPRF doesn't specify a ciphersuite for Curve25519?",
              "createdAt": "2023-03-22T15:59:28Z",
              "updatedAt": "2023-03-22T15:59:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5QpMJ_",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-22T16:00:10Z",
          "updatedAt": "2023-03-22T16:00:10Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Yeah, exactly. ",
              "createdAt": "2023-03-22T16:00:10Z",
              "updatedAt": "2023-03-22T16:00:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qr3pl",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-23T00:46:43Z",
          "updatedAt": "2023-03-23T00:46:44Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "@chris-wood: This needs to apply the clamping operations to the scalar, otherwise it can generate an invalid X25519 private key\r\n\r\n```\r\nkey[0] &= 248;\r\nkey[31] &= 127;\r\nkey[31] |= 64;\r\n```\r\n\r\ncc: @daxpedda ",
              "createdAt": "2023-03-23T00:46:43Z",
              "updatedAt": "2023-03-23T00:47:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Qr4dV",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-23T00:52:37Z",
          "updatedAt": "2023-03-23T00:52:37Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Aha! Good catch. ",
              "createdAt": "2023-03-23T00:52:37Z",
              "updatedAt": "2023-03-23T00:52:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Q53S1",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-24T19:56:13Z",
          "updatedAt": "2023-03-24T19:56:13Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "After consulting the spec again, I couldn't really find an answer to this. Doesn't removing the `G.HashToScalar` have any security implications at all?\r\nAnd if not, why is it in place for the other ciphersuites?",
              "createdAt": "2023-03-24T19:56:13Z",
              "updatedAt": "2023-03-24T19:56:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Q77jE",
          "commit": {
            "abbreviatedOid": "05bf31e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-25T19:24:09Z",
          "updatedAt": "2023-03-25T19:24:09Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "I'm not sure I understand the question. But to try and reiterate, there was no existing function in the OPRF document we could point to, which is why we just lean on standard key generation for curve25519 -- treat random bytes as the key (scalar).",
              "createdAt": "2023-03-25T19:24:09Z",
              "updatedAt": "2023-03-25T19:24:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Q7_pD",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-25T21:32:26Z",
          "updatedAt": "2023-03-25T21:32:26Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Ah, sorry, I can see how my question is confusing. So in `opaque-ke` we were using OPRF with a custom ciphersuite when chossing Curve25519, which was possible because the hash2curve specification does provide a ciphersuite for Curve25519.\r\n\r\nSo my question is: the other ciphersuites do use OPRF to derive a key pair in `DeriveAuthKeyPair`. So why do other ciphersuites need that but Curve25519 doesn't? I thought it was necessary for security reasons (that I have no clue about).",
              "createdAt": "2023-03-25T21:32:26Z",
              "updatedAt": "2023-05-19T11:41:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Q8B0B",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-25T23:01:17Z",
          "updatedAt": "2023-03-25T23:01:17Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Oh, I see! You're asking if it's necessary to map the input seed to a scalar using something like a random oracle? I don't _think_ it's necessary, but I actually don't know the answer off the top of my head. I think this should probably be asked on the list (I can do that).",
              "createdAt": "2023-03-25T23:01:17Z",
              "updatedAt": "2023-03-25T23:01:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Q8B4T",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-25T23:05:40Z",
          "updatedAt": "2023-03-25T23:05:40Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Thank you!",
              "createdAt": "2023-03-25T23:05:40Z",
              "updatedAt": "2023-03-25T23:05:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Ri80n",
          "commit": {
            "abbreviatedOid": "05bf31e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-02T17:19:15Z",
          "updatedAt": "2023-04-02T17:19:16Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Sorry @chris-wood, I think actually the previous configuration was correct. In RFC 7748 it is done correctly. If we can copy these lines over to the scalar generation code, we should be good.",
              "createdAt": "2023-04-02T17:19:15Z",
              "updatedAt": "2023-04-02T17:19:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Ri82e",
          "commit": {
            "abbreviatedOid": "2ecb706"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-02T17:20:16Z",
          "updatedAt": "2023-04-02T17:20:16Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Let's revert to:\r\n\r\n    key[0] &= 248\r\n    key[31] &= 127\r\n    key[31] |= 64\r\n \r\n as was originally suggested. Sorry for the confusion!",
              "createdAt": "2023-04-02T17:20:16Z",
              "updatedAt": "2023-04-02T17:20:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RjZHG",
          "commit": {
            "abbreviatedOid": "05bf31e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-03T03:04:53Z",
          "updatedAt": "2023-04-03T03:08:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@chris-wood Additionally, I believe we need to make sure that `seed` is clamped here, before using it. Otherwise, the private key that we generate will not be clamped (since it just equal to the seed).",
              "createdAt": "2023-04-03T03:04:53Z",
              "updatedAt": "2023-04-03T03:08:36Z"
            },
            {
              "originalPosition": 10,
              "body": "This should say `Group: curve25519`",
              "createdAt": "2023-04-03T03:08:32Z",
              "updatedAt": "2023-04-03T03:08:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RjZma",
          "commit": {
            "abbreviatedOid": "05bf31e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Based on above comments. Maybe it would be helpful to add a test to check that all private keys / scalars that we publish in the test vectors are actually clamped?",
          "createdAt": "2023-04-03T03:09:12Z",
          "updatedAt": "2023-04-03T03:16:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5Vq0PY",
          "commit": {
            "abbreviatedOid": "a55d914"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is approved by me in case it wasn't clear :P ",
          "createdAt": "2023-05-22T19:09:57Z",
          "updatedAt": "2023-05-22T19:09:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 405,
      "id": "PR_kwDOD79ejs5MmBXt",
      "title": "Return client pk in Recovery functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/405",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #384.",
      "createdAt": "2023-03-21T23:20:22Z",
      "updatedAt": "2023-04-03T09:08:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ac1f7746855cdcdeb42f64256f463a67b94d8fa3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/return-client-pku",
      "headRefOid": "031a3235453a3e5296ac43a352ab6d111d381505",
      "closedAt": "2023-03-27T00:12:11Z",
      "mergedAt": "2023-03-27T00:12:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "617acb37dd62fe79ac15f89c733a27b4a363bc17"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "At this point I'm wondering whether we should not simply bubble up the `cleartext_creds` from `Recover()` up to `ClientFinish()` and feed it to `AuthClientFinalize()` to avoid input arguments comments like\r\n\r\n> the optional encoded xyyz identity, which is set to xyz_public_key if not specified.",
          "createdAt": "2023-03-21T23:40:28Z",
          "updatedAt": "2023-03-21T23:40:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At this point I'm wondering whether we should not simply bubble up the cleartext_creds from Recover() up to ClientFinish() and feed it to AuthClientFinalize() to avoid input arguments comments like\r\n\r\nMaybe! Would you be willing to draft a change so we can see what this looks like?",
          "createdAt": "2023-03-21T23:43:01Z",
          "updatedAt": "2023-03-21T23:43:01Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood here's what it looks like with cleartext_credentials. It's cleaner, I think\r\n\r\nRegarding the implementation, I think we should adapt, yes",
          "createdAt": "2023-03-21T23:57:32Z",
          "updatedAt": "2023-03-21T23:57:32Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "@caw done :) ",
          "createdAt": "2023-03-26T16:45:08Z",
          "updatedAt": "2023-03-26T16:45:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5Qjrk2",
          "commit": {
            "abbreviatedOid": "a4fcbbb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Should we also update the reference implementation to match?",
          "createdAt": "2023-03-21T23:42:13Z",
          "updatedAt": "2023-03-21T23:42:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5Q4nSH",
          "commit": {
            "abbreviatedOid": "63fe27b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is so much cleaner! Let's update the implementation to match.",
          "createdAt": "2023-03-24T16:06:28Z",
          "updatedAt": "2023-03-24T16:06:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5Q8_fm",
          "commit": {
            "abbreviatedOid": "031a323"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-27T00:12:06Z",
          "updatedAt": "2023-03-27T00:12:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 407,
      "id": "PR_kwDOD79ejs5M66VD",
      "title": "Clean-up and rename some things",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/407",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #406 ",
      "createdAt": "2023-03-26T22:17:31Z",
      "updatedAt": "2023-04-03T09:08:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "52074e81fe24eff96849490c8daecfb2c1c92a51",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/sync-names",
      "headRefOid": "5dd2f8756327a91eefda92715519d0a591cadd00",
      "closedAt": "2023-04-01T23:27:25Z",
      "mergedAt": "2023-04-01T23:27:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7b23be528bee6332cb268803db4d9c502755e4e0"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare unfortunately we now conflict -- can you please rebase?",
          "createdAt": "2023-03-27T00:13:38Z",
          "updatedAt": "2023-03-27T00:13:38Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "I found some things missing in the doc, which I patched using a cleartext_credentials structure.\r\nI modified variable names in the spec and POC so they are uniformly the same and don't leave space for misinterpretation.\r\n\r\n@chris-wood @kevinlewi this is ready for final review :)",
          "createdAt": "2023-03-27T16:14:50Z",
          "updatedAt": "2023-03-27T16:14:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5Q8_ns",
          "commit": {
            "abbreviatedOid": "d22c544"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice cleanup =)",
          "createdAt": "2023-03-27T00:13:23Z",
          "updatedAt": "2023-03-27T00:13:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 408,
      "id": "PR_kwDOD79ejs5M-V2Q",
      "title": "Resolve conflicts",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/408",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-27T14:01:32Z",
      "updatedAt": "2023-03-27T14:06:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "dbz/sync-names",
      "baseRefOid": "d22c544217c702d03a405e28a7ef970571b78616",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/sync-names-rebase",
      "headRefOid": "41e262bb3e55b17eccdf978b96814d9f87e0e681",
      "closedAt": "2023-03-27T14:05:57Z",
      "mergedAt": "2023-03-27T14:05:57Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "a7f3aafea44566f893a63d44cae8657cc35db861"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 409,
      "id": "PR_kwDOD79ejs5M_Th_",
      "title": "Add Hugo's suggestion about Thresholding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In #397 , @hugokraw suggested\r\n\r\n> I suggest the following edit  (marked in italics)\r\n>\r\n> The authors suggest implementing the OPRF phase as a Threshold OPRF\r\n> {{TOPPSS}}, effectively forcing an attacker to act online or to control at\r\n> least t key shares, where t is the threshold number of shares necessary to\r\n> recombine the secret OPRF key*, and only then be able to* run an offline\r\n> dictionary attack.\r\n\r\nThis PR adds this.\r\n\r\nMoreover, he suggested\r\n\r\n> You may or may not comment also in the following point:\r\nIf the OPRF servers are separate from the authentication server then\r\nfinding all n shares still does not help since you cannot run the dictionary\r\nattack without the server's database.\r\n\r\n@hugokraw, do you mean _n_ like in \"all shares that have been created\" or \"a threshold number of shares\"?",
      "createdAt": "2023-03-27T16:33:29Z",
      "updatedAt": "2023-04-03T09:08:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "617acb37dd62fe79ac15f89c733a27b4a363bc17",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/threshold/add-hugos-nits",
      "headRefOid": "a2b155a675c39db990431acfc0972f4572528f22",
      "closedAt": "2023-04-01T23:26:41Z",
      "mergedAt": "2023-04-01T23:26:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "19d54bda09e9eb974c6873934b99767aef62c96c"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I meant *n* like in \"all shares that have been created\" (equivalently, all\nservers through which the OPRF key is shared)\n\nOn Mon, Mar 27, 2023 at 12:33\u202fPM Daniel Bourdrez ***@***.***>\nwrote:\n\n> In #397 <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/397> ,\n> @hugokraw <https://github.com/hugokraw> suggested\n>\n> I suggest the following edit (marked in italics)\n>\n> The authors suggest implementing the OPRF phase as a Threshold OPRF\n> {{TOPPSS}}, effectively forcing an attacker to act online or to control at\n> least t key shares, where t is the threshold number of shares necessary to\n> recombine the secret OPRF key*, and only then be able to* run an offline\n> dictionary attack.\n>\n> This PR adds this.\n>\n> Moreover, he suggested\n>\n> You may or may not comment also in the following point:\n> If the OPRF servers are separate from the authentication server then\n> finding all n shares still does not help since you cannot run the\n> dictionary\n> attack without the server's database.\n>\n> @hugokraw <https://github.com/hugokraw>, do you mean *n* like in \"all\n> shares that have been created\" or \"a threshold number of shares\"?\n> ------------------------------\n> You can view, comment on, or merge this pull request online at:\n>\n>   https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409\n> Commit Summary\n>\n>    - 1c3c477\n>    <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409/commits/1c3c477a075e00f73c95f908f4832695e190e84c>\n>    Add Hugo's suggestion about Thresholding\n>\n> File Changes\n>\n> (1 file <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409/files>)\n>\n>    - *M* draft-irtf-cfrg-opaque.md\n>    <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409/files#diff-09a16f0dd79bfde63faf766f3c58ba43f6795026ce020fa36006cfec7094cf0a>\n>    (7)\n>\n> Patch Links:\n>\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409.patch\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409.diff\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/409>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXU3CU6TWIZH4MJJUXDW6G6OLANCNFSM6AAAAAAWJMCQUA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-03-27T19:40:25Z",
          "updatedAt": "2023-03-27T19:40:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5RbXSw",
          "commit": {
            "abbreviatedOid": "1c3c477"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-31T01:21:36Z",
          "updatedAt": "2023-03-31T01:21:47Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n- {{JKX18}} comments on a defense against offline\r\n  dictionary attacks upon server compromise or honest-but-curious servers.\r\n```",
              "createdAt": "2023-03-31T01:21:36Z",
              "updatedAt": "2023-03-31T01:21:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RiThV",
          "commit": {
            "abbreviatedOid": "2f04dd0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-01T21:53:02Z",
          "updatedAt": "2023-04-01T21:53:46Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\n  attack. This implementation only affects the server and changes nothing for the client.\n```\n",
              "createdAt": "2023-04-01T21:53:02Z",
              "updatedAt": "2023-04-01T21:53:46Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\n  Furthermore, if the threshold OPRF servers holding these keys are separate from\n```\n",
              "createdAt": "2023-04-01T21:53:16Z",
              "updatedAt": "2023-04-01T21:53:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RiTln",
          "commit": {
            "abbreviatedOid": "2f04dd0"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-01T21:57:03Z",
          "updatedAt": "2023-04-01T21:57:03Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "hm, I'm referring to the \"Threshold OPRF {{TOPPSS}}\" some lines above, where I used an uppercase T. Should I add the citation on this line or lowercase the top one?",
              "createdAt": "2023-04-01T21:57:03Z",
              "updatedAt": "2023-04-01T21:57:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RiUop",
          "commit": {
            "abbreviatedOid": "fbffe4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-01T22:25:59Z",
          "updatedAt": "2023-04-01T22:25:59Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think we should use lowercase threshold in both cases. It's just an adjective for the OPRF, not a proper noun.",
              "createdAt": "2023-04-01T22:25:59Z",
              "updatedAt": "2023-04-01T22:25:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RiUtm",
          "commit": {
            "abbreviatedOid": "933aa63"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-01T22:27:53Z",
          "updatedAt": "2023-04-01T22:27:53Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n  The authors suggest implementing the OPRF phase as a threshold OPRF {{TOPPSS}},\r\n```",
              "createdAt": "2023-04-01T22:27:53Z",
              "updatedAt": "2023-04-01T22:27:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RiVMx",
          "commit": {
            "abbreviatedOid": "2f04dd0"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-01T22:31:34Z",
          "updatedAt": "2023-04-01T22:31:35Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I committed the change, but then re-checked [in the Paper](https://eprint.iacr.org/2017/363.pdf), where they say \"which we define as Threshold OPRF (T-OPRF)\". I believe we should use uppercase to stick to the language used by the paper we're referring to",
              "createdAt": "2023-04-01T22:31:34Z",
              "updatedAt": "2023-04-01T22:31:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5RihmX",
          "commit": {
            "abbreviatedOid": "a2b155a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-02T01:19:33Z",
          "updatedAt": "2023-04-02T01:19:33Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I don't really agree. Again, there is not just one Threshold OPRF, there can be many, so I'm going to fix this up on main.",
              "createdAt": "2023-04-02T01:19:33Z",
              "updatedAt": "2023-04-02T01:19:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Rihvr",
          "commit": {
            "abbreviatedOid": "2f04dd0"
          },
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-02T01:25:57Z",
          "updatedAt": "2023-04-02T01:25:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "the paper calls it 2HashTDH, later papers call it tdh-op.",
              "createdAt": "2023-04-02T01:25:57Z",
              "updatedAt": "2023-04-02T01:25:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Rihxn",
          "commit": {
            "abbreviatedOid": "a2b155a"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-02T01:27:58Z",
          "updatedAt": "2023-04-02T01:27:58Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "True, you're certainly right ",
              "createdAt": "2023-04-02T01:27:58Z",
              "updatedAt": "2023-04-02T01:27:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 411,
      "id": "PR_kwDOD79ejs5RCsXg",
      "title": "More cleanup to go with x25519 vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/411",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change cleans up some more stuff in the implementation and spec, fixing some errors along the way.",
      "createdAt": "2023-05-22T17:48:38Z",
      "updatedAt": "2023-05-22T19:51:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "caw/x25519-vectors",
      "baseRefOid": "a55d914a5207c6490de54c14cf6be59bf7f8bfd3",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/x25519-cleanup",
      "headRefOid": "cea59e5e4438d401ea89ea6197a1b74fb3728f43",
      "closedAt": "2023-05-22T19:51:55Z",
      "mergedAt": "2023-05-22T19:51:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7360d5754cf6c2dcbeacbdeb4f0d6e33a39bfb91"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5VqsRy",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "First round of requested changes, mainly looking to make sure that we keep parity with the name changes in the spec and the sage code",
          "createdAt": "2023-05-22T18:51:21Z",
          "updatedAt": "2023-05-22T19:08:50Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "Was this an intended change?",
              "createdAt": "2023-05-22T18:51:21Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 41,
              "body": "nit: Can you change the anchor to be {#3dh-protocol}? And change wherever it is referenced as well?",
              "createdAt": "2023-05-22T18:53:21Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 50,
              "body": "nit: Can you change the anchor to be {#3dh-primitives}? And change wherever it is referenced as well?",
              "createdAt": "2023-05-22T18:53:29Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 53,
              "body": "Diffie Hellman -> Diffie-Hellman",
              "createdAt": "2023-05-22T18:54:02Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 85,
              "body": "I see that we are renaming this, but to be consistent, there are a couple of other places where we would also need to rename this:\r\n1) In the sage code, function names that still say \"derive_auth_key_pair\"\r\n2) The constant string on this next line still says \"OPAQUE-DeriveAuthKeyPair\", which should be updated as well.\r\n\r\nBtw, we are also changing the capitalization format here, from \"KeyPair\" to \"Keypair\", despite this being inconsistent with how the OPRF spec displays it (\"DeriveKeyPair\"). I think we should keep it as KeyPair.\r\n\r\nAlso, consider spelling it out fully: \"DeriveDiffieHellmanKeyPair\", or if that is too long, capitalizating the D but not the H, to be: \"DeriveDhKeyPair\"",
              "createdAt": "2023-05-22T18:57:33Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 81,
              "body": "What is a DH primitive? Should we at least spell this out (\"Diffie Hellman primitive\"). And does this differ from a \"Diffie Hellman group\" as mentioned on line 1407? Maybe if we mean the same thing, we should just be consistent and stick to the same terminology in all places.",
              "createdAt": "2023-05-22T19:00:55Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 106,
              "body": "Same comment here on what is a \"DH primitive\"",
              "createdAt": "2023-05-22T19:01:05Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 131,
              "body": "Same here",
              "createdAt": "2023-05-22T19:01:25Z",
              "updatedAt": "2023-05-22T19:08:50Z"
            },
            {
              "originalPosition": 145,
              "body": "nit: used raw -> used as-is",
              "createdAt": "2023-05-22T19:02:23Z",
              "updatedAt": "2023-05-22T19:08:51Z"
            },
            {
              "originalPosition": 70,
              "body": "Why change the name here from \"DiffieHellman(k, B)\" to \"DH(k, B)\"? The latter feels less descriptive, and I am in favor of keeping it as DiffieHellman unless it conflicts with something else...",
              "createdAt": "2023-05-22T19:03:04Z",
              "updatedAt": "2023-05-22T19:08:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq0n8",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:11:13Z",
          "updatedAt": "2023-05-22T19:11:13Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I had spelled it out fully first, but it was really quite long and I made it short. I don't feel strongly, though.",
              "createdAt": "2023-05-22T19:11:13Z",
              "updatedAt": "2023-05-22T19:11:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq0yV",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:11:48Z",
          "updatedAt": "2023-05-22T19:11:49Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "It's just a name for a thing that has (1) a key derivation function and (2) a DH operation. We can call it whatever we want. Group feels wrong for that name.",
              "createdAt": "2023-05-22T19:11:48Z",
              "updatedAt": "2023-05-22T19:11:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq1Hc",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:12:12Z",
          "updatedAt": "2023-05-22T19:12:13Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "This is copied from RFC8446, so I'm going to leave it as-is. =)",
              "createdAt": "2023-05-22T19:12:13Z",
              "updatedAt": "2023-05-22T19:12:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq1cs",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:12:35Z",
          "updatedAt": "2023-05-22T19:12:35Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "It's a long name? \ud83e\udd37 ",
              "createdAt": "2023-05-22T19:12:35Z",
              "updatedAt": "2023-05-22T19:12:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq2rC",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:14:52Z",
          "updatedAt": "2023-05-22T19:14:53Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "Nope, reverting.",
              "createdAt": "2023-05-22T19:14:52Z",
              "updatedAt": "2023-05-22T19:14:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq4-M",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:19:40Z",
          "updatedAt": "2023-05-22T19:19:40Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Fixed.",
              "createdAt": "2023-05-22T19:19:40Z",
              "updatedAt": "2023-05-22T19:19:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq5Be",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:19:42Z",
          "updatedAt": "2023-05-22T19:19:43Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Fixed.",
              "createdAt": "2023-05-22T19:19:42Z",
              "updatedAt": "2023-05-22T19:19:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq5G2",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:19:46Z",
          "updatedAt": "2023-05-22T19:19:47Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Fixed.",
              "createdAt": "2023-05-22T19:19:46Z",
              "updatedAt": "2023-05-22T19:19:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq5Ot",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:19:52Z",
          "updatedAt": "2023-05-22T19:19:53Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Reverted.",
              "createdAt": "2023-05-22T19:19:52Z",
              "updatedAt": "2023-05-22T19:19:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq5yT",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:20:19Z",
          "updatedAt": "2023-05-22T19:20:19Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Fixed, and changed the domain separation tag in the function to match.",
              "createdAt": "2023-05-22T19:20:19Z",
              "updatedAt": "2023-05-22T19:20:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq5-k",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:20:28Z",
          "updatedAt": "2023-05-22T19:20:28Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Fixed.",
              "createdAt": "2023-05-22T19:20:28Z",
              "updatedAt": "2023-05-22T19:20:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq6FW",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:20:33Z",
          "updatedAt": "2023-05-22T19:20:33Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Sure, done.",
              "createdAt": "2023-05-22T19:20:33Z",
              "updatedAt": "2023-05-22T19:20:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq6M5",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:20:39Z",
          "updatedAt": "2023-05-22T19:20:39Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Done.",
              "createdAt": "2023-05-22T19:20:39Z",
              "updatedAt": "2023-05-22T19:20:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5Vq6SR",
          "commit": {
            "abbreviatedOid": "6d8ba3e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T19:20:44Z",
          "updatedAt": "2023-05-22T19:20:44Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "Done.",
              "createdAt": "2023-05-22T19:20:44Z",
              "updatedAt": "2023-05-22T19:20:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5VrBu3",
          "commit": {
            "abbreviatedOid": "cea59e5"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Excellent, this looks good to me! I still haven't verified that test vector changes just yet, but I can do that in a follow-up and report back with any issues. Let's go ahead and land this. \r\n\r\nThank you for the quick turnaround!",
          "createdAt": "2023-05-22T19:42:05Z",
          "updatedAt": "2023-05-22T19:42:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 413,
      "id": "PR_kwDOD79ejs5Rugu7",
      "title": "POC Makefile: Don't re-setup every time",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/413",
      "state": "MERGED",
      "author": "jamesw1892",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Having `setup` as a prerequisite of `pyfiles` (which itself is a prerequisite of `test` and `vectors`) means everytime you do `make test`, `setup` is run too. This means the files from submodules are copied and then have to be re-parsed by sage which really slows everything down.\r\n\r\nAny future additions to the makefile will also likely have `pyfiles` as a prerequisite so have this problem too. This is the case for my fork and is causing problems.\r\n\r\nThe downside is that `make setup` must be run the first time so that the files are copied, but this was the case before the commit on 14th March anyway.",
      "createdAt": "2023-05-30T21:15:35Z",
      "updatedAt": "2023-06-08T21:32:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "727b9acb908dce296e15bc14a53a7d04ba9604d0",
      "headRepository": "jamesw1892/OPAQUE",
      "headRefName": "patch-1",
      "headRefOid": "b08951533834ba98c820ab591f78ee016f776fba",
      "closedAt": "2023-06-08T21:32:39Z",
      "mergedAt": "2023-06-08T21:32:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9f08701757f537501555c59067c9bcdd0237f7d1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5WzK8g",
          "commit": {
            "abbreviatedOid": "b089515"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2023-06-01T20:26:22Z",
          "updatedAt": "2023-06-01T20:26:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 415,
      "id": "PR_kwDOD79ejs5SjmIn",
      "title": "Restoring scrypt as a recommended configuration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/415",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/376",
      "createdAt": "2023-06-08T20:18:21Z",
      "updatedAt": "2023-06-08T21:32:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "727b9acb908dce296e15bc14a53a7d04ba9604d0",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "recommend_scrypt",
      "headRefOid": "a4e6bdde3b7b8555f32a1f670cba6ee46e228b43",
      "closedAt": "2023-06-08T21:32:22Z",
      "mergedAt": "2023-06-08T21:32:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e9cfe5ff07d46b9707ff2efa302242f6bed3b817"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5Xqn23",
          "commit": {
            "abbreviatedOid": "b0adec3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-08T21:32:00Z",
          "updatedAt": "2023-06-08T21:32:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n- P256-SHA256, HKDF-SHA-256, HMAC-SHA-256, SHA-256, scrypt(N = 32768, r = 8, p = 1), P-256\r\n```",
              "createdAt": "2023-06-08T21:32:00Z",
              "updatedAt": "2023-06-08T21:32:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 416,
      "id": "PR_kwDOD79ejs5UJmHa",
      "title": "replace \"password file\" with \"registration record\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/416",
      "state": "MERGED",
      "author": "nikgraf",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The term \"password file\" is not used anywhere else in the spec. Usually it's referred to as `record` and the type is `RegistrationRecord`. To avoid confusion I suggest to change it to `registration record` in this particular place.",
      "createdAt": "2023-06-28T14:38:50Z",
      "updatedAt": "2023-07-11T20:16:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9f08701757f537501555c59067c9bcdd0237f7d1",
      "headRepository": "nikgraf/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "c28fadcc17feaa6a2c5b03301a9772ba0785a9af",
      "closedAt": "2023-07-11T11:05:13Z",
      "mergedAt": "2023-07-11T11:05:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "baf50e72ba437e16a8d35eff2676ad138524d156"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5ayXd_",
          "commit": {
            "abbreviatedOid": "c28fadc"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good catch, thank you!",
          "createdAt": "2023-07-10T22:57:41Z",
          "updatedAt": "2023-07-10T22:57:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 417,
      "id": "PR_kwDOD79ejs5VJEFo",
      "title": "Updating klewi's affiliation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/417",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Novi Research -> Meta\r\n\r\n(They're the same thing, but Novi Research doesn't exist anymore)",
      "createdAt": "2023-07-10T23:46:36Z",
      "updatedAt": "2023-07-11T11:06:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9f08701757f537501555c59067c9bcdd0237f7d1",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "update_affiliation",
      "headRefOid": "c26894d061ec28321bfc472d89101e1a55298af2",
      "closedAt": "2023-07-11T11:06:33Z",
      "mergedAt": "2023-07-11T11:06:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "41d8cee5c2778571fa469c3e8e27da0c65da0d89"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5a1pmu",
          "commit": {
            "abbreviatedOid": "7e0aa7e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-11T11:04:35Z",
          "updatedAt": "2023-07-11T11:04:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5a1pxy",
          "commit": {
            "abbreviatedOid": "7e0aa7e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-11T11:05:01Z",
          "updatedAt": "2023-07-11T11:05:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n    organization: Meta\r\n```",
              "createdAt": "2023-07-11T11:05:01Z",
              "updatedAt": "2023-07-11T11:05:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 419,
      "id": "PR_kwDOD79ejs5ZxAOn",
      "title": "Adding in various editorial edits from Hugo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/419",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-07T10:04:45Z",
      "updatedAt": "2023-09-21T10:16:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "423b51581e0e4fa3a96085e3e5fb9525e3c54ba8",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "hugo_edits_1",
      "headRefOid": "155ef23edd6eae500ee50552b8e6e81669286474",
      "closedAt": "2023-09-21T10:16:55Z",
      "mergedAt": "2023-09-21T10:16:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "407aade7614c676c22003b24c6e8dbee8bac8a7f"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the suggestions. I added the definition of a random-key robust MAC in the sentence right after where it is first mentioned, and then later in the Notable Design Differences section, the reference to this definition is made.",
          "createdAt": "2023-09-20T21:27:19Z",
          "updatedAt": "2023-09-20T21:27:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5g3yf4",
          "commit": {
            "abbreviatedOid": "fc561fa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-09-13T19:03:30Z",
          "updatedAt": "2023-09-13T19:13:33Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nBoth of these states are ephemeral and should be erased after the protocol completes.\r\n```",
              "createdAt": "2023-09-13T19:03:30Z",
              "updatedAt": "2023-09-13T19:13:34Z"
            },
            {
              "originalPosition": 158,
              "body": "```suggestion\r\nonline guessing attack from the client side, it can be mitigated in when the channel\r\nbetween client and server is authenticated, e.g., using server-authenticated TLS.\r\nIn such cases, these online attacks are limited to clients and the authenticated server\r\nitself. Moreover, such a channel provides privacy of user information, including identity\r\nand envelope values.\r\n```\r\n\r\nI don't think this statement is true. A server that authenticates over TLS can still carry out this attack. This suggestion helps clarify that authentication only changes who can carry out the attack, but does not remove it entirely.",
              "createdAt": "2023-09-13T19:08:54Z",
              "updatedAt": "2023-09-13T19:13:34Z"
            },
            {
              "originalPosition": 70,
              "body": "Since this is an unusual term, we should probably define it here or point to a definition elsewhere.",
              "createdAt": "2023-09-13T19:11:03Z",
              "updatedAt": "2023-09-13T19:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5hSZ9c",
          "commit": {
            "abbreviatedOid": "fc561fa"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-19T00:53:29Z",
          "updatedAt": "2023-09-19T00:53:29Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "I added the clause, \", defined in {{notable-design-differences}},\" to help clarify it. It is a bit weird pointing to a section on notable design differences, but that is indeed where it is now defined.\r\n\r\nWe could pull it out to its own subsection within Security Considerations, i.e. \r\n\r\n```\r\n## Random-Key Robustness\r\n\r\nThe random-key robustness property that we rely on for a MAC is as follows:\r\ngiven two random keys k1 and k2, it is infeasible to find a message m such that\r\nMAC(k1, m) = MAC(k2, m).\r\n```\r\n\r\nit would be a short subsection...\r\n\r\nThoughts?",
              "createdAt": "2023-09-19T00:53:29Z",
              "updatedAt": "2023-09-19T00:54:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5hVM96",
          "commit": {
            "abbreviatedOid": "8fa765f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-19T10:37:01Z",
          "updatedAt": "2023-09-19T10:37:58Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Could we just inline the definition here instead?",
              "createdAt": "2023-09-19T10:37:01Z",
              "updatedAt": "2023-09-19T10:37:58Z"
            },
            {
              "originalPosition": 72,
              "body": "```suggestion\r\n(MAC). The random-key robustness property states that, given two random keys k1 and k2, it is infeasible to find a message m such that MAC(k1, m) = MAC(k2, m). The API and parameters for the random-key robust MAC is as follows:\r\n```",
              "createdAt": "2023-09-19T10:37:53Z",
              "updatedAt": "2023-09-19T10:37:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5hmbjn",
          "commit": {
            "abbreviatedOid": "aec3426"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-21T10:16:29Z",
          "updatedAt": "2023-09-21T10:16:44Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nThe API and parameters for the random-key robust MAC are as follows:\r\n```",
              "createdAt": "2023-09-21T10:16:29Z",
              "updatedAt": "2023-09-21T10:16:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 420,
      "id": "PR_kwDOD79ejs5Z0x_K",
      "title": "Changing RFCXXXX string to OPAQUEv1-",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/420",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on Scott Fluhrer's mailing list comments:\r\n\r\n\"At one point, the draft uses \u201cRFCXXXX\u201d as a protocol identifier in the preamble; is that expected to be replaced by the assigned RFC number?  If so, I would suggest you add instructions to the RFC editors to that effect.\"",
      "createdAt": "2023-09-07T23:11:19Z",
      "updatedAt": "2023-09-25T14:04:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "8a99c89fab51bdfb017d14721ce33f8fd2aee0d9",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "rfc_editor_note",
      "headRefOid": "34ff52a86975412abdce930b1964a596b1c0455f",
      "closedAt": "2023-09-25T14:04:48Z",
      "mergedAt": "2023-09-25T14:04:48Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "12b9b64a699422da331d6e6cfffa227ca962636f"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah that might be nicer. I see that VOPRF does \"OPRFv1-\" as the context string -- perhaps we can just follow suit?",
          "createdAt": "2023-09-14T21:59:16Z",
          "updatedAt": "2023-09-14T21:59:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yeah that might be nicer. I see that VOPRF does \"OPRFv1-\" as the context string -- perhaps we can just follow suit?\r\n\r\nYep, that's my suggestion.",
          "createdAt": "2023-09-15T10:07:43Z",
          "updatedAt": "2023-09-15T10:07:43Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated the string from \"RFCXXXX\" to \"OPAQUEv1-\". Also re-ran test vector generation",
          "createdAt": "2023-09-25T00:42:54Z",
          "updatedAt": "2023-09-25T00:42:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5g3xIc",
          "commit": {
            "abbreviatedOid": "6500d3d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Alternatively, we could just use `\"OPAQUEv1\"` or whatever as the string, and avoid the RFC number dependency altogether? That would let us generate test vectors right now.",
          "createdAt": "2023-09-13T18:59:36Z",
          "updatedAt": "2023-09-13T18:59:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5h4qt6",
          "commit": {
            "abbreviatedOid": "34ff52a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T14:04:03Z",
          "updatedAt": "2023-09-25T14:04:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 421,
      "id": "PR_kwDOD79ejs5aD4hL",
      "title": "Fixing eurocrypt misspelling",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/421",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-11T20:28:12Z",
      "updatedAt": "2023-09-13T18:57:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41d8cee5c2778571fa469c3e8e27da0c65da0d89",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "eurocrypt_mispelling",
      "headRefOid": "60ad6b60fe7c8d0cc45b07d499ad75b43e5a2fe8",
      "closedAt": "2023-09-13T18:57:04Z",
      "mergedAt": "2023-09-13T18:57:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ed1415cc2e668e7bb3a4a54277988bc591bc7fac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5g3wMc",
          "commit": {
            "abbreviatedOid": "60ad6b6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-13T18:56:58Z",
          "updatedAt": "2023-09-13T18:56:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 422,
      "id": "PR_kwDOD79ejs5aENIX",
      "title": "Various edits suggested by JP Aumasson",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/422",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\n# 2.1\r\n\r\n\"SerializeElement(element): Map input element to a fixed-length byte array buf.\"\r\n\r\nIs it necessary and IETF-standard to name the output value variable?\r\nThis function's output is later assigned to other variables such as \r\n\"blinded_message = SerializeElement(blinded_element)\" (5.2.1)\r\n\r\nThanks, good catch, removed the \"buf\" from the sentence.\r\n \r\n\r\n\r\n# 2.2\r\n\r\nNot really expecting this to be revised, but mentioning it FTR:\r\n\r\nThe Expand()/Extract() API is specific to HKDF, and not a standard\r\ncrypto primitive API. This precludes the (direct) use of other KDFs than\r\nHKDF. It might have been more \"inclusive\" to use standard KDF or XOF\r\nAPIs. \r\n \r\n\r\n\r\n\"a collision-resistant Message Authentication Code (MAC)\"\r\nThis is not a cryptographically standard security notion, as a MAC's\r\nsecurity goal is unforgeability. If some collision resistance is\r\nadditionally required, it should be specified that we're talking (I\r\nsuppose) of collisions with a same secret key.\r\nAlso, these combined requirements will imply in practice the use of a\r\nPRF, so it might be simpler to require a PRF and restrict its output\r\nsize to greater than some security bound.\r\n\r\nThanks for bringing this up as well. Actually, after some comments from Hugo Krawczyk, we are changing this to require: \"random key robust\" instead of \"collision-resistant\" MAC. Additionally, we are adding the following definition for a random key robust MAC, under the Security Considerations section: \r\n\r\n\"The random-key robustness property is only needed for the MAC function: the\r\n  property being that, given two random keys k1 and k2, it is infeasible to find a\r\n  message m such that MAC(k1, m) = MAC(k2, m).\"\r\n\r\nChanges are on github here (search for \"random key robust\"): https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/419\r\n\r\n\r\n# 3 \r\n\r\nnit: the \"authenticated key exchange\" is mentioned, and then 3.1 refers\r\nto it as the \"AKE\", but it may not be obvious to all readers that it's\r\nthe \"authenticated key exchange\". Suggested change: \"authenticated key\r\nexchange (AKE)\" in 3.\r\n\r\n\ud83d\udc4d\r\n \r\n\r\n# 3.1\r\n\r\n\"chooses a seed (oprf_seed) of Nh bytes for the OPRF\":\r\nIs this consistent with earlier statement \"all random nonces and seeds\r\nused in these dependencies and the rest of the OPAQUE protocol are of\r\nlength Nn and Nseed bytes, respectively, where Nn = Nseed = 32.\"?\r\n\r\nMaybe mention earlier that Nn = Nseed = Nh = 32?\r\n\r\n\r\nFor SHA512 outputs, Nh = 64, whereas for SHA256, Nh = 32. So, Nh would be an instance of the exception \"*Unless said otherwise*, all random nonces and seeds...\"\r\n \r\n\r\n# 3.2\r\n\r\nFor the avoidance of doubt, it may be added that \"export_key\" is a\r\nsymmetric key, not a public key or a private key.\r\n\r\nAdded this text: \"The client output of this stage is a single value `export_key` that the client may use for application-specific purposes, e.g., *as a symmetric key* used to encrypt...\"\r\n \r\n# 4\r\n\r\nThis section was not clear to me:\r\nit starts by introducing the concept of Envelope structured, then says\r\n\"The following types of application credential information are\r\nconsidered\", from which a reader might understand \"are part of the\r\nEnvelope\" or \"may be part of the Envelope\". \r\nRight after that, the text says \"These credential values are used in the\r\nCleartextCredentials\", when in fact it's only 3 out of the 5 values. \r\n\r\nI see \ud83d\udc4d. To help make things clearer, I changed the text to say, \"*A subset of* these credential values are used in ...\"\r\n \r\n\r\n# 4.1.1\r\n\r\n\"nonce: A unique nonce\"\r\nIt may be specified that it is unique with respect to the set of users\r\nof a given application (and set of parameters thereof)\r\n\r\nWouldn't it be safer to \"bind\" values derived from the nonce to the\r\nserver's identity/publickey? In that case, the nonce should be unique\r\nonly per server, rather than per application parameters. \r\nBut maybe that's on purpose, to allow the use of the same nonce with\r\nmultiple servers?\r\n\r\nHmm. This nonce is meant to be sampled randomly upon each envelope creation (based on the line `envelope_nonce = random(Nn)`). So actually, we do not want this nonce to ever be reused. Perhaps it would help to clarify that this nonce is \"randomly-sampled\" instead of just saying \"unique nonce\"? I amended the text to read: \"nonce: A randomly-sampled nonce ...\" in hopes of clearing up this confusion.\r\n \r\n\r\n\r\n# 4.1.3\r\n\r\n\"  If !ct_equal(envelope.auth_tag, expected_tag)\r\n    raise EnvelopeRecoveryError\"\r\n\r\nWe may add that, in such a case, all the previously computed\r\nvalues/key/credentials must be discarded/deleted.\r\n\r\nAdded the text: \"In the case of `EnvelopeRecoveryError` being raised, all previously-computed intermediary values in this function MUST be deleted.\"\r\n \r\n\r\n# 5.2.1\r\n\r\n\"password, an opaque byte string\"\r\n\r\nThe definition of an opaque string in this context seems necessary, as\r\nit may confuse readers (e.g., as related to opaque types). \r\n\r\n\r\nIndeed what we mean here by \"opaque byte string\" is: a string of bytes of unspecified format. Perhaps [@Christopher Wood](mailto:caw@heapingbits.net) can chime in on this for suggestions on how we can clarify, as I was assuming it is the unambiguous terminology for these sorts of things :)\r\n\r\n\r\n# 6.3.2.2\r\n\r\n\"It is RECOMMENDED that a fake client record is created once (e.g. as\r\nthe first user record of the application) and stored alongside\r\nlegitimate client records.  This allows servers to locate the record in\r\na time comparable to that of a legitimate client record.\"\r\n\r\nThis part wasn't clear to me first (regarding the purpose \"to locate\").\r\nIt may be clarified that storing such fake record (or, even better, many\r\nsuch records and pick a random one) saves the cost/time of computing\r\none, thus avoiding potential timing side channels.\r\n\r\nI clarified by rephrasing the words \"to locate\" to \"to retrieve\".\r\n \r\n\r\n# 7\r\n\r\n\"is 128-bits\" ->  \"is 128 bits\" (or \"is 128-bit\").\r\n\r\nIt may be added that the recommended configurations target 128-bit\r\nsecurity.\r\n\r\nThanks, also added after the configurations, the sentence: \"The above recommended configurations target 128-bit security.\"\r\n \r\n# 10\r\n\r\nTotally trivial and obvious, but shouldn't the security considerations\r\nmention somewhere the risk of weak/short passwords?\r\nHere of maybe in section 5 (Offline Registation)\r\n\r\n\r\nAdded a sentence at the end of the \"## Password Salt and Storage Implications\" section:\r\n\r\n\"In general, passwords should be selected with sufficient entropy to avoid being susceptible to recovery through dictionary attacks, both online and offline.\"",
      "createdAt": "2023-09-11T21:41:37Z",
      "updatedAt": "2023-09-19T10:39:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41d8cee5c2778571fa469c3e8e27da0c65da0d89",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "jpa_edits",
      "headRefOid": "57e3b830b74f4ea4d2a66f17deed2247e087be22",
      "closedAt": "2023-09-19T10:39:10Z",
      "mergedAt": "2023-09-19T10:39:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "423b51581e0e4fa3a96085e3e5fb9525e3c54ba8"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I think this is good to go, feel free to merge it in!",
          "createdAt": "2023-09-19T00:55:22Z",
          "updatedAt": "2023-09-19T00:55:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5g3wIk",
          "commit": {
            "abbreviatedOid": "57e3b83"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-13T18:56:47Z",
          "updatedAt": "2023-09-13T18:56:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 423,
      "id": "PR_kwDOD79ejs5aoE4M",
      "title": "Incorporating Julia Hesse's edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/423",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Editorial:\r\n- Sec 2.1, DeriveKeyPair: maybe assign names to the output of this API? \r\nIt is also unclear what happens with the public key. Is that needed \r\nanywhere else?\r\n\r\nChanged the DeriveKeyPair definition to read:\r\n\r\n- DeriveKeyPair(seed, info): Create and output (`sk`, `pk`), consisting of a private and public key derived deterministically from a `seed`` and `info`` parameter, as described in {{OPRF, Section 3.2}}.\r\n\r\nThe public key is not used in one case (when we compute\u00a0(oprf_key, _) = DeriveKeyPair(seed, \"OPAQUE-DeriveKeyPair\")), but it is used for some configurations in the AKE section (for example in 3DH ristretto255:\u00a0DeriveDiffieHellmanKeyPair(seed): This function is implemented as DeriveKeyPair(seed, \"OPAQUE-DeriveDiffieHellmanKeyPair\"), where DeriveKeyPair is as specified in {{OPRF, Section 3.2}}. The public value from DeriveKeyPair is encoded using SerializeElement from {{Section 2.1 of OPRF}}.)\r\n\u00a0- Sec 3.1, \"The server can use this single pair of keys with multiple \r\nclients and can opt to use multiple seeds (so long as they are kept \r\nconsistent for each client).\" - WhatsApp's usage of OPAQUE is one \r\nexample where *reusing* a key among several clients is devastating for \r\nthe security of the overall scheme. It should be made super clear in \r\nthis draft that *individual* keys have to be used per client. There are \r\nother parts in the draft where this is actually taken care of, but the \r\ncited paragraph here is too ambiguous, imo. What is a \"client\"? And is \r\nit really okay to use the same key and same seed for many clients?\r\n\r\nI think there might be some confusion here. The sentence, \"The server can use this single pair of keys with multiple clients\" refers to the\u00a0server_private_key and server_public_key parameters used in the AKE section, not the OPRF key. The \"oprf_seed\" is something we believe can be re-used for each client, but anyway the sentence says it is OK to use multiple seeds if desired. The actual OPRF key is not referenced in this paragraph, because it is anyway derived from KDF(oprf_seed, credential_identifier), and not handpicked by the server.\r\nTo address the confusion, I changed the text to say, \"The server can use `server_private_key` and `server_public_key` with multiple clients and can opt to use multiple seeds (so long as they are kept consistent for each client).\" (instead of saying \"this single pair of keys\", just spelling out which pair of keys the text is referring to).\r\n\r\n\u00a0- I had a hard time following the modularization of the protocol. In \r\nSection 3, the phases are described as Setup, Offline registration, and \r\nonline AKE. That is decoupled from 4, which describes client credential \r\nstorage and key recovery. This touches both offline registration and \r\nonline AKE phases. I do not want to suggest to do any large changes, but \r\n2-3 clarifying sentences about the structure of the \r\nsections/explanations of the different protocol phases could be added.\r\n\r\nI believe this is already addressed by the paragraph at the end of Section 3, \"The rest of this document describes the details of these stages in detail. Section 4 describes how client credential information is generated, encoded, and stored on the server during registration, and recovered during login. Section 5 describes the first registration stage of the protocol, and Section 6 describes the second authentication stage of the protocol. Section 7 describes how to instantiate OPAQUE using different cryptographic dependencies and parameters.\"\r\n\r\nBut if you have some suggested wording to make this even more clear, let me know and I can incorporate it!\u00a0\r\nSecurity:\r\n- The export key export_key is (if I understood correctly), \r\ndeterministically derived from PRF_K(pw). I simplify a bit here. This \r\nmeans the server can brute-force export_key. export_key is *not* as \r\nsecure as a key that is, e.g., generated by the client running some \r\nkeygen locally. This should be made super clear in the draft, imo. In \r\nparticular, 10.1 states that export_key is a \"pseudorandom value \r\nindependent of other values in the protocol\", and 10.5 says that it can \r\nbe used to encrypt client secrets and store them on the server. The \r\nlatter I find particularly alarming: the server can run long-term \r\npassword guessing attempts against this encryption key, so I would \r\nspecifically recommend to *not* use export_key as an encryption key when \r\nstoring things on the server. Not sure if I'm too careful here, but \r\npeople do tend to choose weak passwords...\r\n\r\nGood point. In 10.1, I changed the text on export_key to say, \"This key is a pseudorandom value *derived from the client password (among other values)* and has no influence on the security analysis (it can be simulated with a random output).\"And in 10.5, I still wanted to capture the usage of the export key, and so I changed the text to the following:\r\n\r\n\"The export key can be used (separately from the OPAQUE protocol) to provide confidentiality and integrity to other data which only the client should be able to process. For instance, if the client wishes to store secrets with a third party, then this export key can be used by the client to encrypt these secrets so that they remain hidden from a passive adversary that does not have access to the server's secret keys or the client's password.\"\r\n\r\nLet me know if this is still inaccurate.\u00a0- Sec 4, \"Future variants of OPAQUE may use different key recovery \r\nmechanisms. See Section 4.1 for details.\" - Section 4.1 does not specify \r\nany framework/constraints on what such mechanism need to fulfill, and I \r\nwould downtone this \"invitation\" to design one's own recovery mechanism.\r\n\r\nI will simply delete this sentence -- I believe we added it in originally to address feedback that we got about choosing one specific recovery mechanism over another alternative, but I agree that at this point, such an exercise should be done with caution, and we don't want to actively recommend doing so (unless it comes with a proper security analysis).\u00a0- Sec 10.1, first bullet. The \"upcoming paper\" is here: \r\nhttps://eprint.iacr.org/2023/220\r\nAdded\u00a0\r\n- Sec 10.1, second bullet. It is not true that this variant is analyzed \r\nin \"the new paper\", i.e., the paper mentioned in the first bullet. I \r\nhave discussed this already with Hugo and he agrees.\r\n\r\nThanks, I simply removed the sentence: \"This variant is also analyzed in the new paper referred to in the previous item.\"\u00a0- Sec 10.2 Security Analysis. This section mentions that the security of \r\nOPAQUE was proven in [JKX18]. However, the protocol proven there differs \r\nin many ways from the protocol specified in this draft. As a starting \r\npoint, https://eprint.iacr.org/2023/843.pdf points out differences \r\nbetween the proven version and the draft versions v03 and v09 (I did not \r\ncheck whether all these still apply to v11).\r\nI amended the first sentence to have the caveat: \"Jarecki et al. {{JKX18}} proved the security of OPAQUE (modulo the design differences outlined in {{notable-design-differences}})\" (referring to the previous section)\r\n\u00a0Most importantly, [JKX18] \r\nrequires session identifiers not only for the overall OPAQUE protocol \r\nbut also for the VOPRF building block. However, the VOPRF as currently \r\nspecified in draft-irtf-cfrg-voprf-21 does not add unique session \r\nidentifiers to, e.g., hash inputs (which would be required for the \r\nsecurity analysis of both [JKK14] and [JKX18] to apply to a multi-user \r\nVOPRF, and a multi-client OPAQUE). I discussed this with Chris and he \r\nadded the following disclaimer to the VOPRF security considerations \r\nsection of draft-irtf-cfrg-voprf-21:\r\n\r\n\"In [JKK14], these properties are proven for one instance (i.e., one \r\nkey) of the VOPRF protocol, and without batching. There is currently no \r\nsecurity analysis available for the VOPRF protocol described in this \r\ndocument in a setting with multiple server keys or batching.\"\r\n\r\nThe same should be done in the OPAQUE draft, because for the specified \r\nprotocol, multi-client security is not proven anywhere in the \r\nliterature, afaik.\r\n\r\nI see. At the end of this section, I added the paragraph: \"In {{JKX18}}, security is proven for one instance (i.e., one key) of the OPAQUE protocol, and without batching. There is currently no security analysis available for the OPAQUE protocol described in this document in a setting with multiple server keys or batching.\"\r\n\u00a0\r\nNits:\r\n- the voprf draft is now a RFC and could be cited as such\r\n\r\nI think it is not an RFC just yet (or at least I don't see an RFC number anywhere)\u00a0- \"describes the details of these stages in detail\"\r\n\r\nThanks, changed to \"describes the specifics of these stages in detail\"\u00a0- Sec 4, Create CleartextCredentials: client_public_key missing from the \r\ninputs?\r\n\r\nclient_public_key is not stored in the struct because it is derived from client_private_key. But JP Aumasson also pointed out this confusion, and in response to his edits, I added the text: \"*A subset of* these credential values are used in ...\"\u00a0\r\n\r\nBest,\r\nJulia\r\n",
      "createdAt": "2023-09-19T00:45:25Z",
      "updatedAt": "2023-09-23T23:05:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "407aade7614c676c22003b24c6e8dbee8bac8a7f",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "jhesse_edits",
      "headRefOid": "775a1e9a435c53db9a8f89abaca4f649e16742cc",
      "closedAt": "2023-09-23T23:05:14Z",
      "mergedAt": "2023-09-23T23:05:14Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "8a99c89fab51bdfb017d14721ce33f8fd2aee0d9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5hVNrh",
          "commit": {
            "abbreviatedOid": "cc12d29"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-19T10:38:58Z",
          "updatedAt": "2023-09-19T10:38:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 424,
      "id": "PR_kwDOD79ejs5bEXq2",
      "title": "RKR MAC section + client identity clarifications",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/424",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Second round of edits from Hugo.\r\n\r\n- Pulled out a section for defining random-key robustness for MACs + adding some other notes about it.\r\n- Some clarifications on how the client identity can be transmitted being outside of the scope of the protocol\r\n- Also adding text to implementation safeguards to say that the client identity can be added into the OPRF computation if it is bound to the lifetime of the registration record",
      "createdAt": "2023-09-25T00:23:08Z",
      "updatedAt": "2023-09-25T18:44:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "8a99c89fab51bdfb017d14721ce33f8fd2aee0d9",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "hugo_edits_2",
      "headRefOid": "b95828b09bdcaa6a4b2b59d668240fe736520551",
      "closedAt": "2023-09-25T18:44:51Z",
      "mergedAt": "2023-09-25T18:44:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "66834054528d1daf4f68d730fb95c15d625006d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5h6waI",
          "commit": {
            "abbreviatedOid": "b95828b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T18:44:47Z",
          "updatedAt": "2023-09-25T18:44:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 425,
      "id": "PR_kwDOD79ejs5bJ-rt",
      "title": "Fix Preamble signature",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/425",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #418",
      "createdAt": "2023-09-25T18:47:10Z",
      "updatedAt": "2023-09-28T15:00:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "66834054528d1daf4f68d730fb95c15d625006d0",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fix-preamble-signature",
      "headRefOid": "4812b06e8ac55e047f67538af909f278b0b1b416",
      "closedAt": "2023-09-28T15:00:37Z",
      "mergedAt": "2023-09-28T15:00:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fead7c6d9cd4efb9cf71114afb485ccc296a91c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5iN7h2",
          "commit": {
            "abbreviatedOid": "4812b06"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2023-09-28T03:01:17Z",
          "updatedAt": "2023-09-28T03:01:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 427,
      "id": "PR_kwDOD79ejs5bZYEn",
      "title": "Clarifying the use of multiple client seeds",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/427",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #426 ",
      "createdAt": "2023-09-28T03:10:01Z",
      "updatedAt": "2023-10-05T21:22:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f8ef33b9b3d8f54028eb45d0242b43ac721646e7",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "clarify_client_seeds",
      "headRefOid": "46f581650fb6a56c2d3c41b1fde318311edc4097",
      "closedAt": "2023-10-05T21:22:43Z",
      "mergedAt": "2023-10-05T21:22:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2839e39f4638cfc123c1141f9f2949cc73906d61"
      },
      "comments": [
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the OPRF seed has to be the same to prevent client enumeration, I think it should be noted here.",
          "createdAt": "2023-09-28T07:20:22Z",
          "updatedAt": "2023-09-28T07:20:22Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated the sentence to say:\r\n\r\nThe server can also opt to use different seeds for each client,\r\nso long as they are maintained across the registration and online AKE stages, and\r\nkept consistent for each client (since an inconsistent mapping of clients to seeds\r\ncould leak information as described in {{preventing-client-enumeration}}).\r\n\r\nHope that works!",
          "createdAt": "2023-10-04T23:48:09Z",
          "updatedAt": "2023-10-04T23:48:09Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (since an inconsistent mapping of clients to seeds\r\n> could leak information as described in {{preventing-client-enumeration}})\r\n\r\nWouldn't that require consistent mapping between pre- and post-registered clients?\r\nE.g. unregistered client X requires to have the same seed as registered client X, otherwise an attacker could notice the difference and determine that client X was not registered but is registered now.\r\n\r\nThe only way I see this could be done is by deriving a seed from the client identifier/identity, which seems rather problematic to me.",
          "createdAt": "2023-10-05T09:52:34Z",
          "updatedAt": "2023-10-05T09:52:34Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To clarify though: I think the change LGTM, I was just worried about how implementers could interpret this.",
          "createdAt": "2023-10-05T09:55:29Z",
          "updatedAt": "2023-10-05T09:55:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> > (since an inconsistent mapping of clients to seeds\r\n> > could leak information as described in {{preventing-client-enumeration}})\r\n> \r\n> Wouldn't that require consistent mapping between pre- and post-registered clients? E.g. unregistered client X requires to have the same seed as registered client X, otherwise an attacker could notice the difference and determine that client X was not registered but is registered now.\r\n> \r\n> The only way I see this could be done is by deriving a seed from the client identifier/identity, which seems rather problematic to me.\r\n\r\nYes, this requires a consistent mapping between pre and post registered clients. The situation I am thinking of is the following. Let's say the server sets the policy:\r\n- if the client identity starts with an A, then always use seed X for registration and login\r\n- if the client identity starts with a B, then always use seed Y for registration and login\r\n- ... and so on\r\n\r\nThe purpose of the sentence \"The server can also opt to use different seeds for each client\" is to indicate that it is indeed OK to set this kind of policy. This is not exactly deriving a seed dependent on the client identity, but choosing a seed based on the client identity, which we don't view as problematic.\r\n\r\nSo I guess my main question is: is the language clear enough to convey that this is what we mean, or is it just causing unnecessary confusion (and maybe we should get rid of the suggestion altogether)?",
          "createdAt": "2023-10-05T19:56:45Z",
          "updatedAt": "2023-10-05T19:57:03Z"
        },
        {
          "author": "daxpedda",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So I guess my main question is: is the language clear enough to convey that this is what we mean, or is it just causing unnecessary confusion (and maybe we should get rid of the suggestion altogether)?\r\n\r\nI believe it is clear enough.",
          "createdAt": "2023-10-05T20:09:18Z",
          "updatedAt": "2023-10-05T20:09:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5iS0CR",
          "commit": {
            "abbreviatedOid": "2fb5b80"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM. I'm also OK with folding in @daxpedda's additional suggestion. Please feel free to merge as you see fit.",
          "createdAt": "2023-09-28T15:02:47Z",
          "updatedAt": "2023-09-28T15:02:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 428,
      "id": "PR_kwDOD79ejs5bZZs3",
      "title": "Fixing minor typos: extraneous mac computation, ke2.server_mac",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/428",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [#418:](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/418#issuecomment-1737188161):\r\n\r\nFixes the following two issues:\r\n- In function AuthServerRespond the value expected_client_mac is computed twice (I think the first line can be dropped)\r\n- In function AuthClientFinalize the value ke2.server_mac is used that doesn't exist, it should be ke2.auth_response.server_mac",
      "createdAt": "2023-09-28T03:22:10Z",
      "updatedAt": "2023-09-28T15:00:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "66834054528d1daf4f68d730fb95c15d625006d0",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "minor_typos",
      "headRefOid": "8084df02053902aa377d8e1dbb3efd99aa41e498",
      "closedAt": "2023-09-28T15:00:57Z",
      "mergedAt": "2023-09-28T15:00:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8424bc1881acb8e78ae49d7a41d3b08406fddbcd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5iSy-2",
          "commit": {
            "abbreviatedOid": "8084df0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-28T15:00:48Z",
          "updatedAt": "2023-09-28T15:00:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 429,
      "id": "PR_kwDOD79ejs5bZems",
      "title": "Removing extraneous output from RecoverCredentials",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/429",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/418#issuecomment-1737188161:\r\n\r\n- In function GenerateKE3 the value server_public_key is returned from RecoverCredentials, but it's never used in GenerateKE3\r\n\r\nIndeed this was a typo, the server_public_key parameter did not need to be output by RecoverCredentials because it is already part of the cleartext_credentials output.\r\n\r\nThis change removes the output of server_public_key from the RecoverCredentials() function",
      "createdAt": "2023-09-28T04:00:20Z",
      "updatedAt": "2023-09-28T15:01:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "66834054528d1daf4f68d730fb95c15d625006d0",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_recover_credentials",
      "headRefOid": "f5a403976b2dc6dd32aa22e79c29911aad9656b9",
      "closedAt": "2023-09-28T15:01:16Z",
      "mergedAt": "2023-09-28T15:01:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f8ef33b9b3d8f54028eb45d0242b43ac721646e7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5iSzMg",
          "commit": {
            "abbreviatedOid": "f5a4039"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-28T15:01:10Z",
          "updatedAt": "2023-09-28T15:01:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 430,
      "id": "PR_kwDOD79ejs5b9WFg",
      "title": "Adding in edits from Chloe Martindale",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/430",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "General:\r\n\r\nIt is clear that the authors have taken the previous comments on board and have made many positive changes. However, some important points from previous discussions remain:\r\n\r\n-OPAQUE differs in some fundamental ways from PAKEs, for example, it is not PKI-free in the sense of other PAKEs. It would be good to make this very clear in an introductory section where you outline all the properties of standard PAKEs that are different from OPAQUE, and motivate your choices in each case. This is also very important in the security proof: It is different from the case you cite, and consideration needs to be taken here.\r\n\r\n-In my opinion, the effort to make the protocol (and its explanation) as general as possible is harming the potential for safe adoption. It is great that there are three recommended configurations on p38, but no details are given on why these have been chosen: Performance? Trusted security? A trade-off? Or specific applications?\r\nI would reorder the whole draft focussing on each specific instantiation in turn, and end with a generalization for potential future (e.g. post-qauntum) applications. This would encourage and allow for careful scrutiny of the cryptographic security of each configuration to be recommended for adoption. (I will not insist on this, as this is a big change, but I would like to see more discussion of the chosen instantiations).\r\n\r\nSection 1, paragraph 3:\r\n\r\n-Not PKI-free - you say in the previous paragraph that PKI is only used during client registration. Be more precise here: I also am not convinced of the lack of PKI in the rest of the protocol as the term PKI(-free) is not mathematically defined.\r\n-\"pre-computation attack\" needs defining\r\n\r\nSection 6.4.1\r\n\r\nIn light of comments in https://eprint.iacr.org/2021/839.pdf on the necessity of Hash-to-Curve, maybe highlight here that ECDH is RECOMMENDED where you link forward to your suggested instantiations.\r\n\r\nAppendix C.1\r\n\r\nYou should add public key validation to the HMQV instantiation. Perhaps you tried to avoid the problem of small subgroup attacks by specify a prime order group, but if you have a prime order elliptic curve group that doesn't rule out small subgroup twist attacks. It would be cleaner to just add the public key validation, that way you ensure you have covered all cases in any instantiation.",
      "createdAt": "2023-10-05T03:16:36Z",
      "updatedAt": "2023-10-05T21:23:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f8ef33b9b3d8f54028eb45d0242b43ac721646e7",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "martindale_edits_1",
      "headRefOid": "7672222205432b385cad175702cb2200259358e9",
      "closedAt": "2023-10-05T21:22:59Z",
      "mergedAt": "2023-10-05T21:22:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0f90d424c14ef2e77a944e3d367fca0b9d63cb13"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5i8Dpy",
          "commit": {
            "abbreviatedOid": "7672222"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-05T13:46:30Z",
          "updatedAt": "2023-10-05T13:46:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 431,
      "id": "PR_kwDOD79ejs5b9bJs",
      "title": "Small clarifications + recommendations per Hugo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/431",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-05T03:50:13Z",
      "updatedAt": "2023-10-05T21:22:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f8ef33b9b3d8f54028eb45d0242b43ac721646e7",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "hugo_edits_3",
      "headRefOid": "d553790077573b46013b0946b9dc61eef01ea7e2",
      "closedAt": "2023-10-05T21:22:51Z",
      "mergedAt": "2023-10-05T21:22:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "12602032d504d4c617d2a5dfe9337b1d27d2ece5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5i8D3i",
          "commit": {
            "abbreviatedOid": "d553790"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-05T13:46:54Z",
          "updatedAt": "2023-10-05T13:46:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 432,
      "id": "PR_kwDOD79ejs5cNSGM",
      "title": "remove extra backticks in DeriveKeyPair description",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/432",
      "state": "MERGED",
      "author": "aldenml",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-08T22:16:44Z",
      "updatedAt": "2023-10-09T00:08:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0f90d424c14ef2e77a944e3d367fca0b9d63cb13",
      "headRepository": "aldenml/draft-irtf-cfrg-opaque",
      "headRefName": "typos",
      "headRefOid": "db25f3c2063fd30f3bc6b0766209d4e77410d616",
      "closedAt": "2023-10-08T23:54:21Z",
      "mergedAt": "2023-10-08T23:54:21Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "6f98fac04f72d9d8449ca763a42e4f486cf7ff11"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5jKPBs",
          "commit": {
            "abbreviatedOid": "db25f3c"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-08T23:53:32Z",
          "updatedAt": "2023-10-08T23:53:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 433,
      "id": "PR_kwDOD79ejs5ckS5R",
      "title": "Minor clarification about sending additional information",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/433",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adding the following sentence under application considerations:\r\n\r\n- Additional information: After completing the online AKE stage, the server\r\n  may choose to send additional information, encrypted under `session_key`,\r\n  to the client.",
      "createdAt": "2023-10-11T21:03:53Z",
      "updatedAt": "2023-12-10T14:52:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "6f98fac04f72d9d8449ca763a42e4f486cf7ff11",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "hugo_edits_4",
      "headRefOid": "eaf7f1d71c62e604aabb520bc992892d534226b2",
      "closedAt": "2023-12-10T14:52:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "After some offline discussion, seems like we can omit making this change as it just adds more confusion.",
          "createdAt": "2023-12-10T14:52:03Z",
          "updatedAt": "2023-12-10T14:52:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 435,
      "id": "PR_kwDOD79ejs5frCW1",
      "title": "Incorporating server identity into OPRF computation as a recommendation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/435",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-16T19:50:22Z",
      "updatedAt": "2023-12-11T20:12:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "6f98fac04f72d9d8449ca763a42e4f486cf7ff11",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "incorporate_server_identity",
      "headRefOid": "483834fe33f6f32d929f7e7e0921a4caeb9dfe10",
      "closedAt": "2023-12-11T20:12:50Z",
      "mergedAt": "2023-12-11T20:12:50Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "ee74a9a6e8f6d255b162f357b03515326796643b"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Should we add this in the reference implementations and vectors ?",
          "createdAt": "2023-12-04T19:07:39Z",
          "updatedAt": "2023-12-04T19:07:39Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should we add this in the reference implementations and vectors ?\r\n\r\nNo, since these are just RECOMMENDED but not required.",
          "createdAt": "2023-12-07T21:11:14Z",
          "updatedAt": "2023-12-07T21:11:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5puKbk",
          "commit": {
            "abbreviatedOid": "483834f"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-09T14:52:00Z",
          "updatedAt": "2023-12-09T14:52:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 436,
      "id": "PR_kwDOD79ejs5hE7lQ",
      "title": "Adding note on password change",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/436",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Under Application Considerations, we are adding some text to describe how a password change should be handled: by rerunning the registration protocol as a fresh instance using the new password.",
      "createdAt": "2023-12-04T16:40:10Z",
      "updatedAt": "2023-12-07T21:18:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "6f98fac04f72d9d8449ca763a42e4f486cf7ff11",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "password_change",
      "headRefOid": "cbc12f5d2f344e1dd87874201187dde44d004e56",
      "closedAt": "2023-12-07T21:10:47Z",
      "mergedAt": "2023-12-07T21:10:47Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "ade0cf06672580ef99cd68adb9b942ad7df79509"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "apologies if this is a bit late, but i just had the thought, the way this is now phrased does not address authorization to replace this record. is there any way the previous record+OPAQUE can be used to provide authorization to this operation?",
          "createdAt": "2023-12-07T21:18:39Z",
          "updatedAt": "2023-12-07T21:18:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5pFFHs",
          "commit": {
            "abbreviatedOid": "0c25e0b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-04T16:54:33Z",
          "updatedAt": "2023-12-04T16:54:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n- Handling password changes: In the event of a password change, the client and server can\r\n```",
              "createdAt": "2023-12-04T16:54:33Z",
              "updatedAt": "2023-12-04T16:54:52Z"
            },
            {
              "originalPosition": 4,
              "body": "I don't think we need any normative language here. Applications can do whatever they want here.",
              "createdAt": "2023-12-04T16:54:48Z",
              "updatedAt": "2023-12-04T16:54:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5pGAE9",
          "commit": {
            "abbreviatedOid": "cbc12f5"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-04T19:03:25Z",
          "updatedAt": "2023-12-04T19:03:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 437,
      "id": "PR_kwDOD79ejs5hHkpl",
      "title": "added proposal to caveat the server-side registration warning",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/437",
      "state": "MERGED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "draft proposal to settle #434",
      "createdAt": "2023-12-05T00:56:38Z",
      "updatedAt": "2023-12-14T20:41:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "6f98fac04f72d9d8449ca763a42e4f486cf7ff11",
      "headRepository": "stef/draft-irtf-cfrg-opaque",
      "headRefName": "one-shot-registration",
      "headRefOid": "9587fa4438c975d56c4bba9f337dd6636de08e11",
      "closedAt": "2023-12-14T20:41:16Z",
      "mergedAt": "2023-12-14T20:41:16Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "f036cf2dfcdf5a33b8f28c194003ac2455ba501b"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm hoping to cut down on the wording and avoid referencing corporate deployments. How about the following suggested text, instead? \r\n\r\n> Some applications may require learning the client's password for enforcing password\r\n> rules. Doing so invalidates this important security property of OPAQUE and is\r\n> NOT RECOMMENDED, unless it is not possible for applications to move such checks\r\n> to the client. Note that limited checks at the server are possible to implement, e.g.,\r\n> detecting repeated passwords upon re-registrations or password change.\r\n\r\nNote that the delta is that we are caveating the \"NOT RECOMMENDED\", with the phrasing \"unless it is not possible for applications to move such checks to the client\" without elaborating the different scenarios where that might not be possible. I hope this still captures what you are aiming for!\r\n\r\n@stef ^",
          "createdAt": "2023-12-09T14:41:56Z",
          "updatedAt": "2023-12-11T20:13:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5p_tKM",
          "commit": {
            "abbreviatedOid": "00eb278"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Marking as request changes for the above comment ^",
          "createdAt": "2023-12-12T19:38:12Z",
          "updatedAt": "2023-12-12T19:38:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5qP3PB",
          "commit": {
            "abbreviatedOid": "9587fa4"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thank you!\r\n\r\nBut I also want to make sure that @chris-wood and @bytemare get a chance to see this before merging.",
          "createdAt": "2023-12-14T19:17:13Z",
          "updatedAt": "2023-12-14T19:17:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOD79ejs5qQBvT",
          "commit": {
            "abbreviatedOid": "9587fa4"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-14T19:42:52Z",
          "updatedAt": "2023-12-14T19:42:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 438,
      "id": "PR_kwDOD79ejs5iwc6L",
      "title": "Some corrections to the text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/438",
      "state": "MERGED",
      "author": "bytemare",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As I was rereading the draft, I saw a couple of mistakes and missing spaces. So I ran the text through a corrector that found some other suggestions.",
      "createdAt": "2023-12-26T02:59:20Z",
      "updatedAt": "2024-03-07T01:32:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f036cf2dfcdf5a33b8f28c194003ac2455ba501b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "dbz/draft-corrections",
      "headRefOid": "c9e4971e9b455f32ccf1b853b62c73916f9daf7a",
      "closedAt": "2024-03-07T01:32:52Z",
      "mergedAt": "2024-03-07T01:32:52Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "36470f84ec1f6bffd76dc98203298b7d031654f2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5r3V8P",
          "commit": {
            "abbreviatedOid": "62fb6cb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with some nits",
          "createdAt": "2024-01-08T17:30:26Z",
          "updatedAt": "2024-01-08T17:31:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nusing only their password.\r\n```",
              "createdAt": "2024-01-08T17:30:26Z",
              "updatedAt": "2024-01-08T17:31:39Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\n  However, this mechanism is out of scope for this document.\r\n```",
              "createdAt": "2024-01-08T17:30:55Z",
              "updatedAt": "2024-01-08T17:31:39Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\nof this mechanism are out of scope for this document.\r\n```",
              "createdAt": "2024-01-08T17:31:18Z",
              "updatedAt": "2024-01-08T17:31:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5r3tmw",
          "commit": {
            "abbreviatedOid": "62fb6cb"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-08T18:34:53Z",
          "updatedAt": "2024-01-08T18:34:53Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'm not native in English so it's very probable that my suggestion comes from another language.\n\nBut does putting the singular to password not mean something like \"the one password that all the clients have\" instead of \"the password of each client\"?",
              "createdAt": "2024-01-08T18:34:53Z",
              "updatedAt": "2024-01-09T17:30:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5yCGBd",
          "commit": {
            "abbreviatedOid": "0364883"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-03-03T23:33:39Z",
          "updatedAt": "2024-03-03T23:35:50Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "this change should be reverted",
              "createdAt": "2024-03-03T23:33:39Z",
              "updatedAt": "2024-03-03T23:35:50Z"
            },
            {
              "originalPosition": 123,
              "body": "I think a better change would be \"protect against\"",
              "createdAt": "2024-03-03T23:34:47Z",
              "updatedAt": "2024-03-03T23:35:50Z"
            },
            {
              "originalPosition": 8,
              "body": "I think it is best left singular, agree with Chris's suggestion here",
              "createdAt": "2024-03-03T23:35:28Z",
              "updatedAt": "2024-03-05T06:47:05Z"
            },
            {
              "originalPosition": 17,
              "body": "I would revert this change",
              "createdAt": "2024-03-03T23:35:40Z",
              "updatedAt": "2024-03-03T23:35:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs5yM6Jr",
          "commit": {
            "abbreviatedOid": "c9e4971"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I went ahead and addressed the comments I left with a commit, so I am approving now!",
          "createdAt": "2024-03-05T06:49:51Z",
          "updatedAt": "2024-03-05T06:49:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 439,
      "id": "PR_kwDOD79ejs5kMo6T",
      "title": "changed offline registration -> registration",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/439",
      "state": "MERGED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "reviewing the document at a whole for the rglc, i notice that registration is consistently referred to as \"offline registration\" - as the meme goes \"You Keep Using That Word, I Do Not Think It Means What You Think It Means\". most people understand offline as something that doesn't need a network connection. and with opaque `offline` in the context of `registration` has a much more nuanced and different meaning, which is confusing for the casual reader and implementer. and thus i think there is two options, the more expensive let's explicitly define \"offline\" in this context (and not mix it up with the other use through out this document in the context of attacks) or simply and cheaply delete the offline adjective from the context of registrations. i think this change eliminates one source of confusion and while doing so decreases entropy.",
      "createdAt": "2024-01-16T14:00:11Z",
      "updatedAt": "2024-03-07T01:33:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f036cf2dfcdf5a33b8f28c194003ac2455ba501b",
      "headRepository": "stef/draft-irtf-cfrg-opaque",
      "headRefName": "offline-registration",
      "headRefOid": "9059a19da6957dc53bb08065e5d1f38f0cef6fad",
      "closedAt": "2024-03-07T01:33:02Z",
      "mergedAt": "2024-03-07T01:33:02Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "e43e11328f9ef40481448c4f1a7931078fcd05e4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5yM182",
          "commit": {
            "abbreviatedOid": "9059a19"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Added some small adjustments to fix tests and catch one more spot where offline registration is mentioned. LGTM",
          "createdAt": "2024-03-05T06:35:28Z",
          "updatedAt": "2024-03-05T06:35:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 441,
      "id": "PR_kwDOD79ejs5kNRYR",
      "title": "export_key is only used by clients",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/441",
      "state": "MERGED",
      "author": "stef",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "only clients use the export_key.",
      "createdAt": "2024-01-16T15:05:31Z",
      "updatedAt": "2024-03-07T01:33:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f036cf2dfcdf5a33b8f28c194003ac2455ba501b",
      "headRepository": "stef/draft-irtf-cfrg-opaque",
      "headRefName": "export_key",
      "headRefOid": "203dd460f713f048a172b72aff5e48c4c7dd4928",
      "closedAt": "2024-03-07T01:33:12Z",
      "mergedAt": "2024-03-07T01:33:12Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "9b99e80632229f716377f6d201418ccad8a0e19a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5vu1l_",
          "commit": {
            "abbreviatedOid": "203dd46"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, makes sense!",
          "createdAt": "2024-02-12T05:03:52Z",
          "updatedAt": "2024-02-12T05:03:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 443,
      "id": "PR_kwDOD79ejs5mmLM0",
      "title": "Remove Related Protocols section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/443",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested in https://mailarchive.ietf.org/arch/msg/cfrg/Fxxdbe6sBae9yqTtZfwrGvtAKRQ/, this section is out-of-date and does not need to stay in the draft.",
      "createdAt": "2024-02-12T04:34:19Z",
      "updatedAt": "2024-03-09T01:02:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f036cf2dfcdf5a33b8f28c194003ac2455ba501b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "remove_related_protocols",
      "headRefOid": "4a6c2ed225a4173fbd11cb8e5f27fb3687d5822e",
      "closedAt": "2024-03-09T01:02:29Z",
      "mergedAt": "2024-03-09T01:02:29Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "da597bbd6bf1d876d27fa10db9fd98973d7f747b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5yzT-L",
          "commit": {
            "abbreviatedOid": "4a6c2ed"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-09T01:02:19Z",
          "updatedAt": "2024-03-09T01:02:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 445,
      "id": "PR_kwDOD79ejs5nlSK4",
      "title": "Clarifying the requirement that OPRF keys must be unique per client",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/445",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From correspondence with Hugo Krawczyk -- let's make it extra clear that OPRF keys must be unique per client (addendum to the security considerations section)",
      "createdAt": "2024-02-21T22:56:14Z",
      "updatedAt": "2024-03-09T01:44:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f036cf2dfcdf5a33b8f28c194003ac2455ba501b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_unique_oprf_keys_requirement",
      "headRefOid": "1b5b3a893dc29e0dc262ec52465441602d12b06c",
      "closedAt": "2024-03-09T01:44:54Z",
      "mergedAt": "2024-03-09T01:44:54Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "a4d55bd8ed60b0c57102fb8eb7fe9f47f648c21b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5yzXC4",
          "commit": {
            "abbreviatedOid": "1b5b3a8"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-09T01:44:46Z",
          "updatedAt": "2024-03-09T01:44:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 446,
      "id": "PR_kwDOD79ejs5n25fV",
      "title": "Update references to published drafts for voprf and h2c",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/446",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #442 \r\n\r\nUpdates references from \"draft voprf\" to RFC9497\r\nSame with draft hash-to-curve and RFC9380",
      "createdAt": "2024-02-26T01:58:22Z",
      "updatedAt": "2024-03-09T01:05:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f036cf2dfcdf5a33b8f28c194003ac2455ba501b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "update_oprf_refs",
      "headRefOid": "59b1de530335385bcf18bee9be136763772d9963",
      "closedAt": "2024-03-09T01:05:57Z",
      "mergedAt": "2024-03-09T01:05:57Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "6690ad48913b470391d704dfc5b16e21fc278671"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5yzUPH",
          "commit": {
            "abbreviatedOid": "59b1de5"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-09T01:05:51Z",
          "updatedAt": "2024-03-09T01:05:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 447,
      "id": "PR_kwDOD79ejs5o6Jfq",
      "title": "Updating acknowledgments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/447",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adding Marta Mularczyk under the Acknowledgments section",
      "createdAt": "2024-03-07T01:58:01Z",
      "updatedAt": "2024-03-09T01:59:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "6690ad48913b470391d704dfc5b16e21fc278671",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "update_acks",
      "headRefOid": "70328241b31d8dab11db83988d26b3445e8e9a24",
      "closedAt": "2024-03-09T01:45:57Z",
      "mergedAt": "2024-03-09T01:45:57Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "3f026d1dafd824a5fc3b98812d8a7b449b8c62a1"
      },
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d for adding @stef ",
          "createdAt": "2024-03-09T01:45:31Z",
          "updatedAt": "2024-03-09T01:45:31Z"
        },
        {
          "author": "stef",
          "authorAssociation": "CONTRIBUTOR",
          "body": "<3",
          "createdAt": "2024-03-09T01:59:22Z",
          "updatedAt": "2024-03-09T01:59:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5yzXJg",
          "commit": {
            "abbreviatedOid": "7032824"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-09T01:45:51Z",
          "updatedAt": "2024-03-09T01:45:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 448,
      "id": "PR_kwDOD79ejs5pJ-io",
      "title": "OPAQUE is an sdPAKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/448",
      "state": "MERGED",
      "author": "Sc00bz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "* Replaced \"asymmetric PAKE\" with augmented PAKE since \"asymmetric PAKE\" is incorrect terminology.\r\n* Added info on doubly augmented PAKEs (dPAKE).\r\n* Stated OPAQUE is a strong dPAKE (sdPAKE).\r\n* Replaced \"secure aPAKE\" with \"strong dPAKE\" (sdPAKE). Strong being what academic papers use to describe PAKEs that are secure against pre-computation attacks.\r\n\r\nThe following might need to be reworded or use a different source. Since JKX18 defined an saPAKE vs sdPAKE. The difference being that the client can also store data that can be used to authenticate to the server but not used to authenticate to the client. Lines 325-326:\r\n\r\n> \\- This document describes OPAQUE, an aPAKE that is secure against pre-computation attacks (as defined in {{JKX18}}).\r\n\r\n> \\+ This document describes OPAQUE, an sdPAKE (as defined in {{JKX18}}).\r\n\r\nNote I moved \"secure against pre-computation attacks\" to here since that's part of being an sdPAKE. Lines 312-313:\r\n\r\n> \\- A secure aPAKE should provide the best possible security for a password protocol.\r\n\r\n> \\+ A strong dPAKE (sdPAKE) should provide the best possible security for a password protocol which includes being secure against pre-computation attacks.\r\n\r\nAlso the \"Security Analysis\" section needs updating since the source proved the security of OPAQUE in an saPAKE model instead of an sdPAKE model. The difference in the proof is minor and would likely be obvious for anyone that knows how to write a proof. It's basically something along the lines of \"the private client identity key and public server identity key are unrelated to the password thus you can't use it to make offline password guesses. Without knowing the private server identity key means you can't authenticate as the server (which should already part of the saPAKE model proof).\" Also since it's an sdPAKE the client data can't be used for offline password guesses (even if the private keys are related to the password) because of the OPRF. Although I hear that people don't like \"story proofs\". So I'm not sure how to prove this correctly. Lines 2061-2063:\r\n\r\n> Jarecki et al. {{JKX18}} proved the security of OPAQUE (modulo the design differences outlined in {{notable-design-differences}}) in a strong aPAKE model...",
      "createdAt": "2024-03-09T23:36:03Z",
      "updatedAt": "2024-03-24T12:04:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4b3c6b117b0478872d8c3b3c1c07bd52aa82d028",
      "headRepository": "Sc00bz/draft-irtf-cfrg-opaque",
      "headRefName": "doubly-augmented",
      "headRefOid": "fa8886344917e53496dd4aacd7a40704b91c3423",
      "closedAt": "2024-03-24T12:04:20Z",
      "mergedAt": "2024-03-24T12:04:20Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "dc86a06db68367efca044b3ff45a1e244e2f2099"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@Sc00bz Thanks for the PR!\r\n\r\nI think the terminology change from \"asymmetric\" -> \"augmented\" is something I am supportive of (though don't have too strong of a preference either way)\r\n\r\nHowever, rather than defining OPAQUE as a strong doubly-augmented PAKE, I would prefer to still define OPAQUE as being a strong augmented PAKE, and then within the document we can also add a paragraph about the fact that it is doubly-augmented.\r\n\r\nThe reasons being that:\r\n- The proofs in the paper prove that it is a strong aPAKE and not a strong sdPAKE as you also remarked, and it is cleaner to simply say that the proofs support that it meets the bar of strong aPAKEs\r\n- The term \"doubly augmented\" is not as widely known as simply \"augmented\", and so I hesitate to include it in the title of the draft / first paragraph.\r\n- We can still include the points that you wanted in the doc about doubly-augmented, just surfaced less prominently, if that is alright with you!",
          "createdAt": "2024-03-11T23:03:50Z",
          "updatedAt": "2024-03-11T23:03:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Modified the PR to address my previous comments. Please see the text of the new subsection:\r\n\r\n> ## Client Authentication Using Credentials\r\n\r\nand let me know if this suffices. As mentioned above, I think we are aiming to avoid defining OPAQUE as a doubly augmented PAKE, even though it does satisfy those properties, because there isn't a proof for it at the moment (nor a formal UC-style definition of doubly-augmented), and the original OPAQUE paper only proves it with respect to a strong augmented PAKE.\r\n\r\nHowever, the property itself is still worth mentioning.\r\n\r\nThanks @Sc00bz and appreciate your patience on getting this right.",
          "createdAt": "2024-03-14T22:25:26Z",
          "updatedAt": "2024-03-14T22:25:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@Sc00bz ^ can you check the revisions that I made and let us know if this is acceptable? We'd like to merge this PR in and publish the next draft once this is unblocked. Thank you!",
          "createdAt": "2024-03-20T06:00:21Z",
          "updatedAt": "2024-03-20T06:00:21Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me :) thank you @Sc00bz and @kevinlewi ! \ud83d\udc4d",
          "createdAt": "2024-03-24T12:03:47Z",
          "updatedAt": "2024-03-24T12:03:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs50nRHm",
          "commit": {
            "abbreviatedOid": "d915914"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-24T00:00:41Z",
          "updatedAt": "2024-03-24T00:00:47Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I suggest we add that we give all the details on how to do it, adding that the OPRF finish/output and stretching can be skipped in favor of directly using the randomized henceforth. What do you think?",
              "createdAt": "2024-03-24T00:00:42Z",
              "updatedAt": "2024-03-24T00:00:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs50necE",
          "commit": {
            "abbreviatedOid": "d915914"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-24T08:50:53Z",
          "updatedAt": "2024-03-24T08:50:54Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Good idea. I added a little bit more to the description to clarify how this would be done. Let me know what you think!",
              "createdAt": "2024-03-24T08:50:53Z",
              "updatedAt": "2024-03-24T08:50:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs50ne1s",
          "commit": {
            "abbreviatedOid": "f1a658b"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-03-24T09:01:40Z",
          "updatedAt": "2024-03-24T09:02:53Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\nThis can be achieved by supplying an arbitrary password as input to\n`CreateCredentialRequest` in the login phase, and then using the `randomized_password` from the backup in `RecoverCredentials` (invoked by `GenerateKE3`) rather than computing it from\n```\n",
              "createdAt": "2024-03-24T09:01:40Z",
              "updatedAt": "2024-03-24T12:01:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs50nfkP",
          "commit": {
            "abbreviatedOid": "f1a658b"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-24T09:19:08Z",
          "updatedAt": "2024-03-24T09:19:08Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "(Updated, and removed the extraneous \"the\" before `randomized_password`)",
              "createdAt": "2024-03-24T09:19:08Z",
              "updatedAt": "2024-03-24T09:19:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs50nllN",
          "commit": {
            "abbreviatedOid": "fa88863"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-24T12:04:03Z",
          "updatedAt": "2024-03-24T12:04:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 449,
      "id": "PR_kwDOD79ejs5pr5xE",
      "title": "Clarifying wording about multiple seeds per client",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/449",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolving a slight wording ambiguity that could be interpreted not the way we intend. Servers should consistently assign one  seed for a client, but across clients, different seeds could be used, so long as they are kept consistent.\r\n\r\nSpawned from discussion offline with Hugo Krawczyk who requested this change.",
      "createdAt": "2024-03-14T22:30:30Z",
      "updatedAt": "2024-03-24T08:57:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3f026d1dafd824a5fc3b98812d8a7b449b8c62a1",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "clarifying_multiple_seeds",
      "headRefOid": "91664ba7394dd7ab31eef0135f17647a4ad8167c",
      "closedAt": "2024-03-24T08:57:45Z",
      "mergedAt": "2024-03-24T08:57:45Z",
      "mergedBy": "bytemare",
      "mergeCommit": {
        "oid": "4b3c6b117b0478872d8c3b3c1c07bd52aa82d028"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs50nQ7i",
          "commit": {
            "abbreviatedOid": "d9bf3f6"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-23T23:48:50Z",
          "updatedAt": "2024-03-23T23:49:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I find \"use different seeds for each client\" can be confusing.\n\nWhat do you think about \"use a different seed for each client (i.e. each client should...\" ?",
              "createdAt": "2024-03-23T23:48:50Z",
              "updatedAt": "2024-03-23T23:49:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs50nenY",
          "commit": {
            "abbreviatedOid": "d9bf3f6"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-24T08:55:54Z",
          "updatedAt": "2024-03-24T08:55:56Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Sounds good to me, thanks for the suggestion!",
              "createdAt": "2024-03-24T08:55:55Z",
              "updatedAt": "2024-03-24T08:55:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOD79ejs50neq8",
          "commit": {
            "abbreviatedOid": "91664ba"
          },
          "author": "bytemare",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-24T08:57:34Z",
          "updatedAt": "2024-03-24T08:57:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 454,
      "id": "PR_kwDOD79ejs5vvUqm",
      "title": "Adding distinction between 3-message and 2-message protocol in design differences section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/454",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a clarifying note that the original OPAQUE protocol described a 2-message protocol, but the one presented in this draft is a 3-message version. This is under the \"Notable Design Differences\" section.\r\n\r\nIt also adds a reference to the full version of the OPAQUE paper (https://eprint.iacr.org/2018/163) where the 3-message protocol is analyzed.",
      "createdAt": "2024-05-17T03:53:01Z",
      "updatedAt": "2024-05-21T04:17:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dc86a06db68367efca044b3ff45a1e244e2f2099",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_message_distinction",
      "headRefOid": "4cc8280f78764f7d6fcd76ddc4ab9d6a610aed01",
      "closedAt": "2024-05-21T04:17:08Z",
      "mergedAt": "2024-05-21T04:17:08Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "192d76e3442103a6d87582d83da97a92086e1b71"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 455,
      "id": "PR_kwDOD79ejs5wB1q2",
      "title": "Adding comment which caveats OPRF seed usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/455",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We are adding a caveat to the original text,\r\n\r\n\"The `oprf_seed` value SHOULD be used for all clients; see {{preventing-client-enumeration}}.\"\r\n\r\nThe reason being that the leakage of this global value would compromise security for all users that depend on this value, and one could arguably improve security of the protocol against this kind of compromise by sampling independent OPRF keys. However, we still keep the recommendation to use the global seed value in this way in favor of protecting against client enumeration attacks.\r\n\r\nBut, applications that don't care about preventing client enumeration can feel free to use independently-sampled OPRF keys.",
      "createdAt": "2024-05-21T04:45:19Z",
      "updatedAt": "2024-05-21T18:13:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "192d76e3442103a6d87582d83da97a92086e1b71",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "oprf_seed_clarification",
      "headRefOid": "d2738f06fed1e86b7cb24e9c417f56ea0321c3d4",
      "closedAt": "2024-05-21T18:13:01Z",
      "mergedAt": "2024-05-21T18:13:01Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "ff9c8927020d88816a2c45ac57e6a253277ef648"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs57SPRX",
          "commit": {
            "abbreviatedOid": "d2738f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-21T11:36:00Z",
          "updatedAt": "2024-05-21T11:36:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 456,
      "id": "PR_kwDOD79ejs5wtKB-",
      "title": "Adding note on handling online guessing attacks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/456",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adding some text to the Implementation Considerations section, by creating a subsection called \"Handling Online Guessing Attacks\", and highlighting the fact that servers should treat incomplete AKE interactions (after client receives KE2) as authentication failures by default.\r\n\r\n",
      "createdAt": "2024-05-28T00:44:56Z",
      "updatedAt": "2024-05-29T18:42:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ff9c8927020d88816a2c45ac57e6a253277ef648",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "online_guessing_attacks",
      "headRefOid": "03485c932cd333fccbdee21fae07768566d306b6",
      "closedAt": "2024-05-29T18:42:50Z",
      "mergedAt": "2024-05-29T18:42:50Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "b93489f0bd94dad0d283dc07893ed87e076aa2d9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs58FfSt",
          "commit": {
            "abbreviatedOid": "03485c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-28T05:59:16Z",
          "updatedAt": "2024-05-28T05:59:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 457,
      "id": "PR_kwDOD79ejs5yPppr",
      "title": "Final editorial nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/457",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-12T14:19:32Z",
      "updatedAt": "2024-06-12T21:09:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "b93489f0bd94dad0d283dc07893ed87e076aa2d9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/idnits",
      "headRefOid": "a59fd02202fc564ecff8493364026b30287822f8",
      "closedAt": "2024-06-12T21:09:17Z",
      "mergedAt": "2024-06-12T21:09:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0cd4251786b54c623bf1eceaff15892616e53ea6"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you also remove the TODO line:\r\n\r\n```\r\n<!--\r\nTODO(caw): As part of https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/312, address\r\nthe failure case that occurs when Blind fails, noting that this is an exceptional case that\r\nhappens with negligible probability\r\n-->\r\n```\r\n\r\non line 1944 of the file? (not sure why I couldn't make this comment directly on the line, sorry about that)",
          "createdAt": "2024-06-12T20:17:17Z",
          "updatedAt": "2024-06-12T20:17:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOD79ejs5-Az-C",
          "commit": {
            "abbreviatedOid": "6614590"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-12T20:19:28Z",
          "updatedAt": "2024-06-12T20:19:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 458,
      "id": "PR_kwDOD79ejs5z75z8",
      "title": "Adds inputs necessary for reproducing the fake test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/458",
      "state": "OPEN",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While working on updating the [opaque-ts](https://github.com/cloudflare/opaque-ts/) implementation I found that some extra fields are needed to reproduce the fake test vectors.\r\n\r\nIn particular, this allows the client to invoke the first part of login, and in the second part, after receiving a fake response from the server,  it should fail.\r\n\r\nSupport for draft v16: https://github.com/cloudflare/opaque-ts/pull/19",
      "createdAt": "2024-06-28T21:51:42Z",
      "updatedAt": "2024-06-28T21:51:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0cd4251786b54c623bf1eceaff15892616e53ea6",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "fakeVectors",
      "headRefOid": "83686d9c8018f0eb895f9b210a69c2d1d51da0fa",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}